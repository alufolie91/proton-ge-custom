diff --git a/dlls/winepulse.drv/pulse.c b/dlls/winepulse.drv/pulse.c
index 85062ead684..7d2fce8125b 100644
--- a/dlls/winepulse.drv/pulse.c
+++ b/dlls/winepulse.drv/pulse.c
@@ -59,6 +59,21 @@ DEFINE_GUID(GUID_NULL,0,0,0,0,0,0,0,0,0,0,0);
 
 WINE_DEFAULT_DEBUG_CHANNEL(pulse);
 
+static BOOL get_fast_polling_override(void)
+{
+    static int val = -1;
+    if (val == -1) {
+        const char *env = getenv("WINEPULSE_FAST_POLLING");
+        if (env && atoi(env) != 0) {
+            val = 1;
+            TRACE("Fast polling enabled via env var\n");
+        } else {
+            val = 0;
+        }
+    }
+    return val == 1;
+}
+
 enum phys_device_bus_type {
     phys_device_bus_invalid = -1,
     phys_device_bus_pci,
@@ -109,6 +124,7 @@ struct pulse_stream
     struct list packet_filled_head;
     struct list period_entry;
     struct pulse_period *period;
+    SIZE_T rem_samples;
 };
 
 typedef struct _ACPacket
@@ -1279,7 +1295,7 @@ static NTSTATUS pulse_create_stream(void *args)
 
     stream->bufsize_frames = ceil((params->duration / 10000000.) * params->fmt->nSamplesPerSec);
     bufsize_bytes = stream->bufsize_frames * pa_frame_size(&stream->ss);
-    stream->mmdev_period_usec = params->period / 10;
+    stream->mmdev_period_usec = params->period / (get_fast_polling_override() ? 50 : 10); 
 
     stream->share = params->share;
     stream->flags = params->flags;
@@ -1639,7 +1655,7 @@ static void pa_streams_timer_cb(pa_mainloop_api *api, pa_time_event *e, const st
 {
     struct pulse_period *period = userdata;
     struct pulse_stream *stream;
-    UINT32 adv_bytes;
+    UINT32 adv_bytes = 0;
 
     period->timer_last_time += period->period;
 
@@ -1653,19 +1669,69 @@ static void pa_streams_timer_cb(pa_mainloop_api *api, pa_time_event *e, const st
             {
                 pulse_write(stream);
 
-                /* regardless of what PA does, advance one period */
-                adv_bytes = min(stream->period_bytes, stream->held_bytes);
-                stream->lcl_offs_bytes += adv_bytes;
-                stream->lcl_offs_bytes %= stream->real_bufsize_bytes;
-                stream->held_bytes -= adv_bytes;
-            }
+                if (get_fast_polling_override())
+                {
+                    /* --- FAST POLLING LOGIC --- */
+                    SIZE_T frame_size = pa_frame_size(&stream->ss);
+                    UINT64 total_samples;
+                    SIZE_T safe_bytes;
+
+                    total_samples = stream->mmdev_period_usec * stream->ss.rate + stream->rem_samples;
+                    adv_bytes = (total_samples / 1000000) * frame_size;
+                    stream->rem_samples = total_samples % 1000000;
+
+                    if (adv_bytes > stream->held_bytes)
+                    {
+                        adv_bytes = stream->held_bytes;
+                        stream->rem_samples = 0;
+                    }
+
+                    safe_bytes = adv_bytes;
+                    
+                    if (stream->held_bytes > stream->pa_held_bytes)
+                    {
+                        SIZE_T limit = stream->held_bytes - stream->pa_held_bytes;
+                        if (safe_bytes > limit)
+                            safe_bytes = limit;
+                    }
+                    if (safe_bytes < adv_bytes)
+                    {
+                        TRACE("Braking timer: wanted %u, moved %u (suppressed %u bytes of pop)\n", 
+                              (unsigned int)adv_bytes, 
+                              (unsigned int)safe_bytes, 
+                              (unsigned int)(adv_bytes - safe_bytes));
+                    }
+                    stream->lcl_offs_bytes = (stream->lcl_offs_bytes + safe_bytes) % stream->real_bufsize_bytes;
+                    stream->held_bytes -= safe_bytes;
+                }
+                else
+                {
+                    /* --- ORIGINAL LOGIC --- */
+                    /* regardless of what PA does, advance one period */
+                    adv_bytes = min(stream->period_bytes, stream->held_bytes);
+                    stream->lcl_offs_bytes += adv_bytes;
+                    stream->lcl_offs_bytes %= stream->real_bufsize_bytes;
+                    stream->held_bytes -= adv_bytes;
+                }
+            } 
             else if(stream->dataflow == eCapture)
             {
                 pulse_read(stream);
             }
         }
-        if (stream->event)
-            NtSetEvent(stream->event, NULL);
+         if (get_fast_polling_override())
+        {
+             if (stream->dataflow == eCapture || 
+                 stream->held_bytes == 0  || 
+                ((stream->held_bytes + adv_bytes) / stream->period_bytes != stream->held_bytes / stream->period_bytes))
+             {
+                 if (stream->event) NtSetEvent(stream->event, NULL);
+             }
+        }
+        else
+        {
+             if (stream->event) NtSetEvent(stream->event, NULL);
+        } 
     }
     pa_context_rttime_restart(pulse_ctx, e, period->timer_last_time + period->period);
 }
