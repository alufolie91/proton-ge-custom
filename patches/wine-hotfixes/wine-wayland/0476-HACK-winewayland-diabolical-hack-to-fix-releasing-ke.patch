From 45307ce9abea42af7e4c57fcb1ed65cc13e2b31a Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 6 Jan 2026 21:55:59 -0500
Subject: [PATCH 476/479] HACK: winewayland: diabolical hack to fix releasing
 keys like meta and alt on leave.

---
 dlls/winewayland.drv/wayland_keyboard.c | 41 +++++++++++++++++++++----
 1 file changed, 35 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index d6caf271599..790d2c51fcf 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -825,6 +825,7 @@ static void release_all_keys(HWND hwnd)
 
         if (state[vkey] & 0x80)
         {
+            TRACE("releasing vkey %x\n", vkey);
             send_vkey_input(hwnd, vkey, KEYEVENTF_KEYUP);
         }
     }
@@ -1030,8 +1031,10 @@ static void set_async_key_state(const BYTE state[256])
     SERVER_END_REQ;
 }
 
-/* TODO: Find a way to cleanup the duplicated code */
-static void sync_mod_state(HWND hwnd)
+/* FIXME: rewrite this to make more sense, and make it more concise
+ *        do we need to do normal send hardware input along with the trick to trigger a lock?
+ */
+static void sync_locked_mod_state(HWND hwnd)
 {
     struct wayland_keyboard *keyboard = &process_wayland.keyboard;
     BOOL numlock_active, caplock_active;
@@ -1095,6 +1098,32 @@ static void sync_mod_state(HWND hwnd)
     }
 }
 
+static void sync_depressed_mod_state(HWND hwnd, UINT scan, UINT state)
+{
+    /* limited selection for now until this is tested further */
+    UINT mod_keys[] = { KEY_LEFTALT, KEY_RIGHTALT, KEY_LEFTMETA, KEY_RIGHTMETA };
+    BYTE keystate[256];
+    UINT vkey;
+
+    for (int i = 0; i < ARRAY_SIZE(mod_keys); i++)
+        if (scan == key2scan(mod_keys[i])) goto found;
+    return;
+found:
+
+    if (!NtUserGetAsyncKeyboardState(keystate)) return;
+
+    if (!(vkey = NtUserMapVirtualKeyEx(scan, MAPVK_VSC_TO_VK_EX, keyboard_hkl))) return;
+
+    if (!!(keystate[vkey] & 0x80) == state) return;
+
+    WARN("keystate not changed for vkey %x, probably blocked by hooks\n", vkey);
+
+    if (state) keystate[vkey] |= 0x80;
+    else keystate[vkey] &= ~0x80;
+
+    set_async_key_state(keystate);
+}
+
 static void keyboard_handle_key(void *data, struct wl_keyboard *wl_keyboard,
                                 uint32_t serial, uint32_t time, uint32_t key,
                                 uint32_t state)
@@ -1114,11 +1143,8 @@ static void keyboard_handle_key(void *data, struct wl_keyboard *wl_keyboard,
 
     TRACE_(key)("serial=%u hwnd=%p key=%d scan=%#x state=%#x\n", serial, hwnd, key, scan, state);
 
-    /* these keys would need to be handled in a special way otherwise they cause issues */
-    if (key == KEY_LEFTMETA || key == KEY_RIGHTMETA) return;
-
     if (key != KEY_NUMLOCK && key != KEY_CAPSLOCK)
-        sync_mod_state(hwnd);
+        sync_locked_mod_state(hwnd);
 
     /* NOTE: Windows normally sends VK_CONTROL + VK_MENU only if the layout has KLLF_ALTGR */
     if (key == KEY_RIGHTALT) send_right_control(hwnd, state);
@@ -1131,6 +1157,9 @@ static void keyboard_handle_key(void *data, struct wl_keyboard *wl_keyboard,
     if (state == WL_KEYBOARD_KEY_STATE_RELEASED) input.ki.dwFlags |= KEYEVENTF_KEYUP;
 
     NtUserSendHardwareInput(hwnd, 0, &input, 0);
+
+    /* some modifiers will be blocked by hooks, so force update their key states */
+    sync_depressed_mod_state(hwnd, scan, state == WL_KEYBOARD_KEY_STATE_PRESSED);
 }
 
 static void keyboard_handle_modifiers(void *data, struct wl_keyboard *wl_keyboard,
-- 
2.52.0

