From 78a68e6440b0d1f2719035246a5a7d298b198d9e Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 15 Aug 2025 21:51:16 -0400
Subject: [PATCH 331/339] winewayland: Optimize steam overlay active detection.

---
 dlls/winewayland.drv/wayland_pointer.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 038beacbee5..53473389de6 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -150,8 +150,6 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy, BOOL se
 
     wayland_win_data_release(data);
 
-    if (wayland_is_overlay_active()) return;
-
     if (!send_input)
     {
         pthread_mutex_lock(&pointer->mutex);
@@ -165,6 +163,8 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy, BOOL se
     } else {
         INPUT input = {0};
 
+        if (wayland_is_overlay_active()) return;
+
         input.type = INPUT_MOUSE;
         input.mi.dx = screen.x;
         input.mi.dy = screen.y;
@@ -313,7 +313,6 @@ static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (InterlockedCompareExchange(&pointer->pointer_frame.discrete_event_handled, FALSE, TRUE)) return;
-    if (wayland_is_overlay_active()) return;
 
     pthread_mutex_lock(&pointer->mutex);
 
@@ -363,6 +362,8 @@ static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
 
     pthread_mutex_lock(&pointer->mutex);
 
+    if (wayland_is_overlay_active()) goto skip;
+
     input.type = INPUT_MOUSE;
 
     if (pointer->pointer_frame.flags & WAYLAND_POINTER_FRAME_ABS)
@@ -409,6 +410,7 @@ static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
             NtUserSendHardwareInput(hwnd, 0, &input, 0);
     }
 
+skip:
     /* reset accumulators when scroll event ends */
     if (pointer->pointer_frame.axis_stop & WAYLAND_POINTER_AXIS_STOP_VERTICAL)
         pointer->pointer_frame.wheel = 0;
@@ -455,7 +457,6 @@ static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_point
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
-    if (wayland_is_overlay_active()) return;
 
     InterlockedExchange(&pointer->pointer_frame.discrete_event_handled, TRUE);
 
@@ -537,7 +538,6 @@ static void relative_pointer_v1_relative_motion(void *private,
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (!(data = wayland_win_data_get(hwnd))) return;
-    if (wayland_is_overlay_active()) return;
 
     f_dxu = wl_fixed_to_double(dx_unaccel);
     f_dyu = wl_fixed_to_double(dy_unaccel);
-- 
2.50.1

