From 733038b7d6deed60a33500b6cbf30879100f739a Mon Sep 17 00:00:00 2001
From: Yuxuan Shui <yshui@codeweavers.com>
Date: Tue, 25 Mar 2025 10:34:56 +0000
Subject: [PATCH 001/339] winegstreamer: Make sure WMSyncReader never reads in
 the background.

WMSyncReader starts a background read thread that reads from the IStream
passed to IWMSyncReader::OpenStream. This means it could use the IStream in the
background even when no IWMSyncReader methods are being called.

For well-behaved applications, this is probably OK. However, AQUARIUM
(Steam 2515070) frees the IStream it passes to WMSyncReader _before_
it calls IWMSyncReader::Close, which stops the read thread. This causes
the read thread to access freed memory. This is improper, but not
unreasonable, as IWMSyncReader is supposed to be a synchronous
interface, so one might assume when they weren't calling into
IWMSyncReader methods, the IStream won't be used.

This commit adds a `wg_parser_dont_read` function, which can be used to
stop wg_parser from issuing read requests. This is used by IWMSyncReader
to make sure read requests are only issued when IWMSyncReader methods
are being called.

CW-Bug-Id: #24933
---
 dlls/winegstreamer/gst_private.h |  1 +
 dlls/winegstreamer/main.c        | 11 +++++++++
 dlls/winegstreamer/unixlib.h     |  8 +++++++
 dlls/winegstreamer/wg_parser.c   | 38 ++++++++++++++++++++++++++++++--
 dlls/winegstreamer/wm_reader.c   | 13 ++++++++++-
 5 files changed, 68 insertions(+), 3 deletions(-)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index c64e9ca251d..fa9bc4e4089 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -74,6 +74,7 @@ void wg_sample_queue_flush(struct wg_sample_queue *queue, bool all);
 
 wg_parser_t wg_parser_create(bool output_compressed, bool use_opengl);
 void wg_parser_destroy(wg_parser_t parser);
+void wg_parser_dont_read(wg_parser_t parser, bool dont_read);
 
 HRESULT wg_parser_connect(wg_parser_t parser, uint64_t file_size, const WCHAR *uri);
 void wg_parser_disconnect(wg_parser_t parser);
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index c1b7a7a7bda..6edd7233cfb 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -190,6 +190,17 @@ void wg_parser_destroy(wg_parser_t parser)
     WINE_UNIX_CALL(unix_wg_parser_destroy, &parser);
 }
 
+void wg_parser_dont_read(wg_parser_t parser, bool dont_read)
+{
+    TRACE("%#I64x %d\n", parser, dont_read);
+    struct wg_parser_dont_read_params params =
+    {
+        .parser = parser,
+        .dont_read = dont_read,
+    };
+    WINE_UNIX_CALL(unix_wg_parser_dont_read, &params);
+}
+
 HRESULT wg_parser_connect(wg_parser_t parser, uint64_t file_size, const WCHAR *uri)
 {
     struct wg_parser_connect_params params =
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 7cb5855e509..2daed9f78c8 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -227,6 +227,12 @@ struct wg_parser_create_params
     UINT8 warn_on;
 };
 
+struct wg_parser_dont_read_params
+{
+    wg_parser_t parser;
+    UINT8 dont_read;
+};
+
 struct wg_parser_connect_params
 {
     wg_parser_t parser;
@@ -426,6 +432,8 @@ enum unix_funcs
     unix_wg_parser_create,
     unix_wg_parser_destroy,
 
+    unix_wg_parser_dont_read,
+
     unix_wg_parser_connect,
     unix_wg_parser_disconnect,
 
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 9755548790d..f04499d5cf8 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -88,13 +88,14 @@ struct wg_parser
     bool no_more_pads, has_duration, error;
     bool err_on, warn_on;
 
-    pthread_cond_t read_cond, read_done_cond;
+    pthread_cond_t read_cond, read_done_cond, dont_read_cond;
     struct
     {
         GstBuffer *buffer;
         uint64_t offset;
         uint32_t size;
         bool done;
+        uint32_t n_read_tokens;
         GstFlowReturn ret;
     } read_request;
 
@@ -232,7 +233,7 @@ static NTSTATUS wg_parser_push_data(void *args)
     parser->read_request.size = 0;
 
     pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&parser->read_done_cond);
+    pthread_cond_broadcast(&parser->read_done_cond);
 
     return S_OK;
 }
@@ -1225,6 +1226,8 @@ static GstFlowReturn issue_read_request(struct wg_parser *parser, guint64 offset
     GstFlowReturn ret;
 
     pthread_mutex_lock(&parser->mutex);
+    while (parser->read_request.n_read_tokens == 0)
+        pthread_cond_wait(&parser->dont_read_cond, &parser->mutex);
 
     assert(!parser->read_request.size);
     parser->read_request.buffer = *buffer;
@@ -1775,6 +1778,30 @@ static void query_tags(struct wg_parser_stream *stream)
     gst_object_unref(peer);
 }
 
+static NTSTATUS wg_parser_dont_read(void *args)
+{
+    const struct wg_parser_dont_read_params *params = args;
+    struct wg_parser *parser = get_parser(params->parser);
+    pthread_mutex_lock(&parser->mutex);
+
+    if (!params->dont_read)
+    {
+        if ((parser->read_request.n_read_tokens++) == 0)
+            pthread_cond_signal(&parser->dont_read_cond);
+    }
+    else if (parser->read_request.n_read_tokens == 0)
+        GST_ERROR("Trying to stop read when it's already stopped!");
+    else if ((--parser->read_request.n_read_tokens) == 0)
+    {
+        /* wait for current read condition to finish */
+        while (!parser->read_request.done)
+            pthread_cond_wait(&parser->read_done_cond, &parser->mutex);
+    }
+
+    pthread_mutex_unlock(&parser->mutex);
+    return S_OK;
+}
+
 static NTSTATUS wg_parser_connect(void *args)
 {
     GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE("quartz_src",
@@ -2092,9 +2119,11 @@ static NTSTATUS wg_parser_create(void *args)
     pthread_cond_init(&parser->init_cond, NULL);
     pthread_cond_init(&parser->read_cond, NULL);
     pthread_cond_init(&parser->read_done_cond, NULL);
+    pthread_cond_init(&parser->dont_read_cond, NULL);
     parser->output_compressed = params->output_compressed;
     parser->err_on = params->err_on;
     parser->warn_on = params->warn_on;
+    parser->read_request.n_read_tokens = 1;
     GST_DEBUG("Created winegstreamer parser %p.", parser);
     params->parser = (wg_parser_t)(ULONG_PTR)parser;
     return S_OK;
@@ -2118,6 +2147,7 @@ static NTSTATUS wg_parser_destroy(void *args)
     pthread_cond_destroy(&parser->init_cond);
     pthread_cond_destroy(&parser->read_cond);
     pthread_cond_destroy(&parser->read_done_cond);
+    pthread_cond_destroy(&parser->dont_read_cond);
 
     free(parser->uri);
     free(parser);
@@ -2132,6 +2162,8 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     X(wg_parser_create),
     X(wg_parser_destroy),
 
+    X(wg_parser_dont_read),
+
     X(wg_parser_connect),
     X(wg_parser_disconnect),
 
@@ -2529,6 +2561,8 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
     X(wg_parser_create),
     X(wg_parser_destroy),
 
+    X(wg_parser_dont_read),
+
     X64(wg_parser_connect),
     X(wg_parser_disconnect),
 
diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 9145f59f474..ca590957f4a 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -1612,7 +1612,7 @@ static HRESULT init_stream(struct wm_reader *reader)
      * Now that they're all enabled seek back to the start again. */
     wg_parser_stream_seek(reader->streams[0].wg_stream, 1.0, 0, 0,
             AM_SEEKING_AbsolutePositioning, AM_SEEKING_NoPositioning);
-
+    wg_parser_dont_read(reader->wg_parser, true);
     return S_OK;
 
 out_disconnect_parser:
@@ -1652,6 +1652,7 @@ static HRESULT reinit_stream(struct wm_reader *reader, bool read_compressed)
     enable_opengl = FALSE;
 }
 
+    wg_parser_dont_read(reader->wg_parser, false);
     wg_parser_disconnect(reader->wg_parser);
 
     EnterCriticalSection(&reader->shutdown_cs);
@@ -1701,6 +1702,7 @@ static HRESULT reinit_stream(struct wm_reader *reader, bool read_compressed)
      * Now that they're all enabled seek back to the start again. */
     wg_parser_stream_seek(reader->streams[0].wg_stream, 1.0, 0, 0,
             AM_SEEKING_AbsolutePositioning, AM_SEEKING_NoPositioning);
+    wg_parser_dont_read(reader->wg_parser, true);
 
     return S_OK;
 
@@ -1993,6 +1995,7 @@ static HRESULT WINAPI reader_Close(IWMSyncReader2 *iface)
         return NS_E_INVALID_REQUEST;
     }
 
+    wg_parser_dont_read(reader->wg_parser, false);
     wg_parser_disconnect(reader->wg_parser);
 
     EnterCriticalSection(&reader->shutdown_cs);
@@ -2062,6 +2065,8 @@ static HRESULT WINAPI reader_GetNextSample(IWMSyncReader2 *iface,
     if (!stream_number && !output_number && !ret_stream_number)
         return E_INVALIDARG;
 
+    wg_parser_dont_read(reader->wg_parser, false);
+
     if (reader->outer == &reader->IUnknown_inner)
         EnterCriticalSection(&reader->cs);
 
@@ -2103,6 +2108,7 @@ static HRESULT WINAPI reader_GetNextSample(IWMSyncReader2 *iface,
 
     if (reader->outer == &reader->IUnknown_inner)
         LeaveCriticalSection(&reader->cs);
+    wg_parser_dont_read(reader->wg_parser, true);
     return hr;
 }
 
@@ -2546,6 +2552,7 @@ static HRESULT WINAPI reader_SetRange(IWMSyncReader2 *iface, QWORD start, LONGLO
 
     TRACE("reader %p, start %I64u, duration %I64d.\n", reader, start, duration);
 
+    wg_parser_dont_read(reader->wg_parser, false);
     EnterCriticalSection(&reader->cs);
 
     reader->start_time = start;
@@ -2557,6 +2564,7 @@ static HRESULT WINAPI reader_SetRange(IWMSyncReader2 *iface, QWORD start, LONGLO
         reader->streams[i].eos = false;
 
     LeaveCriticalSection(&reader->cs);
+    wg_parser_dont_read(reader->wg_parser, true);
     return S_OK;
 }
 
@@ -2621,6 +2629,7 @@ static HRESULT WINAPI reader_SetStreamsSelected(IWMSyncReader2 *iface,
     if (!count)
         return E_INVALIDARG;
 
+    wg_parser_dont_read(reader->wg_parser, false);
     EnterCriticalSection(&reader->cs);
 
     for (i = 0; i < count; ++i)
@@ -2629,6 +2638,7 @@ static HRESULT WINAPI reader_SetStreamsSelected(IWMSyncReader2 *iface,
         {
             LeaveCriticalSection(&reader->cs);
             WARN("Invalid stream number %u; returning NS_E_INVALID_REQUEST.\n", stream_numbers[i]);
+            wg_parser_dont_read(reader->wg_parser, true);
             return NS_E_INVALID_REQUEST;
         }
     }
@@ -2662,6 +2672,7 @@ static HRESULT WINAPI reader_SetStreamsSelected(IWMSyncReader2 *iface,
     }
 
     LeaveCriticalSection(&reader->cs);
+    wg_parser_dont_read(reader->wg_parser, true);
     return S_OK;
 }
 
-- 
2.50.1

