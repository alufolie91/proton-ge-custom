From 0a15ab74b88ae6217e1a889b0e77a64774531acf Mon Sep 17 00:00:00 2001
From: Alexandre Julliard <julliard@winehq.org>
Date: Tue, 20 May 2025 22:21:24 +0200
Subject: [PATCH 383/414] winedump: Dump syscall numbers.

---
 tools/winedump/pe.c | 104 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 104 insertions(+)

diff --git a/tools/winedump/pe.c b/tools/winedump/pe.c
index 4dab6aceb79..2d59ac46501 100644
--- a/tools/winedump/pe.c
+++ b/tools/winedump/pe.c
@@ -764,6 +764,109 @@ static const char *get_function_name( UINT rva )
     return name;
 }
 
+static int match_pattern( const BYTE *instr, const BYTE *pattern, int len )
+{
+    for (int i = 0; i < len; i++) if (pattern[i] && pattern[i] != instr[i]) return 0;
+    return 1;
+}
+
+static void dump_export_flags( UINT rva )
+{
+    switch (PE_nt_headers->FileHeader.Machine)
+    {
+    case IMAGE_FILE_MACHINE_I386:
+    {
+        static const BYTE patterns[][18] =
+        {
+            { 0xb8, 0, 0, 0, 0, 0xba, 0, 0, 0, 0, 0xff, 0xd2 }, /* >= win10 */
+            { 0xb8, 0, 0, 0, 0, 0xba, 0, 0, 0, 0, 0xff, 0x12 }, /* winxp */
+            { 0xb8, 0, 0, 0, 0, 0x64, 0xff, 0x15, 0xc0, 0, 0, 0 },  /* nt */
+            { 0xb8, 0, 0, 0, 0, 0x8d, 0x54, 0x24, 0x04, 0xcd, 0x2e }, /* nt */
+            { 0xb8, 0, 0, 0, 0, 0xb9, 0, 0, 0, 0, 0x8d, 0x54, 0x24, 0x04, 0x64, 0xff, 0x15, 0xc0 }, /* vista */
+            { 0xb8, 0, 0, 0, 0, 0x33, 0xc9, 0x8d, 0x54, 0x24, 0x04, 0x64, 0xff, 0x15, 0xc0 }, /* vista */
+            { 0xb8, 0, 0, 0, 0, 0xe8, 0, 0, 0, 0, 0x8d, 0x54, 0x24, 0x04, 0x64, 0xff, 0x15, 0xc0 }, /* win8 */
+            { 0xb8, 0, 0, 0, 0, 0xe8, 0x01, 0, 0, 0, 0xc3, 0x8b, 0xd4, 0x0f, 0x34, 0xc3 },  /* win8 */
+            { 0xb8, 0, 0, 0, 0, 0xe8, 0x03, 0, 0, 0, 0xc2, 0, 0, 0x8b, 0xd4, 0x0f, 0x34, 0xc3 }, /* win8 */
+        };
+        const BYTE *instr = RVA( rva, 32 );
+
+        if (!instr) break;
+        for (UINT i = 0; i < ARRAY_SIZE(patterns); i++)
+        {
+            if (match_pattern( instr, patterns[i], ARRAY_SIZE(patterns[0]) ))
+            {
+                printf( "  [syscall=%04x]", *(UINT *)(instr + 1) );
+                return;
+            }
+        }
+        break;
+    }
+    case IMAGE_FILE_MACHINE_AMD64:
+    {
+        static const BYTE patterns[][20] =
+        {
+            { 0x4c, 0x8b, 0xd1, 0xb8, 0, 0, 0, 0, 0xf6, 0x04, 0x25, 0x08, 0x03, 0xfe,
+              0x7f, 0x01, 0x75, 0x03, 0x0f, 0x05 },  /* >= win10 */
+            { 0x4c, 0x8b, 0xd1, 0xb8, 0, 0, 0, 0, 0x0f, 0x05, 0xc3 }, /* < win10 */
+        };
+        const BYTE *instr = RVA( rva, 32 );
+
+        if (!instr) break;
+        for (UINT i = 0; i < ARRAY_SIZE(patterns); i++)
+        {
+            if (match_pattern( instr, patterns[i], ARRAY_SIZE(patterns[0]) ))
+            {
+                printf( "  [syscall=%04x]", ((UINT *)instr)[1] );
+                return;
+            }
+        }
+        break;
+    }
+    case IMAGE_FILE_MACHINE_ARM64:
+    {
+        const UINT *instr = RVA( rva, 32 );
+
+        if (!instr) break;
+        if (((instr[0] & 0xffe0001f) == 0xd4000001 && instr[1] == 0xd65f03c0) || /* windows */
+            ((instr[0] & 0xffe0001f) == 0xd2800008 && instr[1] == 0xaa1e03e9 && /* wine */
+             instr[3] == 0xf9400210 && instr[4] == 0xd63f0200 && instr[5] == 0xd65f03c0))
+            printf( "  [syscall=%04x]", (instr[0] >> 5) & 0xffff );
+        break;
+    }
+    case IMAGE_FILE_MACHINE_ARMNT:
+    {
+        const USHORT *instr = RVA( rva & ~1, 16 );
+        if (!instr) break;
+        if (instr[0] == 0xb40f && (instr[2] & 0x0f00) == 0x0c00 &&
+            ((instr[3] == 0xdef8 && instr[4] == 0xb004 && instr[5] == 0x4770) ||  /* windows */
+             (instr[3] == 0x4673 && instr[6] == 0xb004 && instr[7] == 0x4770)))  /* wine */
+        {
+            USHORT imm = ((instr[1] & 0x400) << 1) | (instr[2] & 0xff) | ((instr[2] >> 4) & 0x0700);
+            if ((instr[1] & 0xfbf0) == 0xf240)  /* T3 */
+            {
+                imm |= (instr[1] & 0x0f) << 12;
+                printf( "  [syscall=%04x]", imm );
+            }
+            else if ((instr[1] & 0xfbf0) == 0xf040)  /* T2 */
+            {
+                switch (imm >> 8)
+                {
+                case 0: break;
+                case 1: imm = (imm & 0xff); break;
+                case 2: imm = (imm & 0xff) << 8; break;
+                case 3: imm = (imm & 0xff) | ((imm & 0xff) << 8); break;
+                default: imm = (0x80 | (imm & 0x7f)) << (32 - (imm >> 7)); break;
+                }
+                printf( "  [syscall=%04x]", imm );
+            }
+        }
+        break;
+    }
+    default:
+        break;
+    }
+}
+
 static	void	dump_dir_exported_functions(void)
 {
     unsigned int size;
@@ -813,6 +916,7 @@ static	void	dump_dir_exported_functions(void)
         if ((const char *)RVA(pFunc[i],1) >= (const char *)dir &&
             (const char *)RVA(pFunc[i],1) < (const char *)dir + size)
             printf(" (-> %s)", (const char *)RVA(pFunc[i],1));
+        dump_export_flags( pFunc[i] );
         printf("\n");
     }
     free(funcs);
-- 
2.51.1

