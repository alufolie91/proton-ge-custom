From b7ddd8b06957da9945d3d52ca0662f92165f1b08 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 24 Nov 2025 23:05:08 -0600
Subject: [PATCH 002/406] Reapply "ntdll: Implement
 NtAlertMultipleThreadByThreadId()."

This reverts commit 4eece26b263f7b6bc90016501ab59f4c065c3249.
---
 dlls/ntdll/ntdll.spec       |  2 ++
 dlls/ntdll/signal_arm64ec.c |  1 +
 dlls/ntdll/tests/sync.c     | 49 +++++++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/sync.c      | 27 ++++++++++++++++++++
 dlls/wow64/process.c        | 20 +++++++++++++++
 include/winternl.h          |  1 +
 6 files changed, 100 insertions(+)

diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index c4e4d6a17e8..ba1c5a039a2 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -142,6 +142,7 @@
 # @ stub NtAddBootEntry
 @ stdcall -syscall NtAdjustGroupsToken(long long ptr long ptr ptr)
 @ stdcall -syscall NtAdjustPrivilegesToken(long long ptr long ptr ptr)
+@ stdcall -syscall NtAlertMultipleThreadByThreadId(ptr long ptr ptr)
 @ stdcall -syscall NtAlertResumeThread(long ptr)
 @ stdcall -syscall NtAlertThread(long)
 @ stdcall -syscall NtAlertThreadByThreadId(ptr)
@@ -1217,6 +1218,7 @@
 # @ stub ZwAddBootEntry
 @ stdcall -private -syscall ZwAdjustGroupsToken(long long ptr long ptr ptr) NtAdjustGroupsToken
 @ stdcall -private -syscall ZwAdjustPrivilegesToken(long long ptr long ptr ptr) NtAdjustPrivilegesToken
+@ stdcall -private -syscall ZwAlertMultipleThreadByThreadId(ptr long ptr ptr) NtAlertMultipleThreadByThreadId
 @ stdcall -private -syscall ZwAlertResumeThread(long ptr) NtAlertResumeThread
 @ stdcall -private -syscall ZwAlertThread(long) NtAlertThread
 @ stdcall -private -syscall ZwAlertThreadByThreadId(ptr) NtAlertThreadByThreadId
diff --git a/dlls/ntdll/signal_arm64ec.c b/dlls/ntdll/signal_arm64ec.c
index 477ee13629c..88bdeaae2f4 100644
--- a/dlls/ntdll/signal_arm64ec.c
+++ b/dlls/ntdll/signal_arm64ec.c
@@ -352,6 +352,7 @@ DEFINE_SYSCALL(NtAccessCheckAndAuditAlarm, (UNICODE_STRING *subsystem, HANDLE ha
 DEFINE_SYSCALL(NtAddAtom, (const WCHAR *name, ULONG length, RTL_ATOM *atom))
 DEFINE_SYSCALL(NtAdjustGroupsToken, (HANDLE token, BOOLEAN reset, TOKEN_GROUPS *groups, ULONG length, TOKEN_GROUPS *prev, ULONG *retlen))
 DEFINE_SYSCALL(NtAdjustPrivilegesToken, (HANDLE token, BOOLEAN disable, TOKEN_PRIVILEGES *privs, DWORD length, TOKEN_PRIVILEGES *prev, DWORD *retlen))
+DEFINE_SYSCALL(NtAlertMultipleThreadByThreadId, (HANDLE *tids, ULONG count, void *unk1, void *unk2))
 DEFINE_SYSCALL(NtAlertResumeThread, (HANDLE handle, ULONG *count))
 DEFINE_SYSCALL(NtAlertThread, (HANDLE handle))
 DEFINE_SYSCALL(NtAlertThreadByThreadId, (HANDLE tid))
diff --git a/dlls/ntdll/tests/sync.c b/dlls/ntdll/tests/sync.c
index e2967c7873c..6daeb75942e 100644
--- a/dlls/ntdll/tests/sync.c
+++ b/dlls/ntdll/tests/sync.c
@@ -27,6 +27,7 @@
 #include "setjmp.h"
 #include "wine/test.h"
 
+static NTSTATUS (WINAPI *pNtAlertMultipleThreadByThreadId)( HANDLE *, ULONG, void *, void * );
 static NTSTATUS (WINAPI *pNtAlertThreadByThreadId)( HANDLE );
 static NTSTATUS (WINAPI *pNtClose)( HANDLE );
 static NTSTATUS (WINAPI *pNtCreateEvent) ( PHANDLE, ACCESS_MASK, const OBJECT_ATTRIBUTES *, EVENT_TYPE, BOOLEAN);
@@ -774,12 +775,22 @@ static DWORD WINAPI tid_alert_thread( void *arg )
     return 0;
 }
 
+static DWORD WINAPI tid_wait_alert_thread( void *arg )
+{
+    NTSTATUS ret;
+
+    ret = pNtWaitForAlertByThreadId( (void *)0x123, NULL );
+    ok(ret == STATUS_ALERTED, "got %#lx\n", ret);
+    return 0;
+}
+
 static void test_tid_alert( char **argv )
 {
     LARGE_INTEGER timeout = {{0}};
     char cmdline[MAX_PATH];
     STARTUPINFOA si = {0};
     PROCESS_INFORMATION pi;
+    HANDLE tids[2];
     HANDLE thread;
     NTSTATUS ret;
     DWORD tid;
@@ -840,6 +851,43 @@ static void test_tid_alert( char **argv )
     ok(!WaitForSingleObject( pi.hProcess, 1000 ), "wait failed\n");
     CloseHandle( pi.hProcess );
     CloseHandle( pi.hThread );
+
+    if (!pNtAlertMultipleThreadByThreadId)
+    {
+        win_skip( "NtAlertMultipleThreadByThreadId is not avaliable.\n" );
+        return;
+    }
+
+    timeout.QuadPart = 0;
+    ret = pNtAlertMultipleThreadByThreadId( NULL, 0, NULL, NULL );
+    ok( !ret, "got %#lx.\n", ret );
+    ret = pNtAlertMultipleThreadByThreadId( NULL, 1, NULL, NULL );
+    ok( ret == STATUS_ACCESS_VIOLATION, "got %#lx.\n", ret );
+
+    ret = pNtWaitForAlertByThreadId( (HANDLE)(ULONG_PTR)GetCurrentThreadId(), &timeout );
+    ok(ret == STATUS_TIMEOUT, "got %#lx\n", ret);
+    tids[0] = (HANDLE)(ULONG_PTR)GetCurrentThreadId();
+    tids[1] = (HANDLE)0xdeadbeef;
+    ret = pNtAlertMultipleThreadByThreadId( tids, 2, NULL, NULL );
+    ok( ret == STATUS_INVALID_CID, "got %#lx.\n", ret );
+    ret = pNtWaitForAlertByThreadId( (HANDLE)(ULONG_PTR)GetCurrentThreadId(), &timeout );
+    ok(ret == STATUS_TIMEOUT, "got %#lx\n", ret);
+    tids[1] = tids[0];
+    ret = pNtAlertMultipleThreadByThreadId( tids, 2, NULL, NULL );
+    ok( !ret, "got %#lx.\n", ret );
+    ret = pNtWaitForAlertByThreadId( (HANDLE)(ULONG_PTR)GetCurrentThreadId(), &timeout );
+    ok(ret == STATUS_ALERTED, "got %#lx\n", ret);
+    ret = pNtWaitForAlertByThreadId( (HANDLE)(ULONG_PTR)GetCurrentThreadId(), &timeout );
+    ok(ret == STATUS_TIMEOUT, "got %#lx\n", ret);
+
+    thread = CreateThread( NULL, 0, tid_wait_alert_thread, (HANDLE)(DWORD_PTR)GetCurrentThreadId(), 0, &tid );
+    tids[1] = (HANDLE)(ULONG_PTR)tid;
+    ret = pNtAlertMultipleThreadByThreadId( tids, 2, NULL, NULL );
+    ok( !ret, "got %#lx.\n", ret );
+    ret = pNtWaitForAlertByThreadId( (HANDLE)(ULONG_PTR)GetCurrentThreadId(), &timeout );
+    ok(ret == STATUS_ALERTED, "got %#lx\n", ret);
+    WaitForSingleObject( thread, INFINITE );
+    CloseHandle( thread );
 }
 
 struct test_completion_port_scheduling_param
@@ -1285,6 +1333,7 @@ START_TEST(sync)
 
     if (argc > 2) return;
 
+    pNtAlertMultipleThreadByThreadId = (void *)GetProcAddress(module, "NtAlertMultipleThreadByThreadId");
     pNtAlertThreadByThreadId        = (void *)GetProcAddress(module, "NtAlertThreadByThreadId");
     pNtClose                        = (void *)GetProcAddress(module, "NtClose");
     pNtCreateEvent                  = (void *)GetProcAddress(module, "NtCreateEvent");
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 47fd5b24c46..eba1470c82d 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -2707,6 +2707,14 @@ static unsigned int handle_to_index( HANDLE handle, unsigned int *block_idx )
     return idx % TID_ALERT_BLOCK_SIZE;
 }
 
+static BOOL is_alert_tid_valid( HANDLE tid )
+{
+    unsigned int block_idx;
+
+    handle_to_index( tid, &block_idx );
+    return block_idx <= ARRAY_SIZE(tid_alert_blocks);
+}
+
 static union tid_alert_entry *get_tid_alert_entry( HANDLE tid )
 {
     unsigned int block_idx, idx = handle_to_index( tid, &block_idx );
@@ -2777,6 +2785,25 @@ static union tid_alert_entry *get_tid_alert_entry( HANDLE tid )
 }
 
 
+/***********************************************************************
+ *             NtAlertMultipleThreadByThreadId (NTDLL.@)
+ */
+NTSTATUS WINAPI NtAlertMultipleThreadByThreadId( HANDLE *tids, ULONG count, void *unk1, void *unk2 )
+{
+    unsigned int i;
+
+    TRACE( "%p %d %p %p\n", tids, (int)count, unk1, unk2 );
+
+    if (unk1 || unk2) FIXME( "unk1 %p, unk2 %p.\n", unk1, unk2 );
+    for (i = 0; i < count; ++i)
+    {
+        if (!is_alert_tid_valid( tids[i] )) return STATUS_INVALID_CID;
+    }
+    for (i = 0; i < count; ++i) NtAlertThreadByThreadId( tids[i] );
+    return STATUS_SUCCESS;
+}
+
+
 /***********************************************************************
  *             NtAlertThreadByThreadId (NTDLL.@)
  */
diff --git a/dlls/wow64/process.c b/dlls/wow64/process.c
index 8968bcc2d0e..573b003ac44 100644
--- a/dlls/wow64/process.c
+++ b/dlls/wow64/process.c
@@ -269,6 +269,26 @@ void put_vm_counters( VM_COUNTERS_EX32 *info32, const VM_COUNTERS_EX *info, ULON
 }
 
 
+/**********************************************************************
+ *           wow64_NtAlertMultipleThreadByThreadId
+ */
+NTSTATUS WINAPI wow64_NtAlertMultipleThreadByThreadId( UINT *args )
+{
+    LONG *handles_ptr = get_ptr( &args );
+    ULONG count = get_ulong( &args );
+    void *unk1 = get_ptr( &args );
+    void *unk2 = get_ptr( &args );
+    HANDLE handles_buf[256], *handles;
+    unsigned int i;
+
+    if (count <= ARRAY_SIZE(handles_buf)) handles = handles_buf;
+    else                                  handles = Wow64AllocateTemp( count * sizeof(*handles) );
+    for (i = 0; i < count; ++i) handles[i] = (HANDLE)(ULONG_PTR)handles_ptr[i];
+
+    return NtAlertMultipleThreadByThreadId( handles, count, unk1, unk2 );
+}
+
+
 /**********************************************************************
  *           wow64_NtAlertResumeThread
  */
diff --git a/include/winternl.h b/include/winternl.h
index 335d972d31c..11a013f62d8 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -4544,6 +4544,7 @@ NTSYSAPI NTSTATUS  WINAPI NtAccessCheckAndAuditAlarm(PUNICODE_STRING,HANDLE,PUNI
 NTSYSAPI NTSTATUS  WINAPI NtAddAtom(const WCHAR*,ULONG,RTL_ATOM*);
 NTSYSAPI NTSTATUS  WINAPI NtAdjustGroupsToken(HANDLE,BOOLEAN,PTOKEN_GROUPS,ULONG,PTOKEN_GROUPS,PULONG);
 NTSYSAPI NTSTATUS  WINAPI NtAdjustPrivilegesToken(HANDLE,BOOLEAN,PTOKEN_PRIVILEGES,DWORD,PTOKEN_PRIVILEGES,PDWORD);
+NTSYSAPI NTSTATUS  WINAPI NtAlertMultipleThreadByThreadId(HANDLE*,ULONG,void*,void*);
 NTSYSAPI NTSTATUS  WINAPI NtAlertResumeThread(HANDLE,PULONG);
 NTSYSAPI NTSTATUS  WINAPI NtAlertThread(HANDLE ThreadHandle);
 NTSYSAPI NTSTATUS  WINAPI NtAlertThreadByThreadId(HANDLE);
-- 
2.51.1

