From 038857caf8c3e2a58e525d620b91ed46a7cc760e Mon Sep 17 00:00:00 2001
From: Alexandre Julliard <julliard@winehq.org>
Date: Tue, 29 Apr 2025 18:22:32 +0200
Subject: [PATCH 335/406] ntdll: Add a test for invalid syscall numbers.

---
 dlls/ntdll/signal_arm64ec.c     |  2 +-
 dlls/ntdll/tests/virtual.c      | 48 +++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/signal_arm.c    |  2 +-
 dlls/ntdll/unix/signal_arm64.c  |  4 +--
 dlls/ntdll/unix/signal_x86_64.c |  2 +-
 5 files changed, 53 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/signal_arm64ec.c b/dlls/ntdll/signal_arm64ec.c
index f5e53a5b933..66d47ccbf5b 100644
--- a/dlls/ntdll/signal_arm64ec.c
+++ b/dlls/ntdll/signal_arm64ec.c
@@ -1275,7 +1275,7 @@ static void dispatch_syscall( ARM64_NT_CONTEXT *context )
         context->X4 = context->Pc;  /* and save return address to syscall thunk */
         context->Pc = (ULONG_PTR)invoke_arm64ec_syscall;
     }
-    else context->X8 = STATUS_INVALID_PARAMETER;  /* set return value in rax */
+    else context->X8 = STATUS_INVALID_SYSTEM_SERVICE;  /* set return value in rax */
 
     /* return to x64 code so that the syscall entry thunk is invoked properly */
     dispatch_emulation( context );
diff --git a/dlls/ntdll/tests/virtual.c b/dlls/ntdll/tests/virtual.c
index 5afabc6cd59..380931c74ca 100644
--- a/dlls/ntdll/tests/virtual.c
+++ b/dlls/ntdll/tests/virtual.c
@@ -2297,6 +2297,53 @@ static void test_syscalls(void)
     UnmapViewOfFile( ptr );
 }
 
+static void test_invalid_syscalls(void)
+{
+    HMODULE module = GetModuleHandleW( L"ntdll.dll" );
+    NTSTATUS (WINAPI *pNtImpersonateAnonymousToken)( HANDLE thread );
+    NTSTATUS status;
+    DWORD prot, i;
+    LONG old_id, new_id, *id;
+
+    /* grab a syscall that's unlikely to be used while we are testing */
+    pNtImpersonateAnonymousToken = (void *)GetProcAddress( module, "NtImpersonateAnonymousToken" );
+    if (!pNtImpersonateAnonymousToken)
+    {
+        win_skip( "NtImpersonateAnonymousToken not supported\n" );
+        return;
+    }
+    status = pNtImpersonateAnonymousToken( 0 );
+    ok( status == STATUS_INVALID_HANDLE || status == STATUS_NOT_IMPLEMENTED, "wrong status %lx\n", status );
+    VirtualProtect( pNtImpersonateAnonymousToken, 32, PAGE_EXECUTE_READWRITE, &prot );
+    for (i = 0; i < 4; i++)
+    {
+        new_id = 0x666 | (i << 12);
+        winetest_push_context( "%04lx", new_id );
+#ifdef __i386__
+        id = (LONG *)((BYTE *)pNtImpersonateAnonymousToken + 1);
+        new_id = (*id & ~0xffff) | new_id;
+#elif defined __x86_64__
+        id = (LONG *)pNtImpersonateAnonymousToken + 1;
+        new_id = (*id & ~0xffff) | new_id;
+#elif defined __aarch64__
+        id = (LONG *)pNtImpersonateAnonymousToken;
+        new_id = (*id & ~(0xffff << 5)) | (new_id << 5);
+#elif defined __arm__
+        id = (LONG *)(((ULONG_PTR)pNtImpersonateAnonymousToken & ~1) + 2);
+        new_id = 0x0c00f240 | ((new_id & 0xff) << 16) | ((new_id & 0xf00) << 20) | (new_id >> 12); /* movw ip, #0xnnn */
+#endif
+        old_id = *id;
+        *id = new_id;
+        NtFlushInstructionCache( GetCurrentProcess(), pNtImpersonateAnonymousToken, 32 );
+        status = pNtImpersonateAnonymousToken( 0 );
+        ok( status == STATUS_INVALID_SYSTEM_SERVICE, "wrong status %lx\n", status );
+        *id = old_id;
+        NtFlushInstructionCache( GetCurrentProcess(), pNtImpersonateAnonymousToken, 32 );
+        winetest_pop_context();
+    }
+    VirtualProtect( pNtImpersonateAnonymousToken, 32, prot, &prot );
+}
+
 static void test_NtFreeVirtualMemory(void)
 {
     void *addr1, *addr;
@@ -3237,6 +3284,7 @@ START_TEST(virtual)
     test_prefetch();
     test_user_shared_data();
     test_syscalls();
+    test_invalid_syscalls();
     test_query_region_information();
     test_query_image_information();
     test_exec_memory_writes();
diff --git a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
index 754801ab8f4..f4239db994b 100644
--- a/dlls/ntdll/unix/signal_arm.c
+++ b/dlls/ntdll/unix/signal_arm.c
@@ -1260,7 +1260,7 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                    "add r8, r8, #0x10\n\t"
                    "ldm r8, {r4-r12,pc}\n"
 
-                   "5:\tmovw r0, #0x000d\n\t" /* STATUS_INVALID_PARAMETER */
+                   "5:\tmovw r0, #0x001c\n\t" /* STATUS_INVALID_SYSTEM_SERVICE */
                    "movt r0, #0xc000\n\t"
                    "b " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") )
 
diff --git a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
index 56c4de532cb..f1f4b522f6a 100644
--- a/dlls/ntdll/unix/signal_arm64.c
+++ b/dlls/ntdll/unix/signal_arm64.c
@@ -1742,8 +1742,8 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                    /* switch to user stack */
                    "mov sp, x17\n\t"
                    "ret x16\n"
-                   "4:\tmov x0, #0xc0000000\n\t" /* STATUS_INVALID_PARAMETER */
-                   "movk x0, #0x000d\n\t"
+                   "4:\tmov x0, #0xc0000000\n\t" /* STATUS_INVALID_SYSTEM_SERVICE */
+                   "movk x0, #0x001c\n\t"
                    "b " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") )
 
 __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher_return,
diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index f20d40fa680..805c9d302d7 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -3490,7 +3490,7 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
 
                    /* pop rbp-based kernel stack cfi */
                    __ASM_CFI("\t.cfi_restore_state\n")
-                   "5:\tmovl $0xc000000d,%eax\n\t" /* STATUS_INVALID_PARAMETER */
+                   "5:\tmovl $0xc000001c,%eax\n\t" /* STATUS_INVALID_SYSTEM_SERVICE */
                    "movq %rsp,%rcx\n\t"
                    "jmp " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") )
 
-- 
2.51.1

