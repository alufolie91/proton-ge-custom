From 4f04b98f638d91860072d7d83df9aef4e99f1350 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 17 Aug 2025 18:52:57 -0400
Subject: [PATCH 365/365] winewayland: WIP remote calls.

---
 dlls/winewayland.drv/Makefile.in       |   2 +
 dlls/winewayland.drv/wayland_cross.c   |  98 ++++++++++++++++++
 dlls/winewayland.drv/wayland_dc.c      | 136 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  24 +++++
 dlls/winewayland.drv/waylanddrv_main.c |  60 +++++++++++
 dlls/winewayland.drv/window.c          |  26 +++++
 6 files changed, 346 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_cross.c
 create mode 100644 dlls/winewayland.drv/wayland_dc.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index d257b39783a..c6320e7b3aa 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -21,7 +21,9 @@ SOURCES = \
 	viewporter.xml \
 	vulkan.c \
 	wayland.c \
+	wayland_cross.c \
 	wayland_data_device.c \
+	wayland_dc.c \
 	wayland_keyboard.c \
 	wayland_output.c \
 	wayland_pointer.c \
diff --git a/dlls/winewayland.drv/wayland_cross.c b/dlls/winewayland.drv/wayland_cross.c
new file mode 100644
index 00000000000..cee67ed18c5
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_cross.c
@@ -0,0 +1,98 @@
+/*
+ * Wayland Cross Process helpers
+ *
+ * Copyright 2025 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "wine/server.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+
+int wayland_remote_call(HWND target, DWORD type, void *data, SIZE_T size)
+{
+    HANDLE process = NULL, section = NULL;
+    LARGE_INTEGER section_size;
+    SIZE_T view_size = 0;
+    DWORD tid, pid;
+    void *local, *other;
+    int ret = 0;
+    CLIENT_ID client_id = {0};
+
+    TRACE("hwnd %p type %x data %p size %lu\n", target, type, data, size);
+
+    tid = NtUserGetWindowThread(target, &pid);
+
+    if (!tid) return -1;
+
+    client_id.UniqueProcess = UlongToPtr(pid);
+
+    if (NtOpenProcess(&process, PROCESS_ALL_ACCESS, NULL, &client_id))
+    {
+        ERR("Failed to open process %x\n", pid);
+        return -1;
+    }
+
+    section_size.QuadPart = size;
+
+    if (NtCreateSection(&section, GENERIC_READ | SECTION_MAP_READ | SECTION_MAP_WRITE,
+                        NULL, &section_size, PAGE_READWRITE, SEC_COMMIT, 0))
+    {
+        ERR("Failed to create section\n");
+        ret = -1;
+        goto done;
+    }
+
+    if (NtMapViewOfSection(section, GetCurrentProcess(), (void *)&local, 0, 0, NULL,
+                           &view_size, ViewUnmap, 0, PAGE_READWRITE))
+    {
+        ERR("Failed to map view of section in current process\n");
+        ret = -1;
+        goto done;
+    }
+
+    memcpy(local, data, size);
+    NtUnmapViewOfSection(GetCurrentProcess(), local);
+
+    if (NtMapViewOfSection(section, process, (void *)&other, 0, 0, NULL,
+                           &view_size, ViewUnmap, 0, PAGE_READWRITE))
+    {
+        ERR("Failed to map view of section for other process\n");
+        ret = -1;
+        goto done;
+    }
+
+    NtUserPostMessage(target, WM_WAYLAND_REMOTE, type, (ULONG_PTR)other);
+
+done:
+    if (section) NtClose(section);
+    if (process) NtClose(process);
+
+    return ret;
+}
diff --git a/dlls/winewayland.drv/wayland_dc.c b/dlls/winewayland.drv/wayland_dc.c
new file mode 100644
index 00000000000..85d1bf635e1
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_dc.c
@@ -0,0 +1,136 @@
+/*
+ * Wayland DC funcs implementation
+ *
+ * Copyright 2025 Etaash Mathamsetty
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *           WAYLAND_PutImage
+ *
+ * This is a fallback implementation for when the dibdrv cannot perform
+ * this task, typically because the destination belongs to a different
+ * process. In such a case the implementation utilizes the remote surface
+ * infrastructure to commit content to the remote HWND.
+ *
+ * The implementation is very limited, supporting only simple full copies,
+ * but that's enough for some typical cross-process cases, notably software
+ * rendered content in Chrome/CEF.
+ */
+DWORD WAYLAND_PutImage(PHYSDEV dev, HRGN clip, BITMAPINFO *info,
+                             const struct gdi_image_bits *bits, struct bitblt_coords *src,
+                             struct bitblt_coords *dst, DWORD rop)
+{
+    HWND hwnd;
+    DWORD ret = ERROR_SUCCESS;
+
+    hwnd = NtUserWindowFromDC(dev->hdc);
+
+    TRACE("hwnd=%p rop=%#x biBitCount=%d compr=%u size=%dx%d "
+          "src=log=%d,%d+%dx%d:dev=%d,%d+%dx%d:vis=%s "
+          "dst=log=%d,%d+%dx%d:dev=%d,%d+%dx%d:vis=%s "
+          "clip=%p\n",
+          hwnd, (UINT)rop, info->bmiHeader.biBitCount,
+          (UINT)info->bmiHeader.biCompression,
+          (int)info->bmiHeader.biWidth, (int)info->bmiHeader.biHeight,
+          src->log_x, src->log_y, src->log_width, src->log_height,
+          src->x, src->y, src->width, src->height,
+          wine_dbgstr_rect(&src->visrect),
+          dst->log_x, dst->log_y, dst->log_width, dst->log_height,
+          dst->x, dst->y, dst->width, dst->height,
+          wine_dbgstr_rect(&dst->visrect), clip);
+
+    if (info->bmiHeader.biPlanes != 1)
+    {
+        TRACE("Multiplanar buffers not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biBitCount != 32)
+    {
+        TRACE("Non 32-bit buffers not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biCompression != BI_RGB)
+    {
+        TRACE("Non RGB not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biHeight > 0)
+    {
+        TRACE("Bottom-up buffers not supported\n");
+        goto update_format;
+    }
+
+    if (!bits) return ERROR_SUCCESS;  /* just querying the format */
+
+    if (!hwnd)
+    {
+        TRACE("Invalid hwnd=%p\n", hwnd);
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if (clip)
+    {
+        TRACE("Clipping not supported\n");
+        return ERROR_CLIPPING_NOT_SUPPORTED;
+    }
+
+    if ((src->width != dst->width) || (src->height != dst->height))
+    {
+        TRACE("Image stretching is not supported\n");
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if ((src->width != info->bmiHeader.biWidth) ||
+        (src->height != -info->bmiHeader.biHeight))
+    {
+        TRACE("Partial blits are not supported\n");
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if (rop != SRCCOPY)
+    {
+        TRACE("Raster operations other than SRCCOPY are not supported\n");
+        return ERROR_INVALID_OPERATION;
+    }
+
+    return ret;
+
+update_format:
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    if (info->bmiHeader.biHeight > 0) info->bmiHeader.biHeight = -info->bmiHeader.biHeight;
+    return ERROR_BAD_FORMAT;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5a669583a83..0cf8052debc 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -76,6 +76,7 @@ enum wayland_window_message
     WM_WAYLAND_INIT_DISPLAY_DEVICES = WM_WINE_FIRST_DRIVER_MSG,
     WM_WAYLAND_CONFIGURE,
     WM_WAYLAND_SET_FOREGROUND,
+    WM_WAYLAND_REMOTE
 };
 
 enum wayland_surface_config_state
@@ -109,6 +110,11 @@ enum wayland_pointer_axis_stop_flags
     WAYLAND_POINTER_AXIS_STOP_HORIZONTAL = (1 << 1)
 };
 
+enum wayland_remote_message_type
+{
+    WAYLAND_REMOTE_MESSAGE_COMMIT
+};
+
 struct wayland_keyboard
 {
     struct wl_keyboard *wl_keyboard;
@@ -365,6 +371,10 @@ struct wayland_surface
     HCURSOR hcursor;
 };
 
+typedef struct {
+    struct gdi_physdev dev;
+} WAYLAND_PDEVICE;
+
 /**********************************************************************
  *          Wayland initialization
  */
@@ -429,6 +439,11 @@ struct wayland_shm_buffer *wayland_shm_buffer_from_color_bitmaps(HDC hdc, HBITMA
 void wayland_shm_buffer_ref(struct wayland_shm_buffer *shm_buffer);
 void wayland_shm_buffer_unref(struct wayland_shm_buffer *shm_buffer);
 
+/**********************************************************************
+ *          Wayland Cross Process helpers
+ */
+int wayland_remote_call(HWND target, DWORD type, void *data, SIZE_T size);
+
 /**********************************************************************
  *          Wayland Window
  */
@@ -561,4 +576,13 @@ BOOL WAYLAND_HasWindowManager(const char *name);
 UINT WAYLAND_VulkanInit(UINT version, void *vulkan_handle, const struct vulkan_driver_funcs **driver_funcs);
 struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version);
 
+/* dc funcs */
+BOOL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR device,
+                            LPCWSTR output, const DEVMODEW* initData);
+BOOL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev);
+BOOL WAYLAND_DeleteDC(PHYSDEV dev);
+DWORD WAYLAND_PutImage(PHYSDEV dev, HRGN clip, BITMAPINFO *info,
+                             const struct gdi_image_bits *bits, struct bitblt_coords *src,
+                             struct bitblt_coords *dst, DWORD rop);
+
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 61beb3e47e3..31b71219b1e 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -39,6 +39,12 @@ BOOL option_use_system_cursors = TRUE;
 
 static const struct user_driver_funcs waylanddrv_funcs =
 {
+    .dc_funcs.pCreateDC = WAYLAND_CreateDC,
+    .dc_funcs.pCreateCompatibleDC = WAYLAND_CreateCompatibleDC,
+    .dc_funcs.pDeleteDC = WAYLAND_DeleteDC,
+    .dc_funcs.pPutImage = WAYLAND_PutImage,
+    .dc_funcs.priority = GDI_PRIORITY_GRAPHICS_DRV,
+
     .pBeep = WAYLAND_Beep,
     .pClipboardWindowProc = WAYLAND_ClipboardWindowProc,
     .pClipCursor = WAYLAND_ClipCursor,
@@ -63,6 +69,60 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pwine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
 };
 
+static inline WAYLAND_PDEVICE *get_wayland_dev(PHYSDEV dev)
+{
+    return (WAYLAND_PDEVICE *)dev;
+}
+
+static WAYLAND_PDEVICE *create_wayland_physdev(void)
+{
+    WAYLAND_PDEVICE *phys;
+
+    phys = calloc(1, sizeof(*phys));
+
+    return phys;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateDC
+ */
+BOOL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR device,
+                            LPCWSTR output, const DEVMODEW* initData)
+{
+    WAYLAND_PDEVICE *physDev = create_wayland_physdev();
+
+    if (!physDev) return FALSE;
+
+    push_dc_driver(pdev, &physDev->dev, &waylanddrv_funcs.dc_funcs);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateCompatibleDC
+ */
+BOOL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev)
+{
+    WAYLAND_PDEVICE *physDev = create_wayland_physdev();
+
+    if (!physDev) return FALSE;
+
+    push_dc_driver(pdev, &physDev->dev, &waylanddrv_funcs.dc_funcs);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_DeleteDC
+ */
+BOOL WAYLAND_DeleteDC(PHYSDEV dev)
+{
+    WAYLAND_PDEVICE *physDev = get_wayland_dev(dev);
+
+    free(physDev);
+    return TRUE;
+}
+
 static HKEY reg_open_key(HKEY root, const WCHAR *name, ULONG name_len)
 {
     UNICODE_STRING nameW = {name_len, name_len, (WCHAR *)name};
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 85a7d32b92d..874e309b0a1 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -695,6 +695,32 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
     case WM_WAYLAND_SET_FOREGROUND:
         NtUserSetForegroundWindow(hwnd);
         return 0;
+    case WM_WAYLAND_REMOTE:
+    {
+        void *mapping = (void *)lp;
+
+        TRACE("wp %x mapping %p\n", (UINT)wp, mapping);
+
+        switch (wp)
+        {
+            case WAYLAND_REMOTE_MESSAGE_COMMIT:
+            {
+                if (!mapping) break;
+                FIXME("remote commit is unimplemented!\n");
+                break;
+            }
+            default:
+            {
+                FIXME("wp %x not implemented\n", (UINT)wp);
+                break;
+            }
+        }
+
+        if (mapping)
+            NtUnmapViewOfSection(GetCurrentProcess(), mapping);
+
+        return 0;
+    }
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
         return 0;
-- 
2.50.1

