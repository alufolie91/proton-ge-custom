From e52c29014a41ab764a558b81986a409d87ed35e0 Mon Sep 17 00:00:00 2001
From: Yuxuan Shui <yshui@codeweavers.com>
Date: Tue, 29 Jul 2025 12:05:03 +0100
Subject: [PATCH 337/423] ntdll: Fix inconsistency in LFH block size
 calculation during realloc.

For allocation, the block size calculation is snapped to block bin sizes, but
for reallocation it is not. So the tail_size calculation will be wrong if the
block size is not one of the bin sizes.

To illustrate the problem: assume an allocation size of 32 bytes.
heap_get_block_size will return 40 bytes. heap_allocate_block_lfh will round
it up to 48 bytes. The tail_size is thus, 48 - 8 - 32 = 8 bytes. Later,
HeapReAlloc is called to shrink it to 30 bytes. heap_get_block_size returns
40 bytes, heap_resize_block_lfh will not return STATUS_NO_MEMORY, because
ROUND_SIZE(30) == 32, and 30 < 32. It will then calculate the tail_size based
on the new block_size, which is 40 bytes. So the new tail_size becomes:
40 - 8 - 30 = 2 bytes. But block->block_size is still 48 bytes! So what it
actually did is **growing** the block to 48 - 8 - 2 = 38 bytes from 32 bytes.

This commit fixes it by also rounding up the block_size to bin sizes in
heap_resize_block_lfh.
---
 dlls/ntdll/heap.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index c194f2058dc..924f889e8e4 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -2197,6 +2197,7 @@ static NTSTATUS heap_resize_block_lfh( struct block *block, ULONG flags, SIZE_T
     if (ROUND_SIZE( *old_size, BLOCK_ALIGN - 1) != ROUND_SIZE( size, BLOCK_ALIGN - 1)) return STATUS_NO_MEMORY;
     if (size >= *old_size) return STATUS_NO_MEMORY;
 
+    block_size = BLOCK_BIN_SIZE( BLOCK_SIZE_BIN( block_size ) );
     block_set_flags( block, BLOCK_FLAG_USER_MASK & ~BLOCK_FLAG_USER_INFO, BLOCK_USER_FLAGS( flags ) );
     block->tail_size = block_size - sizeof(*block) - size;
     initialize_block( block, *old_size, size, flags );
-- 
2.52.0

