From 0b570a876175ea34ee76d01b8011bb36d905ae24 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Fri, 27 Jun 2025 22:11:08 -0600
Subject: [PATCH 238/327] ntdll: Don't skip synchronous read when serial read
 timeout is infinite.

If get_io_timeouts sets the interval timeout to 0, it means that the
read should return immediately even if there is no data. If
get_io_timeouts sets the interval timeout to -1, it means that the read
operation should wait indefinitely for the next byte. In either case,
the interval timer is not used, so there's no need to worry about
forgetting to start it, and the delay in returning data was causing a
problem in Ti99Hdx.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=42882
---
 dlls/ntdll/unix/file.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 77b1477a30f..16012ba6e47 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -6129,7 +6129,7 @@ NTSTATUS WINAPI NtReadFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, vo
            skip the synchronous read to make sure that the server starts the read
            interval timer after the first read */
         if ((status = get_io_timeouts( handle, type, length, TRUE, &timeouts ))) goto err;
-        if (timeouts.interval)
+        if (timeouts.interval > 0)
         {
             status = register_async_file_read( handle, event, apc, apc_user, iosb_ptr,
                                                buffer, total, length, FALSE );
-- 
2.51.0

