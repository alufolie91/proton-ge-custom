From 1aa690b1c0d7a618e5dcf415cb13eccdb192ec14 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 29 Aug 2025 18:22:03 -0500
Subject: [PATCH 315/336] amdxc: Properly check for WMMA support.

---
 dlls/amdxc64/amdxc_interfaces.idl | 26 +++++++++
 dlls/amdxc64/main.c               | 87 +++++++++++++++++++++++++++++--
 2 files changed, 109 insertions(+), 4 deletions(-)

diff --git a/dlls/amdxc64/amdxc_interfaces.idl b/dlls/amdxc64/amdxc_interfaces.idl
index d446d0c4a2e..8a6c8e0011e 100644
--- a/dlls/amdxc64/amdxc_interfaces.idl
+++ b/dlls/amdxc64/amdxc_interfaces.idl
@@ -22,6 +22,10 @@ import "wtypes.idl";
 import "unknwn.idl";
 import "d3d12.idl";
 
+typedef struct VkInstance_T *VkInstance;
+typedef struct VkDevice_T *VkDevice;
+typedef struct VkPhysicalDevice_T *VkPhysicalDevice;
+typedef struct VkQueue_T *VkQueue;
 
 /* the following are publicly available */
 
@@ -323,3 +327,25 @@ interface IAmdExtD3DDevice8 : IAmdExtD3DDevice7
 {
     HRESULT GetWaveMatrixProperties([in, out] SIZE_T *pCount, [in, out] AmdExtWaveMatrixProperties *pProperties);
 }
+
+/* taken from vkd3d-proton */
+
+[
+    uuid(39da4e09-bd1c-4198-9fae-86bbe3be41fd),
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ID3D12DXVKInteropDevice : IUnknown
+{
+    HRESULT GetDXGIAdapter(REFIID iid, void **object);
+    HRESULT GetInstanceExtensions(UINT *extension_count, const char **extensions);
+    HRESULT GetDeviceExtensions(UINT *extension_count, const char **extensions);
+    HRESULT GetDeviceFeatures(const void **features);
+    HRESULT GetVulkanHandles(VkInstance *vk_instance, VkPhysicalDevice *vk_physical_device, VkDevice *vk_device);
+    HRESULT GetVulkanQueueInfo(ID3D12CommandQueue *queue, VkQueue *vk_queue, UINT32 *vk_queue_family);
+    void GetVulkanImageLayout(ID3D12Resource *resource, D3D12_RESOURCE_STATES state, void *vk_layout);
+    HRESULT GetVulkanResourceInfo(ID3D12Resource *resource, UINT64 *vk_handle, UINT64 *buffer_offset);
+    HRESULT LockCommandQueue(ID3D12CommandQueue *queue);
+    HRESULT UnlockCommandQueue(ID3D12CommandQueue *queue);
+}
diff --git a/dlls/amdxc64/main.c b/dlls/amdxc64/main.c
index 5389862ce8c..1d0ecbdcdfd 100644
--- a/dlls/amdxc64/main.c
+++ b/dlls/amdxc64/main.c
@@ -28,6 +28,7 @@
 #include "winternl.h"
 #include "wine/debug.h"
 #include "wine/heap.h"
+#include "wine/vulkan.h"
 
 #define COBJMACROS
 #include "initguid.h"
@@ -178,6 +179,7 @@ struct AmdExtD3DDevice8
 {
     IAmdExtD3DDevice8 IAmdExtD3DDevice8_iface;
     LONG ref;
+    BOOL fsr4_supported;
 };
 
 struct AmdExtD3DDevice8 *impl_from_IAmdExtD3DDevice8(IAmdExtD3DDevice8 *iface)
@@ -301,7 +303,7 @@ HRESULT STDMETHODCALLTYPE AmdExtD3DDevice8_CreateComputePipelineCrossCompile(IAm
 HRESULT STDMETHODCALLTYPE AmdExtD3DDevice8_GetWaveMatrixProperties(IAmdExtD3DDevice8 *iface,
                                                                    SIZE_T *pCount, AmdExtWaveMatrixProperties *pProperties)
 {
-    /* FIXME: this needs an interface vkd3d-proton side */
+    struct AmdExtD3DDevice8 *this = impl_from_IAmdExtD3DDevice8(iface);
     static AmdExtWaveMatrixProperties prop[1] = {{
         16, 16, 16, AMD_EXT_WMMA_TYPE_FP8, AMD_EXT_WMMA_TYPE_FP8,
         AMD_EXT_WMMA_TYPE_FP32, AMD_EXT_WMMA_TYPE_FP32, FALSE}};
@@ -312,9 +314,15 @@ HRESULT STDMETHODCALLTYPE AmdExtD3DDevice8_GetWaveMatrixProperties(IAmdExtD3DDev
 
     if (*pCount >= 1)
     {
-        *pCount = 1;
-        memcpy(pProperties, prop, sizeof(prop));
-        return S_OK;
+        if (this->fsr4_supported)
+        {
+            *pCount = 1;
+            memcpy(pProperties, prop, sizeof(prop));
+            return S_OK;
+        } else {
+            *pCount = 0;
+            return S_OK;
+        }
     } /* FIXME: Handle pCount == 0 */
 
     return S_OK;
@@ -365,6 +373,75 @@ ULONG STDMETHODCALLTYPE AmdExtD3DFactory_Release(IAmdExtD3DFactory *iface)
     return ret;
 }
 
+static BOOL check_fsr4_supported(ID3D12Device *device)
+{
+    ID3D12DXVKInteropDevice *interop;
+    VkInstance instance;
+    VkDevice vk_device;
+    VkPhysicalDevice phys_device;
+    VkPhysicalDeviceProperties2 prop = {0};
+    VkPhysicalDeviceDriverProperties driver_prop = {0};
+    const char **extensions;
+    UINT extension_count = 0;
+    UINT major, minor;
+    BOOL has_float8 = FALSE, has_coopmat2 = FALSE;
+
+    if (FAILED(ID3D12Device_QueryInterface(device, &IID_ID3D12DXVKInteropDevice, (void **)&interop)))
+        return FALSE;
+
+    if (FAILED(ID3D12DXVKInteropDevice_GetVulkanHandles(interop, &instance, &phys_device, &vk_device)))
+        return FALSE;
+
+    prop.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
+    prop.pNext = &driver_prop;
+    driver_prop.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
+
+    vkGetPhysicalDeviceProperties2(phys_device, &prop);
+
+    if (prop.properties.vendorID != 0x1002) return FALSE;
+    /* amdvlk is too slow to be relevant (on rdna3 & doesn't work at all on rdna4) */
+    if (driver_prop.driverID != VK_DRIVER_ID_MESA_RADV) return FALSE;
+
+    major = VK_API_VERSION_MAJOR(prop.properties.driverVersion);
+    minor = VK_API_VERSION_MINOR(prop.properties.driverVersion);
+
+    if (major > 25 || (major == 25 && minor >= 2))
+    {
+
+        if (FAILED(ID3D12DXVKInteropDevice_GetDeviceExtensions(interop, &extension_count, NULL)))
+            return FALSE;
+
+        extensions = malloc(sizeof(*extensions) * extension_count);
+
+        if (FAILED(ID3D12DXVKInteropDevice_GetDeviceExtensions(interop, &extension_count, extensions)))
+            return FALSE;
+
+        for (UINT i = 0; i < extension_count; i++)
+        {
+            if (!strcmp("VK_NV_cooperative_matrix2", extensions[i]))
+                has_coopmat2 = TRUE;
+            if (!strcmp("VK_EXT_shader_float8", extensions[i]))
+                has_float8 = TRUE;
+        }
+
+        /* trivial cases */
+        if (!has_coopmat2) return FALSE;
+        if (has_coopmat2 && has_float8) return TRUE;
+
+        /* probably RDNA3, ensure the user is doing stuff correctly */
+        {
+            const char *env = getenv("DXIL_SPIRV_CONFIG");
+
+            if (env && strstr(env, "wmma_rdna3_workaround"))
+                return TRUE;
+
+            return FALSE;
+        }
+    }
+
+    return FALSE;
+}
+
 HRESULT STDMETHODCALLTYPE AmdExtD3DFactory_CreateInterface(IAmdExtD3DFactory *iface, IUnknown *outer, REFIID iid, void **out)
 {
     TRACE("%p %p %s %p\n", iface, outer, debugstr_guid(iid), out);
@@ -380,6 +457,8 @@ HRESULT STDMETHODCALLTYPE AmdExtD3DFactory_CreateInterface(IAmdExtD3DFactory *if
         struct AmdExtD3DDevice8 *this = calloc(1, sizeof(struct AmdExtD3DDevice8));
         this->IAmdExtD3DDevice8_iface.lpVtbl = &AmdExtD3DDevice8_vtable;
         this->ref = 1;
+        this->fsr4_supported = check_fsr4_supported((ID3D12Device *)outer);
+        TRACE("FSR 4 supported: %d\n", this->fsr4_supported);
         *out = &this->IAmdExtD3DDevice8_iface;
         return S_OK;
     } else {
-- 
2.51.0

