From 982fec67642efda0fbd10f1fea3e50ec69525b46 Mon Sep 17 00:00:00 2001
From: Dylan Donnell <dylan.donnell@student.griffith.ie>
Date: Sun, 19 Oct 2025 13:37:58 +0200
Subject: [PATCH 360/473] ntdll: Stop unwinding on access violation.

---
 dlls/ntdll/signal_x86_64.c | 38 ++++++++++++++++++++++++++++----------
 1 file changed, 28 insertions(+), 10 deletions(-)

diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
index bab9bf2edae..9d3a8920a19 100644
--- a/dlls/ntdll/signal_x86_64.c
+++ b/dlls/ntdll/signal_x86_64.c
@@ -908,6 +908,14 @@ NTSTATUS WINAPI RtlWow64SuspendThread( HANDLE thread, ULONG *count )
     return NtSuspendThread( thread, count );
 }
 
+static LONG WINAPI walk_frame_chain_handler( EXCEPTION_POINTERS *eptr )
+{
+    if (eptr->ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION)
+        return EXCEPTION_EXECUTE_HANDLER;
+
+    return EXCEPTION_CONTINUE_SEARCH;
+}
+
 /*************************************************************************
  *		RtlWalkFrameChain (NTDLL.@)
  */
@@ -923,18 +931,28 @@ ULONG WINAPI RtlWalkFrameChain( void **buffer, ULONG count, ULONG flags )
 
     RtlCaptureContext( &context );
 
-    for (i = 0; i < count; i++)
+    __TRY
     {
-        func = RtlLookupFunctionEntry( context.Rip, &base, &table );
-        if (!func) break;
-        if (RtlVirtualUnwind2( UNW_FLAG_NHANDLER, base, context.Rip, func, &context, NULL,
-                               &data, &frame, NULL, NULL, NULL, &handler, 0 ))
-            break;
-        if (!context.Rip) break;
-        if (!frame || !is_valid_frame( frame )) break;
-        if (context.Rsp == (ULONG_PTR)NtCurrentTeb()->Tib.StackBase) break;
-        if (i >= skip) buffer[num_entries++] = (void *)context.Rip;
+        for (i = 0; i < count; i++)
+        {
+            func = RtlLookupFunctionEntry( context.Rip, &base, &table );
+            if (!func) break;
+            if (RtlVirtualUnwind2( UNW_FLAG_NHANDLER, base, context.Rip, func, &context, NULL,
+                                &data, &frame, NULL, NULL, NULL, &handler, 0 ))
+                break;
+            if (!context.Rip) break;
+            if (!frame || !is_valid_frame( frame )) break;
+            if (context.Rsp == (ULONG_PTR)NtCurrentTeb()->Tib.StackBase) break;
+            if (i >= skip) buffer[num_entries++] = (void *)context.Rip;
+        }
+    }
+    __EXCEPT(walk_frame_chain_handler)
+    {
+        TRACE( "access violation when unwinding with context.Rip %p\n", (void *)context.Rip );
+	return 0;
     }
+    __ENDTRY
+
     return num_entries;
 }
 
-- 
2.52.0

