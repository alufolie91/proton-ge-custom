From 3f906babeb1ce0e7cc465638959efaa78a3d9bec Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 8 Nov 2025 13:42:41 -0600
Subject: [PATCH 379/473] winewayland: Implement ext-data-control-v1.

Drop in replacement for wlr, but also keep it around to keep compat
---
 dlls/winewayland.drv/Makefile.in             |   1 +
 dlls/winewayland.drv/ext-data-control-v1.xml | 276 +++++++++++++++++++
 dlls/winewayland.drv/wayland.c               |  10 +-
 dlls/winewayland.drv/wayland_data_device.c   | 151 +++++++++-
 dlls/winewayland.drv/waylanddrv.h            |   8 +
 dlls/winewayland.drv/waylanddrv_main.c       |   1 +
 6 files changed, 444 insertions(+), 3 deletions(-)
 create mode 100644 dlls/winewayland.drv/ext-data-control-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index a44add4415d..b9ce921fe71 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -10,6 +10,7 @@ SOURCES = \
 	cursor-shape-v1.xml \
 	display.c \
 	dllmain.c \
+	ext-data-control-v1.xml \
 	fractional-scale-v1.xml \
 	linux-dmabuf-v1.xml \
 	opengl.c \
diff --git a/dlls/winewayland.drv/ext-data-control-v1.xml b/dlls/winewayland.drv/ext-data-control-v1.xml
new file mode 100644
index 00000000000..37ee577ed92
--- /dev/null
+++ b/dlls/winewayland.drv/ext-data-control-v1.xml
@@ -0,0 +1,276 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="ext_data_control_v1">
+  <copyright>
+    Copyright © 2018 Simon Ser
+    Copyright © 2019 Ivan Molodetskikh
+    Copyright © 2024 Neal Gompa
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <description summary="control data devices">
+    This protocol allows a privileged client to control data devices. In
+    particular, the client will be able to manage the current selection and take
+    the role of a clipboard manager.
+
+    Warning! The protocol described in this file is currently in the testing
+    phase. Backward compatible changes may be added together with the
+    corresponding interface version bump. Backward incompatible changes can
+    only be done by creating a new major version of the extension.
+  </description>
+
+  <interface name="ext_data_control_manager_v1" version="1">
+    <description summary="manager to control data devices">
+      This interface is a manager that allows creating per-seat data device
+      controls.
+    </description>
+
+    <request name="create_data_source">
+      <description summary="create a new data source">
+        Create a new data source.
+      </description>
+      <arg name="id" type="new_id" interface="ext_data_control_source_v1"
+        summary="data source to create"/>
+    </request>
+
+    <request name="get_data_device">
+      <description summary="get a data device for a seat">
+        Create a data device that can be used to manage a seat's selection.
+      </description>
+      <arg name="id" type="new_id" interface="ext_data_control_device_v1"/>
+      <arg name="seat" type="object" interface="wl_seat"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the manager">
+        All objects created by the manager will still remain valid, until their
+        appropriate destroy request has been called.
+      </description>
+    </request>
+  </interface>
+
+  <interface name="ext_data_control_device_v1" version="1">
+    <description summary="manage a data device for a seat">
+      This interface allows a client to manage a seat's selection.
+
+      When the seat is destroyed, this object becomes inert.
+    </description>
+
+    <request name="set_selection">
+      <description summary="copy data to the selection">
+        This request asks the compositor to set the selection to the data from
+        the source on behalf of the client.
+
+        The given source may not be used in any further set_selection or
+        set_primary_selection requests. Attempting to use a previously used
+        source triggers the used_source protocol error.
+
+        To unset the selection, set the source to NULL.
+      </description>
+      <arg name="source" type="object" interface="ext_data_control_source_v1"
+        allow-null="true"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this data device">
+        Destroys the data device object.
+      </description>
+    </request>
+
+    <event name="data_offer">
+      <description summary="introduce a new ext_data_control_offer">
+        The data_offer event introduces a new ext_data_control_offer object,
+        which will subsequently be used in either the
+        ext_data_control_device.selection event (for the regular clipboard
+        selections) or the ext_data_control_device.primary_selection event (for
+        the primary clipboard selections). Immediately following the
+        ext_data_control_device.data_offer event, the new data_offer object
+        will send out ext_data_control_offer.offer events to describe the MIME
+        types it offers.
+      </description>
+      <arg name="id" type="new_id" interface="ext_data_control_offer_v1"/>
+    </event>
+
+    <event name="selection">
+      <description summary="advertise new selection">
+        The selection event is sent out to notify the client of a new
+        ext_data_control_offer for the selection for this device. The
+        ext_data_control_device.data_offer and the ext_data_control_offer.offer
+        events are sent out immediately before this event to introduce the data
+        offer object. The selection event is sent to a client when a new
+        selection is set. The ext_data_control_offer is valid until a new
+        ext_data_control_offer or NULL is received. The client must destroy the
+        previous selection ext_data_control_offer, if any, upon receiving this
+        event. Regardless, the previous selection will be ignored once a new
+        selection ext_data_control_offer is received.
+
+        The first selection event is sent upon binding the
+        ext_data_control_device object.
+      </description>
+      <arg name="id" type="object" interface="ext_data_control_offer_v1"
+        allow-null="true"/>
+    </event>
+
+    <event name="finished">
+      <description summary="this data control is no longer valid">
+        This data control object is no longer valid and should be destroyed by
+        the client.
+      </description>
+    </event>
+
+    <event name="primary_selection">
+      <description summary="advertise new primary selection">
+        The primary_selection event is sent out to notify the client of a new
+        ext_data_control_offer for the primary selection for this device. The
+        ext_data_control_device.data_offer and the ext_data_control_offer.offer
+        events are sent out immediately before this event to introduce the data
+        offer object. The primary_selection event is sent to a client when a
+        new primary selection is set. The ext_data_control_offer is valid until
+        a new ext_data_control_offer or NULL is received. The client must
+        destroy the previous primary selection ext_data_control_offer, if any,
+        upon receiving this event. Regardless, the previous primary selection
+        will be ignored once a new primary selection ext_data_control_offer is
+        received.
+
+        If the compositor supports primary selection, the first
+        primary_selection event is sent upon binding the
+        ext_data_control_device object.
+      </description>
+      <arg name="id" type="object" interface="ext_data_control_offer_v1"
+        allow-null="true"/>
+    </event>
+
+    <request name="set_primary_selection">
+      <description summary="copy data to the primary selection">
+        This request asks the compositor to set the primary selection to the
+        data from the source on behalf of the client.
+
+        The given source may not be used in any further set_selection or
+        set_primary_selection requests. Attempting to use a previously used
+        source triggers the used_source protocol error.
+
+        To unset the primary selection, set the source to NULL.
+
+        The compositor will ignore this request if it does not support primary
+        selection.
+      </description>
+      <arg name="source" type="object" interface="ext_data_control_source_v1"
+        allow-null="true"/>
+    </request>
+
+    <enum name="error">
+      <entry name="used_source" value="1"
+        summary="source given to set_selection or set_primary_selection was already used before"/>
+    </enum>
+  </interface>
+
+  <interface name="ext_data_control_source_v1" version="1">
+    <description summary="offer to transfer data">
+      The ext_data_control_source object is the source side of a
+      ext_data_control_offer. It is created by the source client in a data
+      transfer and provides a way to describe the offered data and a way to
+      respond to requests to transfer the data.
+    </description>
+
+    <enum name="error">
+      <entry name="invalid_offer" value="1"
+        summary="offer sent after ext_data_control_device.set_selection"/>
+    </enum>
+
+    <request name="offer">
+      <description summary="add an offered MIME type">
+        This request adds a MIME type to the set of MIME types advertised to
+        targets. Can be called several times to offer multiple types.
+
+        Calling this after ext_data_control_device.set_selection is a protocol
+        error.
+      </description>
+      <arg name="mime_type" type="string"
+        summary="MIME type offered by the data source"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this source">
+        Destroys the data source object.
+      </description>
+    </request>
+
+    <event name="send">
+      <description summary="send the data">
+        Request for data from the client. Send the data as the specified MIME
+        type over the passed file descriptor, then close it.
+      </description>
+      <arg name="mime_type" type="string" summary="MIME type for the data"/>
+      <arg name="fd" type="fd" summary="file descriptor for the data"/>
+    </event>
+
+    <event name="cancelled">
+      <description summary="selection was cancelled">
+        This data source is no longer valid. The data source has been replaced
+        by another data source.
+
+        The client should clean up and destroy this data source.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="ext_data_control_offer_v1" version="1">
+    <description summary="offer to transfer data">
+      A ext_data_control_offer represents a piece of data offered for transfer
+      by another client (the source client). The offer describes the different
+      MIME types that the data can be converted to and provides the mechanism
+      for transferring the data directly from the source client.
+    </description>
+
+    <request name="receive">
+      <description summary="request that the data is transferred">
+        To transfer the offered data, the client issues this request and
+        indicates the MIME type it wants to receive. The transfer happens
+        through the passed file descriptor (typically created with the pipe
+        system call). The source client writes the data in the MIME type
+        representation requested and then closes the file descriptor.
+
+        The receiving client reads from the read end of the pipe until EOF and
+        then closes its end, at which point the transfer is complete.
+
+        This request may happen multiple times for different MIME types.
+      </description>
+      <arg name="mime_type" type="string"
+        summary="MIME type desired by receiver"/>
+      <arg name="fd" type="fd" summary="file descriptor for data transfer"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this offer">
+        Destroys the data offer object.
+      </description>
+    </request>
+
+    <event name="offer">
+      <description summary="advertise offered MIME type">
+        Sent immediately after creating the ext_data_control_offer object.
+        One event per offered MIME type.
+      </description>
+      <arg name="mime_type" type="string" summary="offered MIME type"/>
+    </event>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 18773dd758d..a1df276ac6c 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -165,6 +165,7 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         if (process_wayland.zwp_text_input_manager_v3) wayland_text_input_init();
         /* Recreate the data device for the new seat. */
         if (process_wayland.data_device.zwlr_data_control_device_v1 ||
+            process_wayland.data_device.ext_data_control_device_v1 ||
             process_wayland.data_device.wl_data_device)
         {
             wayland_data_device_init();
@@ -202,6 +203,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.zwlr_data_control_manager_v1 =
             wl_registry_bind(registry, id, &zwlr_data_control_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "ext_data_control_manager_v1") == 0)
+    {
+        process_wayland.ext_data_control_manager_v1 =
+            wl_registry_bind(registry, id, &ext_data_control_manager_v1_interface, 1);
+    }
     else if (strcmp(interface, "wl_data_device_manager") == 0)
     {
         process_wayland.wl_data_device_manager =
@@ -411,8 +417,8 @@ BOOL wayland_process_init(void)
     {
         if (!process_wayland.wl_data_device_manager)
             ERR("Wayland compositor doesn't support optional wl_data_device_manager (clipboard won't work)\n");
-        else
-            ERR("Wayland compositor doesn't support optional zwlr_data_control_manager_v1 (clipboard functionality will be limited)\n");
+        else if (!process_wayland.ext_data_control_manager_v1)
+            ERR("Wayland compositor doesn't support optional zwlr_data_control_manager_v1 or ext_data_control_manager_v1 (clipboard functionality will be limited)\n");
     }
 
     if (!process_wayland.xdg_toplevel_icon_manager_v1)
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 429baa2f2f8..eb8eff9f2a7 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -52,6 +52,7 @@ struct wayland_data_offer
     union
     {
         struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1;
+        struct ext_data_control_offer_v1 *ext_data_control_offer_v1;
         struct wl_data_offer *wl_data_offer;
     };
     struct wl_array types;
@@ -345,6 +346,32 @@ static const struct zwlr_data_control_source_v1_listener data_control_source_lis
     data_control_source_cancelled,
 };
 
+static void ext_data_control_source_send(void *data,
+                                     struct ext_data_control_source_v1 *source,
+                                     const char *mime_type, int32_t fd)
+{
+    data_control_source_send(data, NULL, mime_type, fd);
+}
+
+static void ext_data_control_source_cancelled(void *data,
+                                              struct ext_data_control_source_v1 *source)
+{
+    struct wayland_data_device *data_device = data;
+
+    pthread_mutex_lock(&data_device->mutex);
+    ext_data_control_source_v1_destroy(source);
+    if (source == data_device->ext_data_control_source_v1)
+        data_device->ext_data_control_source_v1 = NULL;
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
+static const struct ext_data_control_source_v1_listener ext_data_control_source_listener =
+{
+    ext_data_control_source_send,
+    ext_data_control_source_cancelled
+};
+
+
 /**********************************************************************
  *          zwlr_data_control_offer_v1 handling
  */
@@ -369,6 +396,22 @@ static const struct zwlr_data_control_offer_v1_listener data_control_offer_liste
     data_control_offer_offer,
 };
 
+/**********************************************************************
+ *          ext_data_control_offer_v1 handling
+ */
+
+static void ext_data_control_offer_offer(void *data,
+                                     struct ext_data_control_offer_v1 *ext_data_control_offer_v1,
+                                     const char *type)
+{
+    data_control_offer_offer(data, NULL, type);
+}
+
+static const struct ext_data_control_offer_v1_listener ext_data_control_offer_listener =
+{
+    ext_data_control_offer_offer
+};
+
 static void data_offer_offer(void *data, struct wl_data_offer *wl_data_offer, const char *type)
 {
     data_control_offer_offer(data, NULL, type);
@@ -396,6 +439,12 @@ static void wayland_data_offer_create(void *offer_proxy)
         zwlr_data_control_offer_v1_add_listener(data_offer->zwlr_data_control_offer_v1,
                                                 &data_control_offer_listener, data_offer);
     }
+    else if (process_wayland.ext_data_control_manager_v1)
+    {
+        data_offer->ext_data_control_offer_v1 = offer_proxy;
+        ext_data_control_offer_v1_add_listener(data_offer->ext_data_control_offer_v1,
+                                               &ext_data_control_offer_listener, data_offer);
+    }
     else
     {
         data_offer->wl_data_offer = offer_proxy;
@@ -411,6 +460,8 @@ static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
 
     if (process_wayland.zwlr_data_control_manager_v1)
         zwlr_data_control_offer_v1_destroy(data_offer->zwlr_data_control_offer_v1);
+    else if (process_wayland.ext_data_control_manager_v1)
+        ext_data_control_offer_v1_destroy(data_offer->ext_data_control_offer_v1);
     else
         wl_data_offer_destroy(data_offer->wl_data_offer);
     wl_array_for_each(p, &data_offer->types)
@@ -442,6 +493,11 @@ static int wayland_data_offer_get_import_fd(struct wayland_data_offer *data_offe
         zwlr_data_control_offer_v1_receive(data_offer->zwlr_data_control_offer_v1,
                                            mime_type, data_pipe[1]);
     }
+    else if (process_wayland.ext_data_control_manager_v1)
+    {
+        ext_data_control_offer_v1_receive(data_offer->ext_data_control_offer_v1,
+                                          mime_type, data_pipe[1]);
+    }
     else
     {
         wl_data_offer_receive(data_offer->wl_data_offer, mime_type, data_pipe[1]);
@@ -476,7 +532,15 @@ static void wayland_data_device_destroy_clipboard_data_offer(struct wayland_data
             data_device->clipboard_zwlr_data_control_offer_v1);
         data_device->clipboard_zwlr_data_control_offer_v1 = NULL;
     }
+    else if (process_wayland.ext_data_control_manager_v1 &&
+             data_device->clipboard_ext_data_control_offer_v1)
+    {
+        data_offer = ext_data_control_offer_v1_get_user_data(
+            data_device->clipboard_ext_data_control_offer_v1);
+        data_device->clipboard_ext_data_control_offer_v1 = NULL;
+    }
     else if (!process_wayland.zwlr_data_control_manager_v1 &&
+             !process_wayland.ext_data_control_manager_v1 &&
              data_device->clipboard_wl_data_offer)
     {
         data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
@@ -562,6 +626,8 @@ done:
     {
         if (process_wayland.zwlr_data_control_manager_v1)
             data_device->clipboard_zwlr_data_control_offer_v1 = data_offer->zwlr_data_control_offer_v1;
+        else if (process_wayland.ext_data_control_manager_v1)
+            data_device->clipboard_ext_data_control_offer_v1 = data_offer->ext_data_control_offer_v1;
         else
             data_device->clipboard_wl_data_offer = data_offer->wl_data_offer;
     }
@@ -600,6 +666,45 @@ static const struct zwlr_data_control_device_v1_listener data_control_device_lis
     data_control_device_primary_selection
 };
 
+static void ext_data_control_device_data_offer(
+    void *data,
+    struct ext_data_control_device_v1 *ext_data_control_device_v1,
+    struct ext_data_control_offer_v1 *ext_data_control_offer_v1)
+{
+    wayland_data_offer_create(ext_data_control_offer_v1);
+}
+
+static void ext_data_control_device_selection(
+    void *data,
+    struct ext_data_control_device_v1 *ext_data_control_device_v1,
+    struct ext_data_control_offer_v1 *ext_data_control_offer_v1)
+{
+    handle_selection(data,
+                     ext_data_control_offer_v1 ?
+                     ext_data_control_offer_v1_get_user_data(ext_data_control_offer_v1) :
+                     NULL);
+}
+
+static void ext_data_control_device_finished(
+    void *data, struct ext_data_control_device_v1 *ext_data_control_device_v1)
+{
+}
+
+static void ext_data_control_device_primary_selection(
+    void *data, struct ext_data_control_device_v1 *ext_data_control_device_v1,
+    struct ext_data_control_offer_v1 *id)
+{
+}
+
+static const struct ext_data_control_device_v1_listener ext_data_control_device_listener =
+{
+    ext_data_control_device_data_offer,
+    ext_data_control_device_selection,
+    ext_data_control_device_finished,
+    ext_data_control_device_primary_selection
+};
+
+
 /**********************************************************************
  *          wl_data_source handling
  */
@@ -727,6 +832,21 @@ void wayland_data_device_init(void)
                 data_device);
         }
     }
+    else if (process_wayland.ext_data_control_manager_v1)
+    {
+        if (data_device->ext_data_control_device_v1)
+            ext_data_control_device_v1_destroy(data_device->ext_data_control_device_v1);
+        data_device->ext_data_control_device_v1 =
+            ext_data_control_manager_v1_get_data_device(
+                process_wayland.ext_data_control_manager_v1,
+                process_wayland.seat.wl_seat);
+        if (data_device->ext_data_control_device_v1)
+        {
+            ext_data_control_device_v1_add_listener(
+                data_device->ext_data_control_device_v1, &ext_data_control_device_listener,
+                data_device);
+        }
+    }
     else if (process_wayland.wl_data_device_manager)
     {
         if (data_device->wl_data_device)
@@ -754,6 +874,7 @@ static void clipboard_update(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
     struct zwlr_data_control_source_v1 *zwlr_source = NULL;
+    struct ext_data_control_source_v1 *ext_source = NULL;
     struct wl_data_source *wl_source = NULL;
     UINT *formats, formats_size = 256, i;
     uint32_t serial = 0;
@@ -763,6 +884,11 @@ static void clipboard_update(void)
         zwlr_source = zwlr_data_control_manager_v1_create_data_source(
             process_wayland.zwlr_data_control_manager_v1);
     }
+    else if (process_wayland.ext_data_control_manager_v1)
+    {
+        ext_source = ext_data_control_manager_v1_create_data_source(
+            process_wayland.ext_data_control_manager_v1);
+    }
     else
     {
         serial = InterlockedCompareExchange(&process_wayland.input_serial, 0, 0);
@@ -779,7 +905,7 @@ static void clipboard_update(void)
 
     TRACE("\n");
 
-    if (!zwlr_source && !wl_source)
+    if (!zwlr_source && !ext_source && !wl_source)
     {
         ERR("failed to create data source\n");
         return;
@@ -798,6 +924,7 @@ static void clipboard_update(void)
     {
         ERR("failed to get clipboard formats\n");
         if (wl_source) wl_data_source_destroy(wl_source);
+        else if (ext_source) ext_data_control_source_v1_destroy(ext_source);
         else zwlr_data_control_source_v1_destroy(zwlr_source);
         return;
     }
@@ -810,6 +937,7 @@ static void clipboard_update(void)
         {
             TRACE("offering mime=%s for format=%u\n", format->mime_type, formats[i]);
             if (wl_source) wl_data_source_offer(wl_source, format->mime_type);
+            else if (ext_source) ext_data_control_source_v1_offer(ext_source, format->mime_type);
             else zwlr_data_control_source_v1_offer(zwlr_source, format->mime_type);
         }
     }
@@ -821,6 +949,11 @@ static void clipboard_update(void)
         wl_data_source_offer(wl_source, WINEWAYLAND_TAG_MIME_TYPE);
         wl_data_source_add_listener(wl_source, &data_source_listener, data_device);
     }
+    else if (ext_source)
+    {
+        ext_data_control_source_v1_offer(ext_source, WINEWAYLAND_TAG_MIME_TYPE);
+        ext_data_control_source_v1_add_listener(ext_source, &ext_data_control_source_listener, data_device);
+    }
     else
     {
         zwlr_data_control_source_v1_offer(zwlr_source, WINEWAYLAND_TAG_MIME_TYPE);
@@ -838,6 +971,14 @@ static void clipboard_update(void)
             wl_data_source_destroy(data_device->wl_data_source);
         data_device->wl_data_source = wl_source;
     }
+    else if (ext_source)
+    {
+        if (data_device->ext_data_control_device_v1)
+            ext_data_control_device_v1_set_selection(data_device->ext_data_control_device_v1, ext_source);
+        if (data_device->ext_data_control_source_v1)
+            ext_data_control_source_v1_destroy(data_device->ext_data_control_source_v1);
+        data_device->ext_data_control_source_v1 = ext_source;
+    }
     else
     {
         if (data_device->zwlr_data_control_device_v1)
@@ -867,7 +1008,14 @@ static void render_format(UINT clipboard_format)
         data_offer = zwlr_data_control_offer_v1_get_user_data(
             data_device->clipboard_zwlr_data_control_offer_v1);
     }
+    else if (process_wayland.ext_data_control_manager_v1 &&
+             data_device->clipboard_ext_data_control_offer_v1)
+    {
+        data_offer = ext_data_control_offer_v1_get_user_data(
+            data_device->clipboard_ext_data_control_offer_v1);
+    }
     else if (!process_wayland.zwlr_data_control_manager_v1 &&
+             !process_wayland.ext_data_control_manager_v1 &&
              data_device->clipboard_wl_data_offer)
     {
         data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
@@ -924,6 +1072,7 @@ LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM l
         /* Disable the default clipboard window in the desktop process if we are
          * using the core wl_data_device protocol. */
         if (!process_wayland.zwlr_data_control_manager_v1 &&
+            !process_wayland.ext_data_control_manager_v1 &&
             process_wayland.wl_data_device_manager &&
             !is_winewayland_clipboard_hwnd(hwnd))
         {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 22d4a0abe03..18e88e813aa 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -42,6 +42,7 @@ struct xkb_compose_table;
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 #include "wlr-data-control-unstable-v1-client-protocol.h"
+#include "ext-data-control-v1-client-protocol.h"
 #include "xdg-toplevel-icon-v1-client-protocol.h"
 #include "fractional-scale-v1-client-protocol.h"
 #include "color-management-v1-client-protocol.h"
@@ -190,6 +191,12 @@ struct wayland_data_device
             struct zwlr_data_control_offer_v1 *clipboard_zwlr_data_control_offer_v1;
         };
         struct
+        {
+            struct ext_data_control_device_v1 *ext_data_control_device_v1;
+            struct ext_data_control_source_v1 *ext_data_control_source_v1;
+            struct ext_data_control_offer_v1 *clipboard_ext_data_control_offer_v1;
+        };
+        struct
         {
             struct wl_data_device *wl_data_device;
             struct wl_data_source *wl_data_source;
@@ -216,6 +223,7 @@ struct wayland
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
     struct zwlr_data_control_manager_v1 *zwlr_data_control_manager_v1;
+    struct ext_data_control_manager_v1 *ext_data_control_manager_v1;
     struct wl_data_device_manager *wl_data_device_manager;
     struct xdg_toplevel_icon_manager_v1 *xdg_toplevel_icon_manager_v1;
     struct wp_content_type_manager_v1 *wp_content_type_manager_v1;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index d6a3ab69fe1..6232c151d2e 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -120,6 +120,7 @@ static NTSTATUS waylanddrv_unix_init_clipboard(void *arg)
      * per-process clipboard window and handling, we can use the default clipboard
      * window from the desktop process. */
     if (process_wayland.zwlr_data_control_manager_v1) return STATUS_UNSUCCESSFUL;
+    if (process_wayland.ext_data_control_manager_v1) return STATUS_UNSUCCESSFUL;
     return STATUS_SUCCESS;
 }
 
-- 
2.52.0

