From f4e6ff527c08942208623d13cbdade45be915944 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 15 Aug 2025 21:51:16 -0400
Subject: [PATCH 278/410] winewayland: Optimize steam overlay active detection.

---
 dlls/winewayland.drv/wayland_pointer.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 6aa9a3e224e..d3b6990f9da 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -155,8 +155,6 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy, BOOL se
 
     wayland_win_data_release(data);
 
-    if (wayland_is_overlay_active()) return;
-
     if (!send_input)
     {
         pthread_mutex_lock(&pointer->mutex);
@@ -170,6 +168,8 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy, BOOL se
     } else {
         INPUT input = {0};
 
+        if (wayland_is_overlay_active()) return;
+
         input.type = INPUT_MOUSE;
         input.mi.dx = screen.x;
         input.mi.dy = screen.y;
@@ -318,7 +318,6 @@ static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (InterlockedCompareExchange(&pointer->pointer_frame.discrete_event_handled, FALSE, TRUE)) return;
-    if (wayland_is_overlay_active()) return;
 
     pthread_mutex_lock(&pointer->mutex);
 
@@ -368,6 +367,8 @@ static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
 
     pthread_mutex_lock(&pointer->mutex);
 
+    if (wayland_is_overlay_active()) goto skip;
+
     input.type = INPUT_MOUSE;
 
     if (pointer->pointer_frame.flags & WAYLAND_POINTER_FRAME_ABS)
@@ -414,6 +415,7 @@ static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
             NtUserSendHardwareInput(hwnd, 0, &input, 0);
     }
 
+skip:
     /* reset accumulators when scroll event ends */
     if (pointer->pointer_frame.axis_stop & WAYLAND_POINTER_AXIS_STOP_VERTICAL)
         pointer->pointer_frame.wheel = 0;
@@ -460,7 +462,6 @@ static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_point
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
-    if (wayland_is_overlay_active()) return;
 
     InterlockedExchange(&pointer->pointer_frame.discrete_event_handled, TRUE);
 
@@ -542,7 +543,6 @@ static void relative_pointer_v1_relative_motion(void *private,
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (!(data = wayland_win_data_get(hwnd))) return;
-    if (wayland_is_overlay_active()) return;
 
     f_dxu = wl_fixed_to_double(dx_unaccel);
     f_dyu = wl_fixed_to_double(dy_unaccel);
-- 
2.51.1

