From d360f4a2099e43f2164fb4a96a03c640b26c41a3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jun 2024 13:29:40 +0200
Subject: [PATCH 321/378] win32u: Implement KBDTABLES dead key ToUnicodeEx and
 GetKeyNameText.

---
 dlls/win32u/input.c          | 57 ++++++++++++++++++++++++++++++------
 dlls/win32u/ntuser_private.h |  1 +
 2 files changed, 49 insertions(+), 9 deletions(-)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 5fb5c73bffb..3a21cbe814e 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -503,12 +503,13 @@ static WORD kbd_tables_wchar_to_vkey( const KBDTABLES *tables, WCHAR wch )
     return wch >= 0x0080 ? -1 : 0;
 }
 
-static WCHAR kbd_tables_vkey_to_wchar( const KBDTABLES *tables, UINT vkey, const BYTE *state )
+static WCHAR kbd_tables_vkey_to_wchar( const KBDTABLES *tables, UINT vkey, const BYTE *state, BOOL *is_dead )
 {
     UINT mod, caps_mod, alt, ctrl, caps;
     const VK_TO_WCHAR_TABLE *table;
     const VK_TO_WCHARS1 *entry;
 
+    *is_dead = FALSE;
     alt = state[VK_MENU] & 0x80;
     ctrl = state[VK_CONTROL] & 0x80;
     caps = state[VK_CAPITAL] & 1;
@@ -535,8 +536,9 @@ static WCHAR kbd_tables_vkey_to_wchar( const KBDTABLES *tables, UINT vkey, const
              * The entry corresponds to the mapping when Caps Lock is on, and a second entry follows it
              * with the mapping when Caps Lock is off.
              */
-            if ((entry->Attributes & SGCAPS) && !caps) entry = NEXT_ENTRY(table, entry);
-            if ((entry->Attributes & CAPLOK) && table->nModifications > caps_mod) return entry->wch[caps_mod];
+            if (!caps) while (entry->Attributes & SGCAPS) entry = NEXT_ENTRY(table, entry);
+            if ((entry->Attributes & CAPLOK) && table->nModifications > caps_mod) mod = caps_mod;
+            if ((*is_dead = entry->wch[mod] == WCH_DEAD)) entry = NEXT_ENTRY(table, entry);
             return entry->wch[mod];
         }
     }
@@ -1258,7 +1260,11 @@ INT WINAPI NtUserGetKeyNameText( LONG lparam, WCHAR *buffer, INT size )
     INT code = ((lparam >> 16) & 0x1ff), vkey, len;
     HKL layout = NtUserGetKeyboardLayout( 0 );
     const KBDTABLES *kbd_tables;
+    BYTE state[0x100] = {0};
     VSC_LPWSTR *key_name;
+    USHORT vsc2vk[0x300];
+    BOOL is_dead;
+    WCHAR wch;
 
     TRACE_(keyboard)( "lparam %#x, buffer %p, size %d.\n", (int)lparam, buffer, size );
 
@@ -1267,10 +1273,10 @@ INT WINAPI NtUserGetKeyNameText( LONG lparam, WCHAR *buffer, INT size )
 
     if (!(kbd_tables = user_driver->pKbdLayerDescriptor( layout ))) kbd_tables = &kbdus_tables;
 
+    kbd_tables_init_vsc2vk( kbd_tables, vsc2vk );
+
     if (lparam & 0x2000000)
     {
-        USHORT vsc2vk[0x300];
-        kbd_tables_init_vsc2vk( kbd_tables, vsc2vk );
         switch ((vkey = vsc2vk[code] & 0xff))
         {
         case VK_RSHIFT:
@@ -1286,7 +1292,18 @@ INT WINAPI NtUserGetKeyNameText( LONG lparam, WCHAR *buffer, INT size )
     else key_name = kbd_tables->pKeyNamesExt;
     while (key_name->vsc && key_name->vsc != (BYTE)code) key_name++;
 
-    if (key_name->vsc == (BYTE)code && key_name->pwsz)
+    wch = kbd_tables_vkey_to_wchar( kbd_tables, vsc2vk[code], state, &is_dead );
+    if (wch != WCH_NONE && is_dead)
+    {
+        WCHAR **names = kbd_tables->pKeyNamesDead;
+        while (names[0] && *names[0] != wch) names += 2;
+        if (names[0])
+        {
+            len = min( size - 1, wcslen( names[1] ));
+            memcpy( buffer, names[1], len * sizeof(WCHAR) );
+        }
+    }
+    else if (key_name->vsc == (BYTE)code && key_name->pwsz)
     {
         len = min( size - 1, wcslen( key_name->pwsz ) );
         memcpy( buffer, key_name->pwsz, len * sizeof(WCHAR) );
@@ -1312,7 +1329,10 @@ INT WINAPI NtUserGetKeyNameText( LONG lparam, WCHAR *buffer, INT size )
 INT WINAPI NtUserToUnicodeEx( UINT virt, UINT scan, const BYTE *state,
                               WCHAR *str, int size, UINT flags, HKL layout )
 {
+    struct user_thread_info *thread = get_user_thread_info();
+    WCHAR deadkey = thread->kbd_deadkey;
     const KBDTABLES *kbd_tables;
+    BOOL is_dead = FALSE;
     INT len;
 
     TRACE_(keyboard)( "virt %#x, scan %#x, state %p, str %p, size %d, flags %#x, layout %p.\n",
@@ -1323,16 +1343,35 @@ INT WINAPI NtUserToUnicodeEx( UINT virt, UINT scan, const BYTE *state,
 
     if (!(kbd_tables = user_driver->pKbdLayerDescriptor( layout ))) kbd_tables = &kbdus_tables;
     if (scan & 0x8000) str[0] = 0; /* key up */
-    else str[0] = kbd_tables_vkey_to_wchar( kbd_tables, virt, state );
+    else
+    {
+        str[0] = kbd_tables_vkey_to_wchar( kbd_tables, virt, state, &is_dead );
+        thread->kbd_deadkey = is_dead ? str[0] : 0;
+    }
     if (size > 1) str[1] = 0;
 
     if (str[0] != WCH_NONE) len = 1;
     else str[0] = len = 0;
 
+    if (deadkey && !is_dead && len && str[0])
+    {
+        DEADKEY *key = kbd_tables->pDeadKey;
+        while (key->dwBoth && key->dwBoth != MAKELONG(str[0], deadkey)) key++;
+
+        if (key->dwBoth) str[0] = key->wchComposed;
+        else
+        {
+            if (size > 2) str[2] = 0;
+            str[1] = str[0];
+            str[0] = deadkey;
+            len = 2;
+        }
+    }
+
     if (kbd_tables != &kbdus_tables) user_driver->pReleaseKbdTables( kbd_tables );
 
-    TRACE_(keyboard)( "ret %d, str %s.\n", len, debugstr_wn(str, len) );
-    return len;
+    TRACE_(keyboard)( "ret %d, str %s.\n", is_dead ? -len : len, debugstr_wn(str, len) );
+    return is_dead ? -len : len;
 }
 
 /**********************************************************************
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 5dcc4af8ceb..4ba74259236 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -136,6 +136,7 @@ struct user_thread_info
     HKL                           kbd_layout;             /* Current keyboard layout */
     UINT                          kbd_layout_id;          /* Current keyboard layout ID */
     struct hardware_msg_data     *rawinput;               /* Current rawinput message data */
+    WCHAR                         kbd_deadkey;            /* Current keyboard dead key */
     struct touchinput_thread_data *touchinput;            /* touch input thread local buffer */
     UINT                          spy_indent;             /* Current spy indent */
     BOOL                          clipping_cursor;        /* thread is currently clipping */
-- 
2.51.0

