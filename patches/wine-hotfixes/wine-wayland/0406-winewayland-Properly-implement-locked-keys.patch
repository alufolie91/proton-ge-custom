From c0e51269b6d57558e5682f72b88f603f96c612f1 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 30 Nov 2025 22:28:42 -0600
Subject: [PATCH 406/423] winewayland: Properly implement locked keys.

---
 dlls/winewayland.drv/wayland_keyboard.c | 102 ++++++++++++++++++------
 dlls/winewayland.drv/waylanddrv.h       |   1 +
 2 files changed, 80 insertions(+), 23 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 4b7179e5445..cf2922973b7 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -792,11 +792,25 @@ static BOOL find_xkb_layout_variant(const char *name, const char **layout, const
     return FALSE;
 }
 
+static void send_vkey_input(HWND hwnd, UINT vkey, UINT flags)
+{
+    INPUT input = {0};
+    UINT scan = NtUserMapVirtualKeyEx(vkey, MAPVK_VK_TO_VSC_EX, keyboard_hkl);
+
+    input.type = INPUT_KEYBOARD;
+    input.ki.dwFlags = flags;
+    input.ki.wVk = vkey;
+    input.ki.wScan = scan & 0xff;
+
+    if (scan & ~0xff) input.ki.dwFlags |= KEYEVENTF_EXTENDEDKEY;
+
+    NtUserSendHardwareInput(hwnd, 0, &input, 0);
+}
+
 static void release_all_keys(HWND hwnd)
 {
     BYTE state[256];
     int vkey;
-    INPUT input = {.type = INPUT_KEYBOARD};
 
     if (!NtUserGetAsyncKeyboardState(state)) return;
 
@@ -807,17 +821,11 @@ static void release_all_keys(HWND hwnd)
         /* Skip left/right-agnostic modifier vkeys. */
         if (vkey == VK_SHIFT || vkey == VK_CONTROL || vkey == VK_MENU) continue;
         /* skip modifier keys we handle */
-        if (vkey == VK_NUMLOCK) continue;
+        if (vkey == VK_NUMLOCK || vkey == VK_CAPITAL) continue;
 
         if (state[vkey] & 0x80)
         {
-            UINT scan = NtUserMapVirtualKeyEx(vkey, MAPVK_VK_TO_VSC_EX,
-                                              keyboard_hkl);
-            input.ki.wVk = vkey;
-            input.ki.wScan = scan & 0xff;
-            input.ki.dwFlags = KEYEVENTF_KEYUP;
-            if (scan & ~0xff) input.ki.dwFlags |= KEYEVENTF_EXTENDEDKEY;
-            NtUserSendHardwareInput(hwnd, 0, &input, 0);
+            send_vkey_input(hwnd, vkey, KEYEVENTF_KEYUP);
         }
     }
 }
@@ -1011,28 +1019,75 @@ static void send_right_control(HWND hwnd, uint32_t state)
     NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
+static void set_async_key_state(const BYTE state[256])
+{
+    SERVER_START_REQ(set_key_state)
+    {
+        req->async = 1;
+        wine_server_add_data(req, state, 256);
+        wine_server_call(req);
+    }
+    SERVER_END_REQ;
+}
+
+/* TODO: Find a way to cleanup the duplicated code */
 static void sync_mod_state(HWND hwnd)
 {
     struct wayland_keyboard *keyboard = &process_wayland.keyboard;
-    INPUT input = {0};
-    BYTE state[256];
-    BOOL numlock_changed;
+    BOOL numlock_active, caplock_active;
+    BOOL numlock_changed, caplock_changed;
+    BYTE state[256], state_new[256];
+    BOOL state_changed = FALSE;
 
-    input.type = INPUT_KEYBOARD;
-    input.ki.dwFlags = KEYEVENTF_SCANCODE;
     if (!NtUserGetAsyncKeyboardState(state)) return;
 
     pthread_mutex_lock(&keyboard->mutex);
-    numlock_changed = (!!(state[VK_NUMLOCK] & 0x80) != keyboard->numlock_active);
+    numlock_active = keyboard->numlock_active;
+    caplock_active = keyboard->caplock_active;
     pthread_mutex_unlock(&keyboard->mutex);
 
+    numlock_changed = (!!(state[VK_NUMLOCK] & 0x1) != numlock_active)
+                      && !(state[VK_NUMLOCK] & 0x80);
+    caplock_changed = (!!(state[VK_CAPITAL] & 0x1) != caplock_active)
+                      && !(state[VK_CAPITAL] & 0x80);
+
+    TRACE("numlock %d, caplock %d\n", numlock_active, caplock_active);
+    TRACE("numlock state %x, caplock state %x\n", state[VK_NUMLOCK], state[VK_CAPITAL]);
+
     if (numlock_changed)
     {
-        input.ki.dwFlags |= KEYEVENTF_EXTENDEDKEY;
-        input.ki.wScan = key2scan(KEY_NUMLOCK);
-        if (!keyboard->numlock_active) input.ki.dwFlags |= KEYEVENTF_KEYUP;
+        send_vkey_input(hwnd, VK_NUMLOCK, 0);
+        send_vkey_input(hwnd, VK_NUMLOCK, KEYEVENTF_KEYUP);
+    }
 
-        NtUserSendHardwareInput(hwnd, 0, &input, 0);
+    if (caplock_changed)
+    {
+        send_vkey_input(hwnd, VK_CAPITAL, 0);
+        send_vkey_input(hwnd, VK_CAPITAL, KEYEVENTF_KEYUP);
+    }
+
+    /* if nothing changed we don't need to recheck */
+    if (!numlock_changed && !caplock_changed) return;
+
+    if (!NtUserGetAsyncKeyboardState(state_new)) return;
+
+    /* Ensure we have the proper state in case key events were blocked by hooks. */
+    if (!!(state_new[VK_NUMLOCK] & 0x1) == !!(state[VK_NUMLOCK] & 0x1) && numlock_changed)
+    {
+        state_new[VK_NUMLOCK] = (state_new[VK_NUMLOCK] & ~0x1) | numlock_active;
+        state_changed = TRUE;
+    }
+
+    if (!!(state_new[VK_CAPITAL] & 0x1) == !!(state[VK_CAPITAL] & 0x1) && caplock_changed)
+    {
+        state_new[VK_CAPITAL] = (state_new[VK_CAPITAL] & ~0x1) | caplock_active;
+        state_changed = TRUE;
+    }
+
+    if (state_changed)
+    {
+        WARN("keystate not changed, probably blocked by hooks\n");
+        set_async_key_state(state_new);
     }
 }
 
@@ -1055,10 +1110,8 @@ static void keyboard_handle_key(void *data, struct wl_keyboard *wl_keyboard,
 
     TRACE_(key)("serial=%u hwnd=%p key=%d scan=%#x state=%#x\n", serial, hwnd, key, scan, state);
 
-    sync_mod_state(hwnd);
-
-    /* don't send modifier keys twice */
-    if (key == KEY_NUMLOCK) return;
+    if (key != KEY_NUMLOCK && key != KEY_CAPSLOCK)
+        sync_mod_state(hwnd);
 
     /* NOTE: Windows normally sends VK_CONTROL + VK_MENU only if the layout has KLLF_ALTGR */
     if (key == KEY_RIGHTALT) send_right_control(hwnd, state);
@@ -1093,6 +1146,9 @@ static void keyboard_handle_modifiers(void *data, struct wl_keyboard *wl_keyboar
     keyboard->numlock_active = xkb_state_mod_name_is_active(keyboard->xkb_state,
                                                             XKB_MOD_NAME_NUM,
                                                             XKB_STATE_MODS_LOCKED) > 0;
+    keyboard->caplock_active = xkb_state_mod_name_is_active(keyboard->xkb_state,
+                                                            XKB_MOD_NAME_CAPS,
+                                                            XKB_STATE_MODS_LOCKED) > 0;
     pthread_mutex_unlock(&keyboard->mutex);
 
     set_current_xkb_group(xkb_group);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9c086d64cee..d4f2991210c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -122,6 +122,7 @@ struct wayland_keyboard
     struct xkb_context *xkb_context;
     struct xkb_state *xkb_state;
     BOOL numlock_active;
+    BOOL caplock_active;
     HWND focused_hwnd;
     pthread_mutex_t mutex;
 };
-- 
2.52.0

