From 4418606fd5b6e4a424d70286c1dab85b63212687 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 3 Jun 2025 16:09:08 -0600
Subject: [PATCH 012/327] ucrtbase: Fix case mapping and ctype1 tables for utf8
 locale.

CW-Bug-Id: #25473
---
 dlls/msvcrt/locale.c | 33 ++++++++++++++++++++++++---------
 1 file changed, 24 insertions(+), 9 deletions(-)

diff --git a/dlls/msvcrt/locale.c b/dlls/msvcrt/locale.c
index 224182ed3e1..ccfcb753725 100644
--- a/dlls/msvcrt/locale.c
+++ b/dlls/msvcrt/locale.c
@@ -1292,7 +1292,7 @@ static pthreadlocinfo create_locinfo(int category,
     char buf[256];
     BOOL sname_match;
     wchar_t wbuf[256], map_buf[256];
-    int i, ret;
+    int i, ret, count;
 
     TRACE("(%d %s)\n", category, locale);
 
@@ -1513,8 +1513,10 @@ static pthreadlocinfo create_locinfo(int category,
         locinfo->ctype1[0] = 0;
         locinfo->pctype = locinfo->ctype1+1;
 
+        count = locinfo->lc_codepage == CP_UTF8 ? 128 : 256;
+
         buf[1] = buf[2] = '\0';
-        for(i=1; i<257; i++) {
+        for(i = 1; i < count + 1; i++) {
             buf[0] = i-1;
 
             MultiByteToWideChar(locinfo->lc_codepage, 0, buf, 1, wbuf, 1);
@@ -1522,6 +1524,17 @@ static pthreadlocinfo create_locinfo(int category,
             locinfo->ctype1[i] = 0;
             GetStringTypeW(CT_CTYPE1, wbuf, 1, &locinfo->ctype1[i]);
         }
+        if (locinfo->lc_codepage == CP_UTF8)
+        {
+            for (; i < 257; ++i)
+                locinfo->ctype1[i] = (i >= 0xc3 && i <= 0xf5) ? _LEADBYTE : 0;
+        }
+        else
+        {
+            for(i=0; cp_info.LeadByte[i+1]!=0; i+=2)
+                for(j=cp_info.LeadByte[i]; j<=cp_info.LeadByte[i+1]; j++)
+                    locinfo->ctype1[j+1] |= _LEADBYTE;
+        }
 
         for(i=0; cp_info.LeadByte[i+1]!=0; i+=2)
             for(j=cp_info.LeadByte[i]; j<=cp_info.LeadByte[i+1]; j++)
@@ -1539,15 +1552,17 @@ static pthreadlocinfo create_locinfo(int category,
                 buf[i] = i;
         }
 
-        MultiByteToWideChar(locinfo->lc_codepage, 0, buf, 256, wbuf, 256);
-        LCMapStringW(LOCALE_INVARIANT, LCMAP_LOWERCASE, wbuf, 256, map_buf, 256);
-        if ((ret = WideCharToMultiByte(locinfo->lc_codepage, 0, map_buf, 256,
-                (char *)locinfo->pclmap, 256, NULL, NULL)) != 256)
+        MultiByteToWideChar(locinfo->lc_codepage, 0, buf, count, wbuf, count);
+        LCMapStringW(LOCALE_INVARIANT, LCMAP_LOWERCASE, wbuf, count, map_buf, count);
+        if ((ret = WideCharToMultiByte(locinfo->lc_codepage, 0, map_buf, count,
+                (char *)locinfo->pclmap, count, NULL, NULL)) != count)
             FIXME("WideCharToMultiByte failed, ret %d, error %lu.\n", ret, GetLastError());
-        LCMapStringW(LOCALE_INVARIANT, LCMAP_UPPERCASE, wbuf, 256, map_buf, 256);
-        if ((ret = WideCharToMultiByte(locinfo->lc_codepage, 0, map_buf, 256,
-                (char *)locinfo->pcumap, 256, NULL, NULL)) != 256)
+        LCMapStringW(LOCALE_INVARIANT, LCMAP_UPPERCASE, wbuf, count, map_buf, count);
+        if ((ret = WideCharToMultiByte(locinfo->lc_codepage, 0, map_buf, count,
+                (char *)locinfo->pcumap, count, NULL, NULL)) != count)
             FIXME("WideCharToMultiByte failed, ret %d, error %lu.\n", ret, GetLastError());
+        for (i = count; i < 256; ++i)
+            ((char *)locinfo->pclmap)[i] = ((char *)locinfo->pcumap)[i] = i;
     } else {
         locinfo->lc_clike = 1;
         locinfo->mb_cur_max = 1;
-- 
2.51.0

