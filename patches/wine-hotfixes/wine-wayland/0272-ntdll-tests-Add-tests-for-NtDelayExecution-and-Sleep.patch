From 4641dc86fd12cbb06d0fa9d5c4c89c184c210eb2 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Wed, 22 Jan 2025 01:54:33 -0800
Subject: [PATCH 272/379] ntdll/tests: Add tests for NtDelayExecution and
 Sleep(Ex).

---
 dlls/ntdll/tests/sync.c | 103 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 103 insertions(+)

diff --git a/dlls/ntdll/tests/sync.c b/dlls/ntdll/tests/sync.c
index b3b10015f4e..e89a70a4983 100644
--- a/dlls/ntdll/tests/sync.c
+++ b/dlls/ntdll/tests/sync.c
@@ -33,6 +33,7 @@ static NTSTATUS (WINAPI *pNtCreateEvent) ( PHANDLE, ACCESS_MASK, const OBJECT_AT
 static NTSTATUS (WINAPI *pNtCreateKeyedEvent)( HANDLE *, ACCESS_MASK, const OBJECT_ATTRIBUTES *, ULONG );
 static NTSTATUS (WINAPI *pNtCreateMutant)( HANDLE *, ACCESS_MASK, const OBJECT_ATTRIBUTES *, BOOLEAN );
 static NTSTATUS (WINAPI *pNtCreateSemaphore)( HANDLE *, ACCESS_MASK, const OBJECT_ATTRIBUTES *, LONG, LONG );
+static NTSTATUS (WINAPI *pNtDelayExecution)( BOOLEAN, const LARGE_INTEGER * );
 static NTSTATUS (WINAPI *pNtOpenEvent)( HANDLE *, ACCESS_MASK, const OBJECT_ATTRIBUTES * );
 static NTSTATUS (WINAPI *pNtOpenKeyedEvent)( HANDLE *, ACCESS_MASK, const OBJECT_ATTRIBUTES * );
 static NTSTATUS (WINAPI *pNtPulseEvent)( HANDLE, LONG * );
@@ -1252,6 +1253,106 @@ static void test_barrier(void)
         }
         ok( *p.count == p.thread_count, "got %ld.\n", *p.count );
         ok( true_ret_count == 1, "got %ld.\n", true_ret_count );
+
+        winetest_pop_context();
+    }
+}
+
+/* An overview of possible combinations and return values:
+ * - Non-alertable, zero timeout: STATUS_SUCCESS or STATUS_NO_YIELD_PERFORMED
+ * - Non-alertable, non-zero timeout: STATUS_SUCCESS
+ * - Alertable, zero timeout: STATUS_SUCCESS, STATUS_NO_YIELD_PERFORMED, or STATUS_USER_APC
+ * - Alertable, non-zero timeout: STATUS_SUCCESS or STATUS_USER_APC
+ * - Sleep/SleepEx don't modify LastError, no matter what
+ */
+
+static VOID CALLBACK apc_proc( ULONG_PTR param )
+{
+    InterlockedIncrement( (LONG *)param );
+}
+
+static void test_delayexecution(void)
+{
+    static const struct
+    {
+        BOOLEAN alertable;
+        LONGLONG timeout;
+        BOOLEAN queue_apc;
+        const char *desc;
+    } tests[] =
+    {
+        { FALSE, 0,      FALSE, "non-alertable yield" },
+        { FALSE, -10000, FALSE, "non-alertable sleep" },
+        { TRUE,  0,      FALSE, "alertable yield" },
+        { TRUE,  -10000, FALSE, "alertable sleep" },
+        { TRUE,  0,      TRUE,  "alertable yield with APC" },
+        { TRUE,  -10000, TRUE,  "alertable sleep with APC" },
+    };
+    unsigned int i;
+    LARGE_INTEGER timeout;
+    ULONG apc_count;
+    NTSTATUS status;
+    DWORD ret;
+
+    for (i = 0; i < ARRAY_SIZE(tests); i++)
+    {
+        winetest_push_context("%s", tests[i].desc);
+        timeout.QuadPart = tests[i].timeout;
+
+        apc_count = 0;
+        if (tests[i].queue_apc)
+            QueueUserAPC( apc_proc, GetCurrentThread(), (ULONG_PTR)&apc_count );
+
+        /* test NtDelayExecution */
+        SetLastError( 0xdeadbeef );
+        status = pNtDelayExecution( tests[i].alertable, &timeout );
+        ok( GetLastError() == 0xdeadbeef, "got error %#lx.\n", GetLastError() );
+
+        if (tests[i].alertable && tests[i].queue_apc)
+        {
+            ok( status == STATUS_USER_APC, "got status %#lx.\n", status );
+            ok( apc_count, "got 0.\n" );
+        }
+        else
+        {
+            todo_wine_if(status == STATUS_TIMEOUT)
+            ok( status == STATUS_SUCCESS || (!tests[i].timeout && status == STATUS_NO_YIELD_PERFORMED),
+                "got status %#lx.\n", status );
+        }
+
+        if (tests[i].queue_apc) /* don't leave leftover APCs */
+            SleepEx( 0, TRUE );
+
+        /* test SleepEx */
+        apc_count = 0;
+        if (tests[i].queue_apc)
+            QueueUserAPC( apc_proc, GetCurrentThread(), (ULONG_PTR)&apc_count );
+
+        SetLastError( 0xdeadbeef );
+        ret = SleepEx( timeout.QuadPart ? (-timeout.QuadPart / 10000) : 0, tests[i].alertable );
+        ok( GetLastError() == 0xdeadbeef, "got error %#lx.\n", GetLastError() );
+
+        if (tests[i].alertable && tests[i].queue_apc)
+        {
+            ok( ret == WAIT_IO_COMPLETION, "got %lu.\n", ret );
+            ok( apc_count, "got 0.\n" );
+        }
+        else
+        {
+            ok( !ret, "got %lu.\n", ret );
+        }
+
+        if (tests[i].queue_apc)
+            SleepEx( 0, TRUE );
+
+        /* test Sleep (non-alertable only) */
+        if (!tests[i].alertable)
+        {
+            SetLastError( 0xdeadbeef );
+            Sleep( timeout.QuadPart ? (-timeout.QuadPart / 10000) : 0 );
+            ok( GetLastError() == 0xdeadbeef, "got error %#lx.\n", GetLastError() );
+        }
+
         winetest_pop_context();
     }
 }
@@ -1272,6 +1373,7 @@ START_TEST(sync)
     pNtCreateKeyedEvent             = (void *)GetProcAddress(module, "NtCreateKeyedEvent");
     pNtCreateMutant                 = (void *)GetProcAddress(module, "NtCreateMutant");
     pNtCreateSemaphore              = (void *)GetProcAddress(module, "NtCreateSemaphore");
+    pNtDelayExecution               = (void *)GetProcAddress(module, "NtDelayExecution");
     pNtOpenEvent                    = (void *)GetProcAddress(module, "NtOpenEvent");
     pNtOpenKeyedEvent               = (void *)GetProcAddress(module, "NtOpenKeyedEvent");
     pNtPulseEvent                   = (void *)GetProcAddress(module, "NtPulseEvent");
@@ -1308,4 +1410,5 @@ START_TEST(sync)
     test_tid_alert( argv );
     test_completion_port_scheduling();
     test_barrier();
+    test_delayexecution();
 }
-- 
2.51.0

