From 786a285493eac63f91159ab2c9e0247bd5d8b0f6 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 3 Oct 2025 22:26:11 -0500
Subject: [PATCH 338/347] winewayland: Reimplement non-resizeable windows.

The old implementation causes loader section timeouts
---
 dlls/winewayland.drv/wayland_surface.c | 34 --------------------------
 dlls/winewayland.drv/waylanddrv.h      |  3 ++-
 dlls/winewayland.drv/window.c          | 20 +++++++++++++++
 3 files changed, 22 insertions(+), 35 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 87e14ab40e5..ddc04e42664 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -637,15 +637,6 @@ static void wayland_surface_get_rect_in_monitor(struct wayland_surface *surface,
     OffsetRect(rect, -surface->window.rect.left, -surface->window.rect.top);
 }
 
-static BOOL is_window_resizable(struct wayland_surface *surface)
-{
-    DWORD style = NtUserGetWindowLongW(surface->hwnd, GWL_STYLE);
-
-    if (style & WS_THICKFRAME) return TRUE;
-
-    return surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN;
-}
-
 /**********************************************************************
  *          wayland_surface_reconfigure_geometry
  *
@@ -699,31 +690,6 @@ static void wayland_surface_reconfigure_geometry(struct wayland_surface *surface
                                         rect.bottom - rect.top);
         if (wayland_surface_is_toplevel(surface))
         {
-            /* HACK: update min/max size depending on if the window is resizable */
-            if (!is_window_resizable(surface))
-            {
-                xdg_toplevel_set_min_size(
-                    surface->xdg_toplevel,
-                    rect.right - rect.left,
-                    rect.bottom - rect.top);
-                xdg_toplevel_set_max_size(
-                    surface->xdg_toplevel,
-                    rect.right - rect.left,
-                    rect.bottom - rect.top
-                );
-            }
-            else
-            {
-                xdg_toplevel_set_min_size(
-                    surface->xdg_toplevel,
-                    0, 0
-                );
-                xdg_toplevel_set_max_size(
-                    surface->xdg_toplevel,
-                    0, 0
-                );
-            }
-
             /* HACK: reset fullscreen state to ensure surface is on correct output */
             if (surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN)
             {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 102a82086cd..ff9384a87e5 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -87,7 +87,8 @@ enum wayland_surface_config_state
     WAYLAND_SURFACE_CONFIG_STATE_RESIZING = (1 << 1),
     WAYLAND_SURFACE_CONFIG_STATE_TILED = (1 << 2),
     WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN = (1 << 3),
-    WAYLAND_SURFACE_CONFIG_STATE_MINIMIZED = (1 << 4)
+    WAYLAND_SURFACE_CONFIG_STATE_MINIMIZED = (1 << 4),
+    WAYLAND_SURFACE_CONFIG_STATE_RESIZEABLE = (1 << 5)
 };
 
 enum wayland_surface_role
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index cd570668b0e..47a6ae09529 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -177,6 +177,9 @@ static void wayland_win_data_get_config(struct wayland_win_data *data,
         window_state |= WAYLAND_SURFACE_CONFIG_STATE_MAXIMIZED;
     }
 
+    if (style & WS_THICKFRAME || data->is_fullscreen)
+        window_state |= WAYLAND_SURFACE_CONFIG_STATE_RESIZEABLE;
+
     conf->state = window_state;
     conf->scale = conf->fractional_scale * NtUserGetSystemDpiForProcess(0) / 96.0;
     conf->visible = (style & WS_VISIBLE) == WS_VISIBLE;
@@ -247,6 +250,7 @@ static void wayland_surface_update_state_toplevel(struct wayland_surface *surfac
 {
     BOOL processing_config = surface->processing.serial &&
                              !surface->processing.processed;
+    RECT rect = surface->window.rect;
 
     TRACE("hwnd=%p window_state=%#x %s->state=%#x\n",
           surface->hwnd, surface->window.state,
@@ -291,6 +295,22 @@ static void wayland_surface_update_state_toplevel(struct wayland_surface *surfac
         {
             xdg_toplevel_set_minimized(surface->xdg_toplevel);
         }
+        if (surface->window.state & WAYLAND_SURFACE_CONFIG_STATE_RESIZEABLE)
+        {
+            xdg_toplevel_set_min_size(surface->xdg_toplevel, 0, 0);
+            xdg_toplevel_set_max_size(surface->xdg_toplevel, 0, 0);
+        }
+        else
+        {
+            xdg_toplevel_set_min_size(
+                surface->xdg_toplevel,
+                rect.right - rect.left,
+                rect.bottom - rect.top);
+            xdg_toplevel_set_max_size(
+                surface->xdg_toplevel,
+                rect.right - rect.left,
+                rect.bottom - rect.top);
+        }
     }
     else
     {
-- 
2.51.0

