From 91e9fc8f198a7e032c526db32a28e65096d105fd Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 13 Jun 2025 14:46:40 -0400
Subject: [PATCH 094/378] Import WIP atidxx implementation

---
 configure.ac                      |   1 +
 dlls/atidxx64/Makefile.in         |   9 +
 dlls/atidxx64/atidxx.h            | 137 ++++++
 dlls/atidxx64/atidxx64.spec       |  17 +
 dlls/atidxx64/dxvk_interfaces.idl | 153 +++++++
 dlls/atidxx64/main.c              | 677 ++++++++++++++++++++++++++++++
 loader/wine.inf.in                |   1 +
 7 files changed, 995 insertions(+)
 create mode 100644 dlls/atidxx64/Makefile.in
 create mode 100644 dlls/atidxx64/atidxx.h
 create mode 100644 dlls/atidxx64/atidxx64.spec
 create mode 100644 dlls/atidxx64/dxvk_interfaces.idl
 create mode 100644 dlls/atidxx64/main.c

diff --git a/configure.ac b/configure.ac
index 4003ffd3b90..73deb27f9d4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2465,6 +2465,7 @@ WINE_CONFIG_MAKEFILE(dlls/apphelp/tests)
 WINE_CONFIG_MAKEFILE(dlls/appwiz.cpl)
 WINE_CONFIG_MAKEFILE(dlls/appxdeploymentclient)
 WINE_CONFIG_MAKEFILE(dlls/atiadlxx)
+WINE_CONFIG_MAKEFILE(dlls/atidxx64)
 WINE_CONFIG_MAKEFILE(dlls/atl)
 WINE_CONFIG_MAKEFILE(dlls/atl/tests)
 WINE_CONFIG_MAKEFILE(dlls/atl100)
diff --git a/dlls/atidxx64/Makefile.in b/dlls/atidxx64/Makefile.in
new file mode 100644
index 00000000000..e4c1d2875c8
--- /dev/null
+++ b/dlls/atidxx64/Makefile.in
@@ -0,0 +1,9 @@
+MODULE = atidxx64.dll
+IMPORTS = version vulkan-1 user32 gdi32
+IMPORTLIB = atidxx64
+
+EXTRADLLFLAGS = -mno-cygwin -Wb,--prefer-native
+
+SOURCES = \
+	main.c \
+	dxvk_interfaces.idl
diff --git a/dlls/atidxx64/atidxx.h b/dlls/atidxx64/atidxx.h
new file mode 100644
index 00000000000..b57776daafd
--- /dev/null
+++ b/dlls/atidxx64/atidxx.h
@@ -0,0 +1,137 @@
+#include "objbase.h"
+
+typedef struct
+{
+    unsigned int        majorVersion;
+    unsigned int        minorVersion;
+} AmdDxExtVersion;
+
+typedef enum
+{
+                                                       // D3D10_DDI_PRIMITIVE_TOPOLOGY_* values
+    AmdDxExtPrimitiveTopology_Undefined          = 0,  // D3D10 UNDEFINED
+    AmdDxExtPrimitiveTopology_PointList          = 1,  // D3D10 POINTLIST
+    AmdDxExtPrimitiveTopology_LineList           = 2,  // D3D10 LINELIST
+    AmdDxExtPrimitiveTopology_LineStrip          = 3,  // D3D10 LINESTRIP
+    AmdDxExtPrimitiveTopology_TriangleList       = 4,  // D3D10 TRIANGLELIST
+    AmdDxExtPrimitiveTopology_TriangleStrip      = 5,  // D3D10 TRIANGLESTRIP
+                                                       // 6 is reserved for legacy triangle fans
+    AmdDxExtPrimitiveTopology_ExtQuadList        = 7,  // No D3D10 equivalent
+    AmdDxExtPrimitiveTopology_ExtPatch           = 8,  // No D3D10 equivalent
+    AmdDxExtPrimitiveTopology_ExtScreenRectList  = 9,  // No D3D10 equivalent
+    AmdDxExtPrimitiveTopology_LineListAdj        = 10, // D3D10 LINELIST_ADJ
+    AmdDxExtPrimitiveTopology_LineStripAdj       = 11, // D3D10 LINESTRIP_ADJ
+    AmdDxExtPrimitiveTopology_TriangleListAdj    = 12, // D3D10 TRIANGLELIST_ADJ
+    AmdDxExtPrimitiveTopology_TriangleStripAdj   = 13, // D3D10 TRIANGLESTRIP_ADJ
+    AmdDxExtPrimitiveTopology_Max                = 14
+} AmdDxExtPrimitiveTopology;
+
+typedef enum
+{
+    AmdDxExtFeature_ScreenRectSupport           = 1, // Screen Rect supported - data is BOOL
+    AmdDxExtFeature_DeviceHp3d                  = 2, // HP3D support
+    AmdDxExtFeature_DeviceCtxSupport            = 3, // Device Ctx Support
+} AmdDxExtFeatureToken;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+#define THISCALLMETHOD_(type,method)  virtual type __thiscall method
+#else
+#define THISCALLMETHOD_(type,method)  type (__thiscall *method)
+#endif
+
+#define INTERFACE IAmdDxExtInterface
+DECLARE_INTERFACE(IAmdDxExtInterface)
+{
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExt
+DECLARE_INTERFACE_(IAmdDxExt, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExt methods ***/
+    THISCALLMETHOD_(HRESULT, IaGetPrimitiveTopology)(THIS_ AmdDxExtPrimitiveTopology *topology) PURE;
+    THISCALLMETHOD_(HRESULT, GetVersion)(THIS_ AmdDxExtVersion *version) PURE;
+    THISCALLMETHOD_(IAmdDxExtInterface*,GetExtInterface)(THIS_ unsigned int iface) PURE;
+
+
+    THISCALLMETHOD_(HRESULT, IaSetPrimitiveTopology)(THIS_ D3D_PRIMITIVE_TOPOLOGY topology) PURE;
+    THISCALLMETHOD_(HRESULT, SetSingleSampleRead)(THIS_ ID3D10Resource *res, BOOL single_sample) PURE;
+    THISCALLMETHOD_(HRESULT, SetSingleSampleRead11)(THIS_ ID3D11Resource *res, BOOL single_sample) PURE;
+    THISCALLMETHOD_(HRESULT, IaSetPrimitiveTopologyCtx)(THIS_ unsigned int topology, ID3D11DeviceContext *ctx) PURE;
+    THISCALLMETHOD_(HRESULT, QueryFeatureSupport)(THIS_ unsigned int feature_token, void *data, unsigned int data_size) PURE;
+    THISCALLMETHOD_(HRESULT, IaGetPrimitiveTopologyCtx)(THIS_ AmdDxExtPrimitiveTopology *topology, ID3D11DeviceContext *ctx) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExtUAVOverlap
+DECLARE_INTERFACE_(IAmdDxExtUAVOverlap, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExtUAVOverlap methods ***/
+    THISCALLMETHOD_(void, Unk1)(THIS) PURE;
+    THISCALLMETHOD_(HRESULT, BeginUAVOverlap)(THIS) PURE;
+    THISCALLMETHOD_(HRESULT, EndUAVOverlap)(THIS) PURE;
+    THISCALLMETHOD_(void, GetVersion)(THIS, AmdDxExtVersion* version) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExtQuadBufferStereo
+DECLARE_INTERFACE_(IAmdDxExtQuadBufferStereo, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExtQuadBufferStereo methods ***/
+    THISCALLMETHOD_(HRESULT, EnableQuadBufferStereo)(THIS, BOOL enable) PURE;
+    THISCALLMETHOD_(UINT, GetLineOffset)(THIS, IDXGISwapChain *swapchain) PURE;
+    THISCALLMETHOD_(HRESULT, GetDisplayModeList)(THIS, DXGI_FORMAT format, unsigned int flags, unsigned int *num_modes, DXGI_MODE_DESC *desc) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExtDepthBounds
+DECLARE_INTERFACE_(IAmdDxExtDepthBounds, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExtDepthBounds methods ***/
+    THISCALLMETHOD_(void, Unk1)(THIS) PURE;
+    THISCALLMETHOD_(HRESULT, SetDepthBounds)(THIS, BOOL enabled, float min, float max) PURE;
+    THISCALLMETHOD_(void, GetVersion)(THIS, AmdDxExtVersion *version) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExtMultidrawIndirect
+DECLARE_INTERFACE_(IAmdDxExtMultidrawIndirect, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExtMultidrawIndirect methods ***/
+    THISCALLMETHOD_(void, Unk1)(THIS) PURE;
+    THISCALLMETHOD_(void, GetVersion)(THIS, AmdDxExtVersion *version) PURE;
+    THISCALLMETHOD_(HRESULT, MultiDrawIndirect)(THIS, unsigned int draw_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride) PURE;
+    THISCALLMETHOD_(HRESULT, MultiDrawIndexedIndirect)(THIS, unsigned int draw_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride) PURE;
+    THISCALLMETHOD_(HRESULT, MultiDrawIndirectCount)(THIS, ID3D11Buffer *buffer_for_count, unsigned int byte_offset_for_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride) PURE;
+    THISCALLMETHOD_(HRESULT, MultiDrawIndexedIndirectCount)(THIS, ID3D11Buffer *buffer_for_count, unsigned int byte_offset_for_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride) PURE;
+};
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/dlls/atidxx64/atidxx64.spec b/dlls/atidxx64/atidxx64.spec
new file mode 100644
index 00000000000..4012dcb0303
--- /dev/null
+++ b/dlls/atidxx64/atidxx64.spec
@@ -0,0 +1,17 @@
+@ stub AmdD3D11CreateDevice
+@ stub AmdD3D11CreateDeviceAndSwapChain
+@ stub AmdD3D11CreateDeviceAndSwapChainExt()
+@ stdcall AmdD3D11CreateDeviceExt(ptr long ptr long ptr long long ptr ptr ptr ptr)
+@ cdecl AmdDxExtCreate11(ptr ptr)
+@ stub AmdDxExtCreate
+@ stub AmdDxShimQueryInterface
+@ stub XdxInitXopAdapterServices
+@ stub XdxInitXopServices
+@ stub XdxQueryTlsLookupTable
+@ stub AmdDxGsaCompileShader
+@ stub AmdDxGsaFreeCompiledShader
+@ stub AmdGetDxxModuleHandle
+@ stub AmdLiquidVrAffinityInit
+@ stub AmdLiquidVrAffinityTerm
+@ stub AmdLiquidVrD3D11CreateDevice
+@ stub AmdLiquidVrD3D11WrapDeviceContext
diff --git a/dlls/atidxx64/dxvk_interfaces.idl b/dlls/atidxx64/dxvk_interfaces.idl
new file mode 100644
index 00000000000..9e405a32a06
--- /dev/null
+++ b/dlls/atidxx64/dxvk_interfaces.idl
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2023      Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+import "d3d11.idl";
+import "dxgi1_6.idl";
+
+typedef struct VkInstance_T *VkInstance;
+typedef void (__stdcall *PFN_vkVoidFunction)(void);
+typedef PFN_vkVoidFunction (__stdcall *PFN_vkGetInstanceProcAddr)(VkInstance instance, const char* pName);
+
+typedef enum D3D11_VK_EXTENSION
+{
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT,
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT_COUNT,
+    D3D11_VK_EXT_DEPTH_BOUNDS,
+    D3D11_VK_EXT_BARRIER_CONTROL,
+    D3D11_VK_NVX_BINARY_IMPORT,
+    D3D11_VK_NVX_IMAGE_VIEW_HANDLE,
+} D3D11_VK_EXTENSION;
+
+typedef enum D3D11_VK_BARRIER_CONTROL
+{
+    D3D11_VK_BARRIER_CONTROL_IGNORE_WRITE_AFTER_WRITE = 0x1,
+    D3D11_VK_BARRIER_CONTROL_IGNORE_GRAPHICS_UAV = 0x2,
+} D3D11_VK_BARRIER_CONTROL;
+
+[
+    object,
+    uuid(bb8a4fb9-3935-4762-b44b-35189a26414a),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtShader : IUnknown
+{
+    HRESULT GetSpirvCode([in, out] SIZE_T *code_size, [out] void *code);
+}
+
+[
+    object,
+    uuid(8a6e3c42-f74c-45b7-8265-a231b677ca17),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice : IUnknown
+{
+    BOOL GetExtensionSupport([in] D3D11_VK_EXTENSION extension);
+}
+
+[
+    object,
+    uuid(cfcf64ef-9586-46d0-bca4-97cf2ca61b06),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice1 : ID3D11VkExtDevice
+{
+    BOOL GetResourceHandleGPUVirtualAddressAndSizeNVX([in] void *object, [out] UINT64 *gpu_va_start,
+            [out] UINT64 *gpu_va_size);
+    BOOL CreateUnorderedAccessViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_UNORDERED_ACCESS_VIEW_DESC *desc, [out] ID3D11UnorderedAccessView **uav,
+            UINT32 *driver_handle);
+    BOOL CreateShaderResourceViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_SHADER_RESOURCE_VIEW_DESC* desc, [out] ID3D11ShaderResourceView **srv,
+            UINT32 *dirver_handle);
+    BOOL CreateSamplerStateAndGetDriverHandleNVX([in] const D3D11_SAMPLER_DESC *sample_desc,
+            [out] ID3D11SamplerState **sample_state, UINT32 *driver_handle);
+    BOOL CreateCubinComputeShaderWithNameNVX([in] const void *cubin, [in] UINT32 size, [in] UINT32 block_x,
+            [in] UINT32 block_y, [in] UINT32 block_z, [in] const char *shader_name, [out] IUnknown **shader);
+    BOOL GetCudaTextureObjectNVX([in] UINT32 srv_driver_hadnle, [in] UINT32 sample_driver_handle,
+            [out] UINT32 *cuda_texture_handle);
+}
+
+[
+    object,
+    uuid(fd0bca13-5cb6-4c3a-987e-4750de2ca791),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext : IUnknown
+{
+    void MultiDrawIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args, [in] UINT byte_offset_for_args,
+            [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void SetDepthBoundsTest([in] BOOL enable, [in] FLOAT min_depth_bounds, [in] FLOAT max_depth_bounds);
+    void SetBarrierControl([in] UINT control_flags);
+}
+
+[
+    object,
+    uuid(874b09b2-ae0b-41d8-8476-5f3b7a0e879d),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext1 : ID3D11VkExtContext
+{
+    BOOL LaunchCubinShaderNVX([in] IUnknown *shader,[in] UINT32 grid_x, [in] UINT32 grid_y, [in] UINT32 grid_z,
+            [in] const void *params, [in] UINT32 param_size, [in] void * const *read_resources,
+            [in] UINT32 read_resource_count, [in] void* const *write_resources, [in] UINT32 write_resources_count);
+}
+
+[
+    object,
+    uuid(4c5e1b0d-b0c8-4131-bfd8-9b2476f7f408),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory : IUnknown
+{
+    void GetVulkanInstance(
+          [out] VkInstance *pInstance,
+          [out] PFN_vkGetInstanceProcAddr *ppfnVkGetInstanceProcAddr);
+}
+
+[
+    object,
+    uuid(2a289dbd-2d0a-4a51-89f7-f2adce465cd6),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory1 : IDXGIVkInteropFactory
+{
+  HRESULT GetGlobalHDRState(
+          [out] DXGI_COLOR_SPACE_TYPE   *pOutColorSpace,
+          [out] DXGI_HDR_METADATA_HDR10 *ppOutMetadata) = 0;
+
+  HRESULT SetGlobalHDRState(
+          [in] DXGI_COLOR_SPACE_TYPE    ColorSpace,
+    [in] const DXGI_HDR_METADATA_HDR10 *pMetadata) = 0;
+}
diff --git a/dlls/atidxx64/main.c b/dlls/atidxx64/main.c
new file mode 100644
index 00000000000..5d4def2d383
--- /dev/null
+++ b/dlls/atidxx64/main.c
@@ -0,0 +1,677 @@
+/*
+ * atidxx64 implementation
+ *
+ * Copyright 2023 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+#include "wine/vulkan.h"
+#include "wine/asm.h"
+
+#define COBJMACROS
+#include "initguid.h"
+#include "d3d11.h"
+#include "d3d12.h"
+
+#include "dxgi1_6.h"
+
+#include "dxvk_interfaces.h"
+#include "atidxx.h"
+
+#include <wingdi.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(atidxx);
+
+static HMODULE d3d11_module;
+static HRESULT (WINAPI *pD3D11CreateDevice)(IDXGIAdapter *adapter, D3D_DRIVER_TYPE driver_type,
+        HMODULE swrast, UINT flags, const D3D_FEATURE_LEVEL *feature_levels, UINT levels,
+        UINT sdk_version, ID3D11Device **device_out, D3D_FEATURE_LEVEL *obtained_feature_level,
+        ID3D11DeviceContext **immediate_context);
+
+typedef void (*vtable_ptr)(void);
+
+static HRESULT load_d3d11(void)
+{
+    if (!d3d11_module)
+        d3d11_module = LoadLibraryA("d3d11.dll");
+
+    if (!d3d11_module)
+    {
+        ERR("Failed to load d3d11.dll\n");
+        return E_FAIL;
+    }
+
+    return S_OK;
+}
+
+
+HRESULT WINAPI AmdD3D11CreateDeviceExt(IDXGIAdapter *adapter, D3D_DRIVER_TYPE driver_type, HMODULE swrast, UINT flags,
+        const D3D_FEATURE_LEVEL *feature_levels, UINT levels, UINT sdk_version, ID3D11Device **device_out,
+        D3D_FEATURE_LEVEL *obtained_feature_level, ID3D11DeviceContext **immediate_context, void *unk)
+{
+    HRESULT ret;
+    FIXME("%p semi-stub\n", unk);
+
+    if ((ret = load_d3d11()))
+        return ret;
+
+    if (!pD3D11CreateDevice)
+        pD3D11CreateDevice = (void*)GetProcAddress(d3d11_module, "D3D11CreateDevice");
+
+    return pD3D11CreateDevice(adapter, driver_type, swrast, flags, feature_levels, levels, sdk_version,
+            device_out, obtained_feature_level, immediate_context);
+}
+
+/*
+    Ext Ifaces to implement:
+    field_0x170 = 0x11
+    field_0x190 = 0x17
+    field_0x188 = 0x15
+    field_0x178 = 0x14
+    field_0x1a0 = 0x1d
+    field_0x168 = 0xb
+    field_0x160 = 0xf
+    field_0x198 = 0x17
+ */
+
+/* field_0x160 (0xf)
+
+    0x0 = AddRef
+    0x8 = Release
+    0x10 = ??
+    0x18 = BeginUAVOverlap
+    0x20 = EndUAVOverlap
+    0x28 = GetVersion (called on init, prob some kind of version getter)
+
+*/
+
+/* field_0x168 (0xb)
+    0x0 = AddRef
+    0x8 = Release
+    0x10 = ??
+    0x18 = SetDepthBounds
+    0x20 = GetVersion
+*/
+
+/* field_0x170 (0x11)
+    0x0 = AddRef
+    0x8 = Release
+    0x10 = ??
+    0x18 = GetVersion
+    0x20 = MultiDrawIndirect
+    0x28 = MultiDrawIndexedIndirect
+    0x30 = MultiDrawIndirectCount
+    0x38 = MultiDrawIndexedIndirectCount
+*/
+
+typedef struct
+{
+    IAmdDxExt IAmdDxExt_iface;
+    IAmdDxExtUAVOverlap IAmdDxExtUAVOverlap_iface;
+    IAmdDxExtQuadBufferStereo IAmdDxExtQuadBufferStereo_iface;
+    IAmdDxExtDepthBounds IAmdDxExtDepthBounds_iface;
+    IAmdDxExtMultidrawIndirect IAmdDxExtMultidrawIndirect_iface;
+    LONG ref;
+    //could also be a d3d10 device, just cast
+    ID3D11Device *device;
+    ID3D11DeviceContext *context;
+    ID3D11VkExtContext *ext_context;
+    BOOL is_d3d11;
+    BOOL uav_overlap;
+    BOOL depth_bounds;
+    BOOL multi_draw_indirect;
+    BOOL multi_draw_indirect_count;
+} AmdDxExt;
+
+static inline AmdDxExt *impl_from_IAmdDxExt(IAmdDxExt *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExt_iface);
+}
+
+static inline AmdDxExt *impl_from_IAmdDxExtUAVOverlap(IAmdDxExtUAVOverlap *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExtUAVOverlap_iface);
+}
+
+static inline AmdDxExt *impl_from_IAmdDxExtQuadBufferStereo(IAmdDxExtQuadBufferStereo *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExtQuadBufferStereo_iface);
+}
+
+static inline AmdDxExt *impl_from_IAmdDxExtDepthBounds(IAmdDxExtDepthBounds *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExtDepthBounds_iface);
+}
+
+static inline AmdDxExt *impl_from_IAmdDxExtMultidrawIndirect(IAmdDxExtMultidrawIndirect *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExtMultidrawIndirect_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_AddRef, 4)
+unsigned int __thiscall AmdDxExt_AddRef(IAmdDxExt *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExt(iface);
+    return InterlockedIncrement(&This->ref);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_Release, 4)
+unsigned int __thiscall AmdDxExt_Release(IAmdDxExt *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExt(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+    if(ref == 0)
+    {
+        if(This->is_d3d11)
+        {
+            ID3D11Device_Release(This->device);
+            ID3D11DeviceContext_Release(This->context);
+            ID3D11VkExtContext_Release(This->ext_context);
+        }
+        free(This);
+    }
+    return ref;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_GetVersion, 8)
+HRESULT __thiscall AmdDxExt_GetVersion(IAmdDxExt *ext, AmdDxExtVersion *version)
+{
+    FIXME("%p %p\n", ext, version);
+
+    version->majorVersion = 1;
+    version->minorVersion = 0;
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_AddRef, 4)
+unsigned int __thiscall AmdDxExtUAVOverlap_AddRef(IAmdDxExtUAVOverlap *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtUAVOverlap(iface);
+    return AmdDxExt_AddRef(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_Release, 4)
+unsigned int __thiscall AmdDxExtUAVOverlap_Release(IAmdDxExtUAVOverlap *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtUAVOverlap(iface);
+    return AmdDxExt_Release(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_GetExtInterface, 8)
+IAmdDxExtInterface* __thiscall AmdDxExt_GetExtInterface(IAmdDxExt *ext, unsigned int iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExt(ext);
+    IAmdDxExtInterface *ret = NULL;
+    TRACE("%p %x\n", ext, iface);
+
+    switch(iface)
+    {
+        case 0x2:
+            ret = (IAmdDxExtInterface *)&This->IAmdDxExtQuadBufferStereo_iface;
+            break;
+        case 0xb:
+            ret = (IAmdDxExtInterface *)&This->IAmdDxExtDepthBounds_iface;
+            break;
+        case 0xf:
+            ret = (IAmdDxExtInterface *)&This->IAmdDxExtUAVOverlap_iface;
+            break;
+        case 0x11:
+            ret = (IAmdDxExtInterface *)&This->IAmdDxExtMultidrawIndirect_iface;
+            break;
+        default:
+        {
+            FIXME("Unknown interface %x\n", iface);
+            break;
+        }
+    }
+
+    if (ret)
+    {
+        AmdDxExt_AddRef(ext);
+    }
+
+    return ret;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_IaSetPrimitiveTopology, 8)
+HRESULT __thiscall AmdDxExt_IaSetPrimitiveTopology(IAmdDxExt *ext, D3D_PRIMITIVE_TOPOLOGY topology)
+{
+    AmdDxExt *This = impl_from_IAmdDxExt(ext);
+    TRACE("%p %u\n", ext, topology);
+
+    if(This->is_d3d11)
+    {
+        ID3D11DeviceContext_IASetPrimitiveTopology(This->context, topology);
+    }
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_IaGetPrimitiveTopology, 8)
+HRESULT __thiscall AmdDxExt_IaGetPrimitiveTopology(IAmdDxExt *ext, AmdDxExtPrimitiveTopology *topology)
+{
+    FIXME("%p %p stub\n", ext, topology);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_SetSingleSampleRead, 12)
+HRESULT __thiscall AmdDxExt_SetSingleSampleRead(IAmdDxExt *iface, ID3D10Resource *res, BOOL single_sample)
+{
+    FIXME("%p %p %u stub\n", iface, res, single_sample);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_SetSingleSampleRead11, 12)
+HRESULT __thiscall AmdDxExt_SetSingleSampleRead11(IAmdDxExt *iface, ID3D11Resource *res, BOOL single_sample)
+{
+    FIXME("%p %p %u stub\n", iface, res, single_sample);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_QueryFeatureSupport, 16)
+HRESULT __thiscall AmdDxExt_QueryFeatureSupport(IAmdDxExt *iface, unsigned int feature_token, void *data, unsigned int data_size)
+{
+    FIXME("%p %u %p %u stub\n", iface, feature_token, data, data_size);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_IaSetPrimitiveTopologyCtx, 12)
+HRESULT __thiscall AmdDxExt_IaSetPrimitiveTopologyCtx(IAmdDxExt *iface, unsigned int topology, ID3D11DeviceContext *ctx)
+{
+    FIXME("%p %u %p stub\n", iface, topology, ctx);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_IaGetPrimitiveTopologyCtx, 12)
+HRESULT __thiscall AmdDxExt_IaGetPrimitiveTopologyCtx(IAmdDxExt *iface, AmdDxExtPrimitiveTopology *topology, ID3D11DeviceContext *ctx)
+{
+    FIXME("%p %p %p stub\n", iface, topology, ctx);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_Unk1, 4)
+void __thiscall AmdDxExtUAVOverlap_Unk1(IAmdDxExtUAVOverlap *iface)
+{
+    FIXME("%p stub\n", iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_BeginUAVOverlap, 4)
+HRESULT __thiscall AmdDxExtUAVOverlap_BeginUAVOverlap(IAmdDxExtUAVOverlap *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtUAVOverlap(iface);
+    TRACE("%p\n", iface);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->uav_overlap) return E_FAIL;
+
+    ID3D11VkExtContext_SetBarrierControl(This->ext_context, D3D11_VK_BARRIER_CONTROL_IGNORE_WRITE_AFTER_WRITE);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_EndUAVOverlap, 4)
+HRESULT __thiscall AmdDxExtUAVOverlap_EndUAVOverlap(IAmdDxExtUAVOverlap *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtUAVOverlap(iface);
+    TRACE("%p\n", iface);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->uav_overlap) return E_FAIL;
+
+    ID3D11VkExtContext_SetBarrierControl(This->ext_context, 0);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_GetVersion, 8)
+void __thiscall AmdDxExtUAVOverlap_GetVersion(IAmdDxExtUAVOverlap *iface, AmdDxExtVersion* version)
+{
+    FIXME("%p %p stub!\n", iface, version);
+    version->majorVersion = 1;
+    version->minorVersion = 0;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_AddRef, 4)
+unsigned int __thiscall AmdDxExtQuadBufferStereo_AddRef(IAmdDxExtQuadBufferStereo *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtQuadBufferStereo(iface);
+    return AmdDxExt_AddRef(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_Release, 4)
+unsigned int __thiscall AmdDxExtQuadBufferStereo_Release(IAmdDxExtQuadBufferStereo *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtQuadBufferStereo(iface);
+    return AmdDxExt_Release(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_EnableQuadBufferStereo, 8)
+HRESULT __thiscall AmdDxExtQuadBufferStereo_EnableQuadBufferStereo(IAmdDxExtQuadBufferStereo *iface, BOOL enable)
+{
+    FIXME("%p %u stub\n", iface, enable);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_GetDisplayModeList, 20)
+HRESULT __thiscall AmdDxExtQuadBufferStereo_GetDisplayModeList(IAmdDxExtQuadBufferStereo *iface, DXGI_FORMAT format, UINT flags, UINT *num_modes, DXGI_MODE_DESC *desc)
+{
+    FIXME("%p %u %u %p %p stub\n", iface, format, flags, num_modes, desc);
+
+    if (!num_modes) return E_INVALIDARG;
+
+    *num_modes = 0;
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_GetLineOffset, 8)
+UINT __thiscall AmdDxExtQuadBufferStereo_GetLineOffset(IAmdDxExtQuadBufferStereo *iface, IDXGISwapChain *swapchain)
+{
+    FIXME("%p %p stub\n", iface, swapchain);
+
+    return 0;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_AddRef, 4)
+unsigned int __thiscall AmdDxExtDepthBounds_AddRef(IAmdDxExtDepthBounds *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtDepthBounds(iface);
+    return AmdDxExt_AddRef(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_Release, 4)
+unsigned int __thiscall AmdDxExtDepthBounds_Release(IAmdDxExtDepthBounds *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtDepthBounds(iface);
+    return AmdDxExt_Release(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_GetVersion, 8)
+void __thiscall AmdDxExtDepthBounds_GetVersion(IAmdDxExtDepthBounds *iface, AmdDxExtVersion* version)
+{
+    FIXME("%p %p stub!\n", iface, version);
+    version->majorVersion = 1;
+    version->minorVersion = 0;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_SetDepthBounds, 16)
+HRESULT __thiscall AmdDxExtDepthBounds_SetDepthBounds(IAmdDxExtDepthBounds *iface, BOOL enabled, float min, float max)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtDepthBounds(iface);
+
+    TRACE("%p %u %f %f\n", iface, enabled, min, max);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->depth_bounds) return E_FAIL;
+
+    ID3D11VkExtContext_SetDepthBoundsTest(This->ext_context, enabled, min, max);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_Unk1, 4)
+void __thiscall AmdDxExtDepthBounds_Unk1(IAmdDxExtDepthBounds *iface)
+{
+    FIXME("%p stub\n", iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_AddRef, 4)
+unsigned int __thiscall AmdDxExtMultidrawIndirect_AddRef(IAmdDxExtMultidrawIndirect *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    return AmdDxExt_AddRef(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_Release, 4)
+unsigned int __thiscall AmdDxExtMultidrawIndirect_Release(IAmdDxExtMultidrawIndirect *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    return AmdDxExt_Release(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_Unk1, 4)
+void __thiscall AmdDxExtMultidrawIndirect_Unk1(IAmdDxExtMultidrawIndirect *iface)
+{
+    FIXME("%p stub\n", iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_GetVersion, 8)
+void __thiscall AmdDxExtMultidrawIndirect_GetVersion(IAmdDxExtMultidrawIndirect *iface, AmdDxExtVersion* version)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    FIXME("%p %p semi-stub!\n", iface, version);
+    version->majorVersion = 1;
+    /* needed for indirect count */
+    version->minorVersion = This->multi_draw_indirect_count ? 2 : 0;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_MultiDrawIndirect, 20)
+HRESULT __thiscall AmdDxExtMultidrawIndirect_MultiDrawIndirect(IAmdDxExtMultidrawIndirect *iface, unsigned int draw_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    TRACE("%p %u %p %u %u\n", iface, draw_count, buffer, byte_offset, byte_stride);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->multi_draw_indirect) return E_FAIL;
+
+    ID3D11VkExtContext_MultiDrawIndirect(This->ext_context, draw_count, buffer, byte_offset, byte_stride);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_MultiDrawIndexedIndirect, 20)
+HRESULT __thiscall AmdDxExtMultidrawIndirect_MultiDrawIndexedIndirect(IAmdDxExtMultidrawIndirect *iface, unsigned int draw_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    TRACE("%p %u %p %u %u\n", iface, draw_count, buffer, byte_offset, byte_stride);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->multi_draw_indirect) return E_FAIL;
+
+    ID3D11VkExtContext_MultiDrawIndexedIndirect(This->ext_context, draw_count, buffer, byte_offset, byte_stride);
+
+    return S_OK;
+}
+
+static unsigned int get_max_draw_count(ID3D11Buffer *buffer, unsigned int offset, unsigned int stride, unsigned int size)
+{
+    D3D11_BUFFER_DESC desc;
+    unsigned int count;
+
+    ID3D11Buffer_GetDesc(buffer, &desc);
+
+    if(offset >= desc.ByteWidth)
+    {
+        WARN("Offset %u, buffer size %u.", offset, desc.ByteWidth);
+        return 0;
+    }
+
+    count = (desc.ByteWidth - offset) / stride;
+    if (desc.ByteWidth - offset - count * stride >= size)
+        ++count;
+
+    if (!count)
+        WARN("zero count, buffer size %u, offset %u, stride %u, size %u.\n", desc.ByteWidth, offset, stride, size);
+
+    return count;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxextMultiDrawIndirect_MultiDrawIndirectCount, 24)
+HRESULT __thiscall AmdDxextMultiDrawIndirect_MultiDrawIndirectCount(IAmdDxExtMultidrawIndirect *iface, ID3D11Buffer *buffer_for_count, unsigned int byte_offset_for_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    unsigned int max_draw_count;
+    TRACE("%p %p %u %p %u %u\n", iface, buffer_for_count, byte_offset_for_count, buffer, byte_offset, byte_stride);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->multi_draw_indirect_count) return E_FAIL;
+
+    max_draw_count = get_max_draw_count(buffer, byte_offset, byte_stride, sizeof(D3D11_DRAW_INDEXED_INSTANCED_INDIRECT_ARGS));
+
+    ID3D11VkExtContext_MultiDrawIndirectCount(This->ext_context, max_draw_count, buffer_for_count, byte_offset_for_count, buffer, byte_offset, byte_stride);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxextMultiDrawIndirect_MultiDrawIndexedIndirectCount, 24)
+HRESULT __thiscall AmdDxextMultiDrawIndirect_MultiDrawIndexedIndirectCount(IAmdDxExtMultidrawIndirect *iface, ID3D11Buffer *buffer_for_count, unsigned int byte_offset_for_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    unsigned int max_draw_count;
+    TRACE("%p %p %u %p %u %u\n", iface, buffer_for_count, byte_offset_for_count, buffer, byte_offset, byte_stride);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->multi_draw_indirect_count) return E_FAIL;
+
+    max_draw_count = get_max_draw_count(buffer, byte_offset, byte_stride, sizeof(D3D11_DRAW_INDEXED_INSTANCED_INDIRECT_ARGS));
+
+    ID3D11VkExtContext_MultiDrawIndexedIndirectCount(This->ext_context, max_draw_count, buffer_for_count, byte_offset_for_count, buffer, byte_offset, byte_stride);
+
+    return S_OK;
+}
+
+static const IAmdDxExtUAVOverlapVtbl amddxext_uav_vtable =
+{
+    THISCALL(AmdDxExtUAVOverlap_AddRef),
+    THISCALL(AmdDxExtUAVOverlap_Release),
+    THISCALL(AmdDxExtUAVOverlap_Unk1),
+    THISCALL(AmdDxExtUAVOverlap_BeginUAVOverlap),
+    THISCALL(AmdDxExtUAVOverlap_EndUAVOverlap),
+    THISCALL(AmdDxExtUAVOverlap_GetVersion)
+};
+
+static const IAmdDxExtVtbl AmdDxExt_vtable =
+{
+    THISCALL(AmdDxExt_AddRef), //0
+    THISCALL(AmdDxExt_Release), //0x8
+    THISCALL(AmdDxExt_IaGetPrimitiveTopology), // 0x10 ??
+    THISCALL(AmdDxExt_GetVersion), //0x18
+    THISCALL(AmdDxExt_GetExtInterface), //0x20
+    THISCALL(AmdDxExt_IaSetPrimitiveTopology), //0x28
+    THISCALL(AmdDxExt_SetSingleSampleRead), //0x30 ??
+    THISCALL(AmdDxExt_SetSingleSampleRead11), //0x38 ??
+    THISCALL(AmdDxExt_IaSetPrimitiveTopologyCtx), //0x40 ??
+    THISCALL(AmdDxExt_QueryFeatureSupport), //0x48
+    THISCALL(AmdDxExt_IaGetPrimitiveTopologyCtx) //0x50 ??
+};
+
+static const IAmdDxExtQuadBufferStereoVtbl quadbufstereo_vtable =
+{
+    THISCALL(AmdDxExtQuadBufferStereo_AddRef),
+    THISCALL(AmdDxExtQuadBufferStereo_Release),
+    THISCALL(AmdDxExtQuadBufferStereo_EnableQuadBufferStereo),
+    THISCALL(AmdDxExtQuadBufferStereo_GetLineOffset),
+    THISCALL(AmdDxExtQuadBufferStereo_GetDisplayModeList),
+};
+
+static const IAmdDxExtDepthBoundsVtbl amddxext_depth_vtable =
+{
+    THISCALL(AmdDxExtDepthBounds_AddRef),
+    THISCALL(AmdDxExtDepthBounds_Release),
+    THISCALL(AmdDxExtDepthBounds_Unk1),
+    THISCALL(AmdDxExtDepthBounds_SetDepthBounds),
+    THISCALL(AmdDxExtDepthBounds_GetVersion)
+};
+
+static const IAmdDxExtMultidrawIndirectVtbl amddxext_multidraw_vtable =
+{
+    THISCALL(AmdDxExtMultidrawIndirect_AddRef),
+    THISCALL(AmdDxExtMultidrawIndirect_Release),
+    THISCALL(AmdDxExtMultidrawIndirect_Unk1),
+    THISCALL(AmdDxExtMultidrawIndirect_GetVersion),
+    THISCALL(AmdDxExtMultidrawIndirect_MultiDrawIndirect),
+    THISCALL(AmdDxExtMultidrawIndirect_MultiDrawIndexedIndirect),
+    THISCALL(AmdDxextMultiDrawIndirect_MultiDrawIndirectCount),
+    THISCALL(AmdDxextMultiDrawIndirect_MultiDrawIndexedIndirectCount)
+};
+
+HRESULT CDECL AmdDxExtCreate11(ID3D11Device *device, IAmdDxExt **ext)
+{
+    HRESULT ret;
+    AmdDxExt *obj;
+    ID3D11VkExtDevice *ext_device;
+    TRACE("%p %p\n", device, ext);
+
+    if((ret = load_d3d11()) != S_OK)
+        return ret;
+
+    obj = malloc(sizeof(AmdDxExt));
+    if(!obj)
+        return E_OUTOFMEMORY;
+
+    obj->device = device;
+    ID3D11Device_AddRef(device);
+    ID3D11Device_GetImmediateContext(device, &obj->context);
+
+    if(FAILED(ret = ID3D11DeviceContext_QueryInterface(obj->context, &IID_ID3D11VkExtContext, (void**)&obj->ext_context)))
+    {
+        ERR("Failed to get ID3D11VkExtContext\n");
+        return ret;
+    }
+
+    if(FAILED(ret = ID3D11Device_QueryInterface(device, &IID_ID3D11VkExtDevice, (void**)&ext_device)))
+    {
+        ERR("Failed to get ID3D11VkExtDevice\n");
+        return ret;
+    }
+
+    obj->IAmdDxExt_iface.lpVtbl = &AmdDxExt_vtable;
+    obj->IAmdDxExtUAVOverlap_iface.lpVtbl = &amddxext_uav_vtable;
+    obj->IAmdDxExtQuadBufferStereo_iface.lpVtbl = &quadbufstereo_vtable;
+    obj->IAmdDxExtDepthBounds_iface.lpVtbl = &amddxext_depth_vtable;
+    obj->IAmdDxExtMultidrawIndirect_iface.lpVtbl = &amddxext_multidraw_vtable;
+    obj->is_d3d11 = TRUE;
+    obj->ref = 1;
+
+    obj->depth_bounds = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_DEPTH_BOUNDS);
+    obj->uav_overlap = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_BARRIER_CONTROL);
+    obj->multi_draw_indirect = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_MULTI_DRAW_INDIRECT);
+    obj->multi_draw_indirect_count = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_MULTI_DRAW_INDIRECT_COUNT);
+
+    TRACE("Supported extensions:\n DepthBounds: %d, UAVOverlap: %d, MultiDrawIndirect: %d, MultiDrawIndirectCount: %d\n",
+            obj->depth_bounds, obj->uav_overlap, obj->multi_draw_indirect, obj->multi_draw_indirect_count);
+
+    *ext = &obj->IAmdDxExt_iface;
+
+    ID3D11VkExtDevice_Release(ext_device);
+
+    return S_OK;
+}
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 9d2a74e7bb1..f81ad3514ea 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -2990,6 +2990,7 @@ HKCU,Software\Wine\DllOverrides,"vcomp140",0x2,"native,builtin"
 HKCU,Software\Wine\DllOverrides,"vcruntime140",0x2,"native,builtin"
 HKCU,Software\Wine\DllOverrides,"vccorlib140",0x2,"native,builtin"
 HKCU,Software\Wine\DllOverrides,"atiadlxx",,"disabled"
+HKCU,Software\Wine\DllOverrides,"atidxx64",,"disabled"
 HKCU,Software\Wine\DllOverrides,"nvcuda",0x2,"disabled"
 HKCU,Software\Wine\DllOverrides,"vcruntime140_1",0x2,"native,builtin"
 HKCU,Software\Wine\AppDefaults\ShadowOfWar.exe\DllOverrides,"amd_ags_x64",,"disabled"
-- 
2.51.0

