From 13ae0d218b81fd276f135decf1ebf6871b5be1fc Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Tue, 18 Feb 2025 21:01:19 +0100
Subject: [PATCH 01/81] [dxvk] Add config variables for frame pacing

---
 dxvk.conf                 | 52 ++++++++++++++++++++++++++++++++++++++-
 src/dxvk/dxvk_options.cpp |  6 ++++-
 src/dxvk/dxvk_options.h   | 16 +++++++++++-
 3 files changed, 71 insertions(+), 3 deletions(-)

diff --git a/dxvk.conf b/dxvk.conf
index 799991eee3b..0b8deba8cb8 100644
--- a/dxvk.conf
+++ b/dxvk.conf
@@ -18,6 +18,51 @@
 # dxgi.enableHDR = True
 
 
+# Frame pacing mode managing CPU-GPU synchronization.
+# Defaults to "low-latency" in the draft-PR for demonstration purposes.
+#
+# "max-frame-latency" provides stable latency in the GPU-limit as long as
+# GPU render times are stable. Latency generally is higher but offers great
+# visual smoothness.
+#
+# "low-latency" provides lower latency in the GPU-limit and can be fine-tuned
+# via dxvk.lowLatencyOffset and dxvk.lowLatencyAllowCpuFramesOverlap.
+#
+# "min-latency" possibly provides the lowest latency (low-latency can be
+# quicker in some situations), and offers less fps in the GPU-limit
+# due to stalling the GPU between frames. Generally not recommended,
+# but helpful to get insights to fine-tune the low-latency mode and
+# possibly is useful for running games in the CPU-limit.
+#
+# "low/min-latency" also supports its own fps-limiting enabled via common
+# variables.
+#
+# Supported values: "max-frame-latency", "low-latency", "min-latency"
+
+# dxvk.framePacing = ""
+
+
+# Allows fine-tuning the low-latency frame pacing mode.
+# Positive values make a frame begin later which might improve responsiveness,
+# although only very slightly, but may be relevant for edge cases.
+# Negative values make a frame begin earlier which might improve fps.
+# Values are given in microseconds. Defaults to 0.
+#
+# Supported values: -10000 to 10000
+
+# dxvk.lowLatencyOffset = 0
+
+
+# Determines whether a frame is allowed to begin before finishing processing
+# the cpu-part of the previous one, when low-latency frame pacing is used.
+# Snappiness may be improved when disallowing overlap. On the other hand, this
+# might also decrease fps in certain cases. Defaults to True.
+#
+# Supported values: True, False
+
+# dxvk.lowLatencyAllowCpuFramesOverlap = True
+
+
 # Expose support for dcomp swap chains with a dummy window.
 #
 # This is not a valid implementation of DirectComposition swapchains,
@@ -104,8 +149,13 @@
 #         The implementation will either use VK_NV_low_latency2 if supported
 #         by the driver, or a custom algorithm.
 # - False: Disable Reflex support as well as built-in latency reduction.
+#         This build defaults to False to enable dxvk.framePacing. You need to
+#         enable Reflex manually (Auto) until we support switching back and
+#         forth between Reflex and the low-latency frame pacing - for example
+#         via the ingame options - and more critically we want to enable
+#         low-latency frame pacing if the game doesn't support Reflex.
   
-# dxvk.latencySleep = Auto
+# dxvk.latencySleep = False
 
 
 # Tolerance for the latency sleep heuristic, in microseconds. Higher values
diff --git a/src/dxvk/dxvk_options.cpp b/src/dxvk/dxvk_options.cpp
index d2d455c337f..85fc3ec3e4c 100644
--- a/src/dxvk/dxvk_options.cpp
+++ b/src/dxvk/dxvk_options.cpp
@@ -12,12 +12,16 @@ namespace dxvk {
     useRawSsbo            = config.getOption<Tristate>("dxvk.useRawSsbo",             Tristate::Auto);
     hud                   = config.getOption<std::string>("dxvk.hud", "");
     tearFree              = config.getOption<Tristate>("dxvk.tearFree",               Tristate::Auto);
-    latencySleep          = config.getOption<Tristate>("dxvk.latencySleep",           Tristate::Auto);
+    latencySleep          = config.getOption<Tristate>("dxvk.latencySleep",           Tristate::False);
     latencyTolerance      = config.getOption<int32_t> ("dxvk.latencyTolerance",       1000);
     disableNvLowLatency2  = config.getOption<Tristate>("dxvk.disableNvLowLatency2",   Tristate::Auto);
     hideIntegratedGraphics = config.getOption<bool>   ("dxvk.hideIntegratedGraphics", false);
     zeroMappedMemory      = config.getOption<bool>    ("dxvk.zeroMappedMemory",       false);
     allowFse              = config.getOption<bool>    ("dxvk.allowFse",               false);
+    framePace             = config.getOption<std::string>("dxvk.framePace",           "");
+    lowLatencyOffset      = config.getOption<int32_t> ("dxvk.lowLatencyOffset",       0);
+    lowLatencyAllowCpuFramesOverlap
+                          = config.getOption<bool>    ("dxvk.lowLatencyAllowCpuFramesOverlap", true);
     deviceFilter          = config.getOption<std::string>("dxvk.deviceFilter",        "");
     tilerMode             = config.getOption<Tristate>("dxvk.tilerMode",              Tristate::Auto);
   }
diff --git a/src/dxvk/dxvk_options.h b/src/dxvk/dxvk_options.h
index 5351ac68b49..fd297714358 100644
--- a/src/dxvk/dxvk_options.h
+++ b/src/dxvk/dxvk_options.h
@@ -38,7 +38,9 @@ namespace dxvk {
     Tristate tearFree = Tristate::Auto;
 
     /// Enables latency sleep
-    Tristate latencySleep = Tristate::Auto;
+    /// Defaults to false in this build to activate the FramePacer,
+    /// especially for the case when the game doesn't support Reflex
+    Tristate latencySleep = Tristate::False;
 
     /// Latency tolerance, in microseconds
     int32_t latencyTolerance = 0u;
@@ -61,6 +63,18 @@ namespace dxvk {
     /// Whether to enable tiler optimizations
     Tristate tilerMode = Tristate::Auto;
 
+    /// Frame pacing
+    std::string framePace;
+
+    /// A value in microseconds to fine-tune the low-latency frame pacing.
+    /// Positive values make a frame begin later which might improve responsiveness.
+    /// Negative values make a frame begin earlier which might improve fps.
+    int32_t lowLatencyOffset;
+
+    /// Determines whether a frame is allowed to begin before finishing processing
+    /// the cpu-part of the previous one, when low-latency frame pacing is used.
+    bool lowLatencyAllowCpuFramesOverlap;
+
     // Device name
     std::string deviceFilter;
   };

From 01ccd1e7763bbf9a2ccedc479bfe236abafa3a23 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Tue, 18 Feb 2025 21:18:22 +0100
Subject: [PATCH 02/81] [dxvk] Add low-latency frame pacing

---
 src/dxvk/dxvk_latency.h                       |   7 +
 src/dxvk/framepacer/dxvk_framepacer.cpp       |  64 +++++
 src/dxvk/framepacer/dxvk_framepacer.h         | 191 +++++++++++++
 src/dxvk/framepacer/dxvk_framepacer_mode.h    | 117 ++++++++
 .../dxvk_framepacer_mode_low_latency.cpp      |  43 +++
 .../dxvk_framepacer_mode_low_latency.h        | 255 ++++++++++++++++++
 .../dxvk_framepacer_mode_min_latency.h        |  45 ++++
 src/dxvk/framepacer/dxvk_latency_markers.h    | 148 ++++++++++
 src/dxvk/meson.build                          |   3 +
 9 files changed, 873 insertions(+)
 create mode 100644 src/dxvk/framepacer/dxvk_framepacer.cpp
 create mode 100644 src/dxvk/framepacer/dxvk_framepacer.h
 create mode 100644 src/dxvk/framepacer/dxvk_framepacer_mode.h
 create mode 100644 src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
 create mode 100644 src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
 create mode 100644 src/dxvk/framepacer/dxvk_framepacer_mode_min_latency.h
 create mode 100644 src/dxvk/framepacer/dxvk_latency_markers.h

diff --git a/src/dxvk/dxvk_latency.h b/src/dxvk/dxvk_latency.h
index c9ac93c5d33..f4e74a7cecd 100644
--- a/src/dxvk/dxvk_latency.h
+++ b/src/dxvk/dxvk_latency.h
@@ -128,6 +128,10 @@ namespace dxvk {
     virtual void notifyCpuPresentEnd(
             uint64_t                  frameId) = 0;
 
+    virtual void notifySubmit() { }
+    virtual void notifyPresent(
+            uint64_t                  frameId) { }
+
     /**
      * \brief Called when a command list is submitted to the GPU
      *
@@ -174,6 +178,9 @@ namespace dxvk {
     virtual void notifyGpuExecutionEnd(
             uint64_t                  frameId) = 0;
 
+    virtual void notifyGpuPresentBegin(
+            uint64_t                  frameId) { }
+
     /**
      * \brief Called when presentation of a given frame finishes on the GPU
      *
diff --git a/src/dxvk/framepacer/dxvk_framepacer.cpp b/src/dxvk/framepacer/dxvk_framepacer.cpp
new file mode 100644
index 00000000000..63803f1bac0
--- /dev/null
+++ b/src/dxvk/framepacer/dxvk_framepacer.cpp
@@ -0,0 +1,64 @@
+#include "dxvk_framepacer.h"
+#include "dxvk_framepacer_mode_low_latency.h"
+#include "dxvk_framepacer_mode_min_latency.h"
+#include "dxvk_options.h"
+#include "../../util/util_env.h"
+#include "../../util/log/log.h"
+
+namespace dxvk {
+
+
+  FramePacer::FramePacer( const DxvkOptions& options ) {
+    // we'll default to LOW_LATENCY in the draft-PR for now, for demonstration purposes,
+    // highlighting the generally much better input lag and medium-term time consistency.
+    // although MAX_FRAME_LATENCY has advantages in many games and is likely the better default,
+    // for its higher fps throughput and less susceptibility to short-term time inconsistencies.
+    // which mode being smoother depends on the game.
+    FramePacerMode::Mode mode = FramePacerMode::LOW_LATENCY;
+
+    std::string configStr = env::getEnvVar("DXVK_FRAME_PACE");
+
+    if (configStr.find("max-frame-latency") != std::string::npos) {
+      mode = FramePacerMode::MAX_FRAME_LATENCY;
+    } else if (configStr.find("low-latency") != std::string::npos) {
+      mode = FramePacerMode::LOW_LATENCY;
+    } else if (configStr.find("min-latency") != std::string::npos) {
+      mode = FramePacerMode::MIN_LATENCY;
+    } else if (options.framePace.find("max-frame-latency") != std::string::npos) {
+      mode = FramePacerMode::MAX_FRAME_LATENCY;
+    } else if (options.framePace.find("low-latency") != std::string::npos) {
+      mode = FramePacerMode::LOW_LATENCY;
+    } else if (options.framePace.find("min-latency") != std::string::npos) {
+      mode = FramePacerMode::MIN_LATENCY;
+    }
+
+    switch (mode) {
+      case FramePacerMode::MAX_FRAME_LATENCY:
+        Logger::info( "Frame pace: max-frame-latency" );
+        m_mode = std::make_unique<FramePacerMode>(FramePacerMode::MAX_FRAME_LATENCY, &m_latencyMarkersStorage);
+        break;
+
+      case FramePacerMode::LOW_LATENCY:
+        Logger::info( "Frame pace: low-latency" );
+        m_mode = std::make_unique<LowLatencyMode>(mode, &m_latencyMarkersStorage, options);
+        break;
+
+      case FramePacerMode::MIN_LATENCY:
+        Logger::info( "Frame pace: min-latency" );
+        m_mode = std::make_unique<MinLatencyMode>(mode, &m_latencyMarkersStorage);
+        break;
+    }
+
+    for (auto& gpuStart: m_gpuStarts) {
+      gpuStart.store(0);
+    }
+
+    // be consistent that every frame has a gpuReady event from the previous frame
+    LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(DXGI_MAX_SWAP_CHAIN_BUFFERS+1);
+    m->gpuReady.push_back(high_resolution_clock::now());
+  }
+
+
+  FramePacer::~FramePacer() {}
+
+}
diff --git a/src/dxvk/framepacer/dxvk_framepacer.h b/src/dxvk/framepacer/dxvk_framepacer.h
new file mode 100644
index 00000000000..264dcff5755
--- /dev/null
+++ b/src/dxvk/framepacer/dxvk_framepacer.h
@@ -0,0 +1,191 @@
+#pragma once
+
+#include "dxvk_framepacer_mode.h"
+#include "dxvk_latency_markers.h"
+#include "../dxvk_latency.h"
+#include "../../util/util_time.h"
+#include <dxgi.h>
+
+
+namespace dxvk {
+
+  struct DxvkOptions;
+
+  /* \brief Frame pacer interface managing the CPU - GPU synchronization.
+   *
+   * GPUs render frames asynchronously to the game's and dxvk's CPU-side work
+   * in order to improve fps-throughput. Aligning the cpu work to chosen time-
+   * points allows to tune certain characteristics of the video presentation,
+   * like smoothness and latency.
+   */
+
+  class FramePacer : public DxvkLatencyTracker {
+    using microseconds = std::chrono::microseconds;
+  public:
+
+    FramePacer( const DxvkOptions& options );
+    ~FramePacer();
+
+    void sleepAndBeginFrame(
+            uint64_t                  frameId,
+            double                    maxFrameRate) override {
+      // wait for finished rendering of a previous frame, typically the one before last
+      m_mode->waitRenderFinished(frameId);
+      // potentially wait some more if the cpu gets too much ahead
+      m_mode->startFrame(frameId);
+      m_latencyMarkersStorage.registerFrameStart(frameId);
+      m_gpuStarts[ frameId % m_gpuStarts.size() ].store(0);
+    }
+
+    void notifyGpuPresentEnd( uint64_t frameId ) override {
+      // the frame has been displayed to the screen
+      m_latencyMarkersStorage.registerFrameEnd(frameId);
+      m_mode->endFrame(frameId);
+    }
+
+    void notifyCsRenderBegin( uint64_t frameId ) override {
+      auto now = high_resolution_clock::now();
+      LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
+      m->csStart = std::chrono::duration_cast<microseconds>(now - m->start).count();
+    }
+
+    void notifyCsRenderEnd( uint64_t frameId ) override {
+      auto now = high_resolution_clock::now();
+      LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
+      m->csFinished = std::chrono::duration_cast<microseconds>(now - m->start).count();
+      m_mode->signalCsFinished( frameId );
+    }
+
+    void notifySubmit() override {
+      LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(m_lastSubmitFrameId+1);
+      m->gpuSubmit.push_back(high_resolution_clock::now());
+    }
+
+    void notifyPresent( uint64_t frameId ) override {
+      // dx to vk translation is finished
+      if (frameId != 0) {
+        auto now = high_resolution_clock::now();
+        m_lastSubmitFrameId = frameId;
+        LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
+        LatencyMarkers* next = m_latencyMarkersStorage.getMarkers(frameId+1);
+        m->gpuSubmit.push_back(now);
+        m->cpuFinished = std::chrono::duration_cast<microseconds>(now - m->start).count();
+        next->gpuSubmit.clear();
+
+        m_latencyMarkersStorage.m_timeline.cpuFinished.store(frameId);
+      }
+    }
+
+    void notifyQueueSubmit( uint64_t frameId ) override {
+      assert( frameId == m_lastQueueSubmitFrameId + 1 );
+      auto now = high_resolution_clock::now();
+      LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
+      m->gpuQueueSubmit.push_back(now);
+      queueSubmitCheckGpuStart(frameId, m, now);
+    }
+
+    void notifyQueuePresentBegin( uint64_t frameId ) override {
+      if (frameId != 0) {
+        auto now = high_resolution_clock::now();
+        m_lastQueueSubmitFrameId = frameId;
+        LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
+        LatencyMarkers* next = m_latencyMarkersStorage.getMarkers(frameId+1);
+        m->gpuQueueSubmit.push_back(now);
+        next->gpuQueueSubmit.clear();
+        queueSubmitCheckGpuStart(frameId, m, now);
+      }
+    }
+
+    void notifyGpuExecutionBegin( uint64_t frameId ) override {
+      assert( frameId == m_lastFinishedFrameId+1 );
+      LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(m_lastFinishedFrameId+1);
+      gpuExecutionCheckGpuStart(frameId, m, high_resolution_clock::now());
+    }
+
+    void notifyGpuExecutionEnd( uint64_t frameId ) override {
+      auto now = high_resolution_clock::now();
+      LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(m_lastFinishedFrameId+1);
+      m->gpuReady.push_back(now);
+    }
+
+    virtual void notifyGpuPresentBegin( uint64_t frameId ) override {
+      // we get frameId == 0 for repeated presents (SyncInterval)
+      if (frameId != 0) {
+        m_lastFinishedFrameId = frameId;
+        auto now = high_resolution_clock::now();
+
+        LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
+        LatencyMarkers* next = m_latencyMarkersStorage.getMarkers(frameId+1);
+        m->gpuReady.push_back(now);
+        m->gpuFinished = std::chrono::duration_cast<microseconds>(now - m->start).count();
+        next->gpuReady.clear();
+        next->gpuReady.push_back(now);
+
+        gpuExecutionCheckGpuStart(frameId, m, now);
+
+        m_latencyMarkersStorage.m_timeline.gpuFinished.store(frameId);
+        m_mode->finishRender(frameId);
+        m_mode->signalRenderFinished(frameId);
+      }
+    }
+
+    FramePacerMode::Mode getMode() const {
+      return m_mode->m_mode;
+    }
+
+    void setTargetFrameRate( double frameRate ) {
+      m_mode->setTargetFrameRate(frameRate);
+    }
+
+    bool needsAutoMarkers() override {
+      return true;
+    }
+
+    LatencyMarkersStorage m_latencyMarkersStorage;
+
+
+    // not implemented methods
+
+
+    void notifyCpuPresentBegin( uint64_t frameId) override { }
+    void notifyCpuPresentEnd( uint64_t frameId ) override { }
+    void notifyQueuePresentEnd( uint64_t frameId, VkResult status) override { }
+    void discardTimings() override { }
+    DxvkLatencyStats getStatistics( uint64_t frameId ) override
+      { return DxvkLatencyStats(); }
+
+  private:
+
+    void signalGpuStart( uint64_t frameId, LatencyMarkers* m, const high_resolution_clock::time_point& t ) {
+      m->gpuStart = std::chrono::duration_cast<microseconds>(t - m->start).count();
+      m_latencyMarkersStorage.m_timeline.gpuStart.store(frameId);
+      m_mode->signalGpuStart(frameId);
+    }
+
+    void queueSubmitCheckGpuStart( uint64_t frameId, LatencyMarkers* m, const high_resolution_clock::time_point& t ) {
+      auto& gpuStart = m_gpuStarts[ frameId % m_gpuStarts.size() ];
+      uint16_t val = gpuStart.fetch_or(queueSubmitBit);
+      if (val == gpuReadyBit)
+        signalGpuStart( frameId, m, t );
+    }
+
+    void gpuExecutionCheckGpuStart( uint64_t frameId, LatencyMarkers* m, const high_resolution_clock::time_point& t ) {
+      auto& gpuStart = m_gpuStarts[ frameId % m_gpuStarts.size() ];
+      uint16_t val = gpuStart.fetch_or(gpuReadyBit);
+      if (val == queueSubmitBit)
+        signalGpuStart( frameId, m, t );
+    }
+
+    std::unique_ptr<FramePacerMode> m_mode;
+
+    uint64_t m_lastSubmitFrameId      = { DXGI_MAX_SWAP_CHAIN_BUFFERS };
+    uint64_t m_lastQueueSubmitFrameId = { DXGI_MAX_SWAP_CHAIN_BUFFERS };
+    uint64_t m_lastFinishedFrameId    = { DXGI_MAX_SWAP_CHAIN_BUFFERS };
+
+    std::array< std::atomic< uint16_t >, 16 > m_gpuStarts = { };
+    static constexpr uint16_t queueSubmitBit = 1;
+    static constexpr uint16_t gpuReadyBit    = 2;
+
+  };
+
+}
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode.h b/src/dxvk/framepacer/dxvk_framepacer_mode.h
new file mode 100644
index 00000000000..109a240a277
--- /dev/null
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode.h
@@ -0,0 +1,117 @@
+#pragma once
+
+#include "dxvk_latency_markers.h"
+#include "../../util/sync/sync_signal.h"
+#include "../../util/util_env.h"
+#include <dxgi.h>
+
+namespace dxvk {
+
+  /*
+   * /brief Abstract frame pacer mode in order to support different strategies of synchronization.
+   */
+
+  class FramePacerMode {
+
+  public:
+
+    enum Mode {
+      MAX_FRAME_LATENCY = 0,
+      LOW_LATENCY,
+      MIN_LATENCY
+    };
+
+    FramePacerMode( Mode mode, LatencyMarkersStorage* markerStorage, uint32_t maxFrameLatency=1 )
+    : m_mode( mode ),
+      m_waitLatency( maxFrameLatency+1 ),
+      m_latencyMarkersStorage( markerStorage ) {
+      setFpsLimitFrametimeFromEnv();
+    }
+
+    virtual ~FramePacerMode() { }
+
+    virtual void startFrame( uint64_t frameId ) { }
+    virtual void endFrame( uint64_t frameId ) { }
+
+    virtual void finishRender( uint64_t frameId ) { }
+
+    void waitRenderFinished( uint64_t frameId ) {
+      if (m_mode) m_fenceGpuFinished.wait(frameId-m_waitLatency); }
+
+    void signalRenderFinished( uint64_t frameId ) {
+      if (m_mode) m_fenceGpuFinished.signal(frameId); }
+
+    void signalGpuStart( uint64_t frameId ) {
+      if (m_mode) m_fenceGpuStart.signal(frameId); }
+
+    void signalCsFinished( uint64_t frameId ) {
+      if (m_mode) m_fenceCsFinished.signal(frameId); }
+
+    void setTargetFrameRate( double frameRate ) {
+      if (!m_fpsLimitEnvOverride && frameRate > 1.0)
+        m_fpsLimitFrametime.store( 1'000'000/frameRate );
+    }
+
+    const Mode m_mode;
+
+    static bool getDoubleFromEnv( const char* name, double* result );
+    static bool getIntFromEnv( const char* name, int* result );
+
+  protected:
+
+    void setFpsLimitFrametimeFromEnv();
+
+    const uint32_t m_waitLatency;
+    LatencyMarkersStorage* m_latencyMarkersStorage;
+    std::atomic<int32_t> m_fpsLimitFrametime = { 0 };
+    bool m_fpsLimitEnvOverride = { false };
+
+    sync::Fence m_fenceGpuStart    = { sync::Fence(DXGI_MAX_SWAP_CHAIN_BUFFERS) };
+    sync::Fence m_fenceGpuFinished = { sync::Fence(DXGI_MAX_SWAP_CHAIN_BUFFERS) };
+    sync::Fence m_fenceCsFinished  = { sync::Fence(DXGI_MAX_SWAP_CHAIN_BUFFERS+50) };
+
+  };
+
+
+
+  inline bool FramePacerMode::getDoubleFromEnv( const char* name, double* result ) {
+    std::string env = env::getEnvVar(name);
+    if (env.empty())
+      return false;
+
+    try {
+      *result = std::stod(env);
+      return true;
+    } catch (const std::invalid_argument&) {
+      return false;
+    }
+  }
+
+
+  inline bool FramePacerMode::getIntFromEnv( const char* name, int* result ) {
+    std::string env = env::getEnvVar(name);
+    if (env.empty())
+      return false;
+
+    try {
+      *result = std::stoi(env);
+      return true;
+    } catch (const std::invalid_argument&) {
+      return false;
+    }
+  }
+
+
+  inline void FramePacerMode::setFpsLimitFrametimeFromEnv() {
+    double fpsLimit;
+    if (!getDoubleFromEnv("DXVK_FRAME_RATE", &fpsLimit))
+      return;
+
+    m_fpsLimitEnvOverride = true;
+    if (fpsLimit < 1.0)
+      return;
+
+    m_fpsLimitFrametime = 1'000'000/fpsLimit;
+  }
+
+}
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
new file mode 100644
index 00000000000..4e39145b4c3
--- /dev/null
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
@@ -0,0 +1,43 @@
+#include "dxvk_framepacer_mode_low_latency.h"
+
+namespace dxvk {
+
+
+  bool getLowLatencyOffsetFromEnv( int32_t& offset ) {
+    if (!FramePacerMode::getIntFromEnv("DXVK_LOW_LATENCY_OFFSET", &offset))
+      return false;
+    return true;
+  }
+
+
+  bool getLowLatencyAllowCpuFramesOverlapFromEnv( bool& allowOverlap ) {
+    int32_t o;
+    if (!FramePacerMode::getIntFromEnv("DXVK_LOW_LATENCY_ALLOW_CPU_FRAMES_OVERLAP", &o))
+      return false;
+    allowOverlap = (bool) o;
+    return true;
+  }
+
+
+  int32_t LowLatencyMode::getLowLatencyOffset( const DxvkOptions& options ) {
+    int32_t offset = options.lowLatencyOffset;
+    int32_t o;
+    if (getLowLatencyOffsetFromEnv(o))
+      offset = o;
+
+    offset = std::max( -10000, offset );
+    offset = std::min(  10000, offset );
+    return offset;
+  }
+
+
+  bool LowLatencyMode::getLowLatencyAllowCpuFramesOverlap( const DxvkOptions& options ) {
+    bool allowOverlap = options.lowLatencyAllowCpuFramesOverlap;
+    bool o;
+    if (getLowLatencyAllowCpuFramesOverlapFromEnv(o))
+      allowOverlap = o;
+    return allowOverlap;
+  }
+
+
+}
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
new file mode 100644
index 00000000000..06fdaf0dd0e
--- /dev/null
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -0,0 +1,255 @@
+#pragma once
+
+#include "dxvk_framepacer_mode.h"
+#include "../dxvk_options.h"
+#include "../../util/log/log.h"
+#include "../../util/util_string.h"
+#include <assert.h>
+
+namespace dxvk {
+
+  /*
+   * This low-latency mode aims to reduce latency with minimal impact in fps.
+   * Effective when operating in the GPU-limit. Efficient to be used in the CPU-limit as well.
+   *
+   * Greatly reduces input lag variations when switching between CPU- and GPU-limit, and
+   * compared to the max-frame-latency approach, it has a much more stable input lag when
+   * GPU running times change dramatically, which can happen for example when rotating within a scene.
+   *
+   * The current implementation rather generates fluctuations alternating frame-by-frame
+   * depending on the game's and dxvk's CPU-time variations. This might be visible as a loss
+   * in smoothness, which is an area this implementation can be further improved. Unsuitable
+   * smoothing however might degrade input-lag feel, so it's not implemented for now, but
+   * more advanced smoothing techniques will be investigated in the future.
+   * In some situations however, this low-latency pacing actually improves smoothing though,
+   * it will depend on the game.
+   *
+   * An interesting observation while playtesting was that not only the input lag was affected,
+   * but the video generated did progress more cleanly in time as well with regards to
+   * medium-term time consistency, in other words, the video playback speed remained more steady.
+   *
+   * Optimized for VRR and VK_PRESENT_MODE_IMMEDIATE_KHR. It also comes with its own fps-limiter
+   * which is typically used to prevent the game's fps exceeding the monitor's refresh rate,
+   * and which is tightly integrated into the pacing logic.
+   *
+   * Can be fine-tuned via the dxvk.lowLatencyOffset and dxvk.lowLatencyAllowCpuFramesOverlap
+   * variables (or their respective environment variables)
+   * Compared to maxFrameLatency = 3, render-latency reductions of up to 67% are achieved.
+   */
+
+  class LowLatencyMode : public FramePacerMode {
+    using microseconds = std::chrono::microseconds;
+    using time_point = high_resolution_clock::time_point;
+  public:
+
+    LowLatencyMode(Mode mode, LatencyMarkersStorage* storage, const DxvkOptions& options)
+    : FramePacerMode(mode, storage),
+      m_lowLatencyOffset(getLowLatencyOffset(options)),
+      m_allowCpuFramesOverlap(getLowLatencyAllowCpuFramesOverlap(options)) {
+      Logger::info( str::format("Using lowLatencyOffset: ", m_lowLatencyOffset) );
+      Logger::info( str::format("Using lowLatencyAllowCpuFramesOverlap: ", m_allowCpuFramesOverlap) );
+    }
+
+    ~LowLatencyMode() {}
+
+
+    void startFrame( uint64_t frameId ) override {
+      using std::chrono::duration_cast;
+
+      if (!m_allowCpuFramesOverlap)
+        m_fenceCsFinished.wait( frameId-1 );
+
+      m_fenceGpuStart.wait( frameId-1 );
+
+      time_point now = high_resolution_clock::now();
+      uint64_t finishedId = m_latencyMarkersStorage->getTimeline()->gpuFinished.load();
+      if (finishedId <= DXGI_MAX_SWAP_CHAIN_BUFFERS+1ull)
+        return;
+
+      if (finishedId == frameId-1) {
+        // we are the only in-flight frame, nothing to do other then to apply fps-limiter if needed
+        m_lastStart = sleepFor( now, 0 );
+        return;
+      }
+
+      if (finishedId != frameId-2) {
+        Logger::err( str::format("internal error during low-latency frame pacing: expected finished frameId=",
+          frameId-2, ", got: ", finishedId) );
+      }
+
+      const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(frameId-1);
+
+      // estimate the target gpu sync point for this frame
+      // and calculate backwards when we want to start this frame
+
+      const SyncProps props = getSyncPrediction();
+      int32_t gpuReadyPrediction = duration_cast<microseconds>(
+        m->start + microseconds(m->gpuStart+getGpuStartToFinishPrediction()) - now).count();
+
+      int32_t targetGpuSync = gpuReadyPrediction + props.gpuSync;
+      int32_t delay = targetGpuSync - props.cpuUntilGpuSync + m_lowLatencyOffset;
+
+      m_lastStart = sleepFor( now, delay );
+
+    }
+
+
+    void finishRender( uint64_t frameId ) override {
+
+      using std::chrono::duration_cast;
+      const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(frameId);
+
+      int32_t numLoop = (int32_t)(m->gpuReady.size())-1;
+      if (numLoop <= 1) {
+        m_props[frameId % m_props.size()] = SyncProps();
+        m_props[frameId % m_props.size()].isOutlier = true;
+        m_propsFinished.store( frameId );
+        return;
+      }
+
+      // estimates the optimal overlap for cpu/gpu work by optimizing gpu scheduling first
+      // such that the gpu doesn't go into idle for this frame, and then aligning cpu submits
+      // where gpuSubmit[i] <= gpuRun[i] for all i
+
+      std::vector<int32_t>& gpuRun = m_tempGpuRun;
+      std::vector<int32_t>& gpuRunDurations = m_tempGpuRunDurations;
+      gpuRun.clear();
+      gpuRunDurations.clear();
+      int32_t optimizedGpuTime = 0;
+      gpuRun.push_back(optimizedGpuTime);
+
+      for (int i=0; i<numLoop; ++i) {
+        time_point _gpuRun = std::max( m->gpuReady[i], m->gpuQueueSubmit[i] );
+        int32_t duration = duration_cast<microseconds>( m->gpuReady[i+1] - _gpuRun ).count();
+        optimizedGpuTime += duration;
+        gpuRun.push_back(optimizedGpuTime);
+        gpuRunDurations.push_back(duration);
+      }
+
+      int32_t alignment = duration_cast<microseconds>( m->gpuSubmit[numLoop-1] - m->gpuSubmit[0] ).count()
+        - gpuRun[numLoop-1];
+
+      int32_t offset = 0;
+      for (int i=numLoop-2; i>=0; --i) {
+        int32_t curSubmit = duration_cast<microseconds>( m->gpuSubmit[i] - m->gpuSubmit[0] ).count();
+        int32_t diff = curSubmit - gpuRun[i] - alignment;
+        diff = std::max( 0, diff );
+        offset += diff;
+        alignment += diff;
+      }
+
+
+      SyncProps& props = m_props[frameId % m_props.size()];
+      props.gpuSync = gpuRun[numLoop-1];
+      props.cpuUntilGpuSync = offset + duration_cast<microseconds>( m->gpuSubmit[numLoop-1] - m->start ).count();
+      props.optimizedGpuTime = optimizedGpuTime;
+      props.isOutlier = isOutlier(frameId);
+
+      m_propsFinished.store( frameId );
+
+    }
+
+
+    Sleep::TimePoint sleepFor( const Sleep::TimePoint t, int32_t delay ) {
+
+      // account for the fps limit and ensure we won't sleep too long, just in case
+      int32_t frametime = std::chrono::duration_cast<microseconds>( t - m_lastStart ).count();
+      int32_t frametimeDiff = std::max( 0, m_fpsLimitFrametime.load() - frametime );
+      delay = std::max( delay, frametimeDiff );
+      delay = std::max( 0, std::min( delay, 20000 ) );
+
+      Sleep::TimePoint nextStart = t + microseconds(delay);
+      Sleep::sleepUntil( t, nextStart );
+      return nextStart;
+
+    }
+
+
+  private:
+
+    struct SyncProps {
+      int32_t optimizedGpuTime;   // gpu executing packed submits in one go
+      int32_t gpuSync;            // us after gpuStart
+      int32_t cpuUntilGpuSync;
+      bool    isOutlier;
+    };
+
+
+    SyncProps getSyncPrediction() {
+      // in the future we might use more samples to get a prediction
+      // however, simple averaging gives a slightly artificial mouse input
+      // more advanced methods will be investigated
+      SyncProps res = {};
+      uint64_t id = m_propsFinished;
+      if (id < DXGI_MAX_SWAP_CHAIN_BUFFERS+7)
+        return res;
+
+      for (size_t i=0; i<7; ++i) {
+        const SyncProps& props = m_props[ (id-i) % m_props.size() ];
+        if (!props.isOutlier) {
+          id = id-i;
+          break;
+        }
+      }
+
+      return m_props[ id % m_props.size() ];
+    };
+
+
+    int32_t getGpuStartToFinishPrediction() {
+      uint64_t id = m_propsFinished;
+      if (id < DXGI_MAX_SWAP_CHAIN_BUFFERS+7)
+        return 0;
+
+      for (size_t i=0; i<7; ++i) {
+        const SyncProps& props = m_props[ (id-i) % m_props.size() ];
+        if (!props.isOutlier) {
+          const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(id-i);
+          if (m->gpuReady.empty() || m->gpuSubmit.empty())
+            return m->gpuFinished - m->gpuStart;
+
+          time_point t = std::max( m->gpuReady[0], m->gpuSubmit[0] );
+          return std::chrono::duration_cast<microseconds>( t - m->start ).count()
+            + props.optimizedGpuTime
+            - m->gpuStart;
+        }
+      }
+
+      const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(id);
+      return m->gpuFinished - m->gpuStart;
+    };
+
+
+    bool isOutlier( uint64_t frameId ) {
+      constexpr size_t numLoop = 7;
+      int32_t totalCpuTime = 0;
+      for (size_t i=0; i<numLoop; ++i) {
+        const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(frameId-i);
+        totalCpuTime += m->cpuFinished;
+      }
+
+      int32_t avgCpuTime = totalCpuTime / numLoop;
+      const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(frameId);
+      if (m->cpuFinished > 1.7*avgCpuTime || m->gpuSubmit.empty() || m->gpuReady.size() != (m->gpuSubmit.size()+1) )
+        return true;
+
+      return false;
+    }
+
+
+    int32_t getLowLatencyOffset( const DxvkOptions& options );
+    bool getLowLatencyAllowCpuFramesOverlap( const DxvkOptions& options );
+
+    const int32_t m_lowLatencyOffset;
+    const bool    m_allowCpuFramesOverlap;
+
+    Sleep::TimePoint m_lastStart = { high_resolution_clock::now() };
+    std::array<SyncProps, 16> m_props;
+    std::atomic<uint64_t> m_propsFinished = { 0 };
+
+    std::vector<int32_t>  m_tempGpuRun;
+    std::vector<int32_t>  m_tempGpuRunDurations;
+
+  };
+
+}
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_min_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_min_latency.h
new file mode 100644
index 00000000000..763a5368ccc
--- /dev/null
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_min_latency.h
@@ -0,0 +1,45 @@
+#pragma once
+
+#include "dxvk_framepacer_mode.h"
+
+namespace dxvk {
+
+  /*
+   * Minimal latency is achieved here by waiting for the previous
+   * frame to complete, which results in very much reduced fps.
+   * Generally not recommended, but helpful to get insights to fine-tune
+   * the low-latency mode, and possibly is useful for running games
+   * in the cpu limit.
+   */
+
+  class MinLatencyMode : public FramePacerMode {
+
+  public:
+
+    MinLatencyMode(Mode mode, LatencyMarkersStorage* storage)
+    : FramePacerMode(mode, storage, 0) {}
+
+    ~MinLatencyMode() {}
+
+    void startFrame( uint64_t frameId ) override {
+
+      Sleep::TimePoint now = high_resolution_clock::now();
+      int32_t frametime = std::chrono::duration_cast<std::chrono::microseconds>(
+        now - m_lastStart ).count();
+      int32_t frametimeDiff = std::max( 0, m_fpsLimitFrametime.load() - frametime );
+      int32_t delay = std::max( 0, frametimeDiff );
+      delay = std::min( delay, 20000 );
+
+      Sleep::TimePoint nextStart = now + std::chrono::microseconds(delay);
+      Sleep::sleepUntil( now, nextStart );
+      m_lastStart = nextStart;
+
+    }
+
+  private:
+
+    Sleep::TimePoint m_lastStart = { high_resolution_clock::now() };
+
+  };
+
+}
diff --git a/src/dxvk/framepacer/dxvk_latency_markers.h b/src/dxvk/framepacer/dxvk_latency_markers.h
new file mode 100644
index 00000000000..7658f073789
--- /dev/null
+++ b/src/dxvk/framepacer/dxvk_latency_markers.h
@@ -0,0 +1,148 @@
+#pragma once
+
+#include <atomic>
+#include <dxgi.h>
+#include <vector>
+#include <array>
+#include <assert.h>
+#include "../../util/util_sleep.h"
+#include "../../util/log/log.h"
+#include "../../util/util_string.h"
+
+
+namespace dxvk {
+
+  class FramePacer;
+  class LatencyMarkersStorage;
+
+
+  struct LatencyMarkers {
+
+    using time_point = high_resolution_clock::time_point;
+
+    time_point start;
+    time_point end;
+
+    int32_t csStart;
+    int32_t csFinished;
+    int32_t cpuFinished;
+    int32_t gpuStart;
+    int32_t gpuFinished;
+    int32_t presentFinished;
+
+    std::vector<time_point> gpuReady;
+    std::vector<time_point> gpuSubmit;
+    std::vector<time_point> gpuQueueSubmit;
+
+  };
+
+
+  /*
+   * stores which information is accessible for which frame
+   */
+  struct LatencyMarkersTimeline {
+
+    std::atomic<uint64_t> cpuFinished   = { DXGI_MAX_SWAP_CHAIN_BUFFERS };
+    std::atomic<uint64_t> gpuStart      = { DXGI_MAX_SWAP_CHAIN_BUFFERS };
+    std::atomic<uint64_t> gpuFinished   = { DXGI_MAX_SWAP_CHAIN_BUFFERS };
+    std::atomic<uint64_t> frameFinished = { DXGI_MAX_SWAP_CHAIN_BUFFERS };
+
+  };
+
+
+  class LatencyMarkersReader {
+
+  public:
+
+    LatencyMarkersReader( const LatencyMarkersStorage* storage, uint32_t numEntries );
+    bool getNext( const LatencyMarkers*& result );
+
+  private:
+
+    const LatencyMarkersStorage* m_storage;
+    uint64_t m_index;
+
+  };
+
+
+  class LatencyMarkersStorage {
+    friend class LatencyMarkersReader;
+    friend class FramePacer;
+  public:
+
+    LatencyMarkersStorage() { }
+    ~LatencyMarkersStorage() { }
+
+    LatencyMarkersReader getReader( uint32_t numEntries ) const {
+      return LatencyMarkersReader(this, numEntries);
+    }
+
+    void registerFrameStart( uint64_t frameId ) {
+      if (frameId <= m_timeline.frameFinished.load()) {
+        Logger::warn( str::format("internal error during registerFrameStart: expected frameId=",
+          m_timeline.frameFinished.load()+1, ", got: ", frameId) );
+      }
+      auto now = high_resolution_clock::now();
+
+      LatencyMarkers* markers = getMarkers(frameId);
+      markers->start = now;
+    }
+
+    void registerFrameEnd( uint64_t frameId ) {
+      if (frameId <= m_timeline.frameFinished.load()) {
+        Logger::warn( str::format("internal error during registerFrameEnd: expected frameId=",
+          m_timeline.frameFinished.load()+1, ", got: ", frameId) );
+      }
+      auto now = high_resolution_clock::now();
+
+      LatencyMarkers* markers = getMarkers(frameId);
+      markers->presentFinished = std::chrono::duration_cast<std::chrono::microseconds>(
+        now - markers->start).count();
+      markers->end = now;
+
+      m_timeline.frameFinished.store(frameId);
+    }
+
+    const LatencyMarkersTimeline* getTimeline() const {
+      return &m_timeline;
+    }
+
+    const LatencyMarkers* getConstMarkers( uint64_t frameId ) const {
+      return &m_markers[frameId % m_numMarkers];
+    }
+
+
+  private:
+
+    LatencyMarkers* getMarkers( uint64_t frameId ) {
+      return &m_markers[frameId % m_numMarkers];
+    }
+
+    // simple modulo hash mapping is used for frameIds. They are expected to monotonically increase by one.
+    // select the size large enough, so we never come into a situation where the reader cannot keep up with the producer
+    static constexpr uint16_t m_numMarkers = 128;
+    std::array<LatencyMarkers, m_numMarkers> m_markers = { };
+    LatencyMarkersTimeline m_timeline;
+
+  };
+
+
+
+  inline LatencyMarkersReader::LatencyMarkersReader( const LatencyMarkersStorage* storage, uint32_t numEntries )
+  : m_storage(storage) {
+    m_index = 0;
+    if (m_storage->m_timeline.frameFinished.load() > numEntries + DXGI_MAX_SWAP_CHAIN_BUFFERS + 2)
+      m_index = m_storage->m_timeline.frameFinished.load() - numEntries;
+  }
+
+
+  inline bool LatencyMarkersReader::getNext( const LatencyMarkers*& result ) {
+    if (m_index == 0 || m_index > m_storage->m_timeline.frameFinished.load())
+      return false;
+
+    result = &m_storage->m_markers[m_index % m_storage->m_numMarkers];
+    m_index++;
+    return true;
+  }
+
+}
diff --git a/src/dxvk/meson.build b/src/dxvk/meson.build
index 9b2b0735699..e5d99054337 100644
--- a/src/dxvk/meson.build
+++ b/src/dxvk/meson.build
@@ -120,6 +120,9 @@ dxvk_src = [
   'hud/dxvk_hud_font.cpp',
   'hud/dxvk_hud_item.cpp',
   'hud/dxvk_hud_renderer.cpp',
+
+  'framepacer/dxvk_framepacer.cpp',
+  'framepacer/dxvk_framepacer_mode_low_latency.cpp',
 ]
 
 if platform == 'windows'

From a8bd6f069e1367dd1020a32d16e095fd38115fde Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Tue, 18 Feb 2025 21:39:01 +0100
Subject: [PATCH 03/81] [dxvk] Integrate frame pacing

---
 src/d3d11/d3d11_swapchain.cpp |  5 +++++
 src/d3d9/d3d9_swapchain.cpp   |  5 +++++
 src/dxvk/dxvk_context.cpp     |  2 +-
 src/dxvk/dxvk_device.cpp      |  5 +++--
 src/dxvk/dxvk_presenter.cpp   |  9 ++++-----
 src/dxvk/dxvk_queue.cpp       |  9 ++++++++-
 src/util/util_fps_limiter.cpp | 15 +++++++++++++--
 src/util/util_fps_limiter.h   |  6 +++++-
 8 files changed, 44 insertions(+), 12 deletions(-)

diff --git a/src/d3d11/d3d11_swapchain.cpp b/src/d3d11/d3d11_swapchain.cpp
index a2d356067fe..cb5679854a0 100644
--- a/src/d3d11/d3d11_swapchain.cpp
+++ b/src/d3d11/d3d11_swapchain.cpp
@@ -3,6 +3,7 @@
 #include "d3d11_swapchain.h"
 
 #include "../dxvk/dxvk_latency_builtin.h"
+#include "../dxvk/framepacer/dxvk_framepacer.h"
 
 #include "../util/util_win32_compat.h"
 
@@ -354,6 +355,10 @@ namespace dxvk {
 
     if (m_presenter != nullptr)
       m_presenter->setFrameRateLimit(m_targetFrameRate, GetActualFrameLatency());
+
+    FramePacer* framePacer = dynamic_cast<FramePacer*>(m_latency.ptr());
+    if (framePacer != nullptr)
+      framePacer->setTargetFrameRate(FrameRate);
   }
 
 
diff --git a/src/d3d9/d3d9_swapchain.cpp b/src/d3d9/d3d9_swapchain.cpp
index 73218c51626..05466eca528 100644
--- a/src/d3d9/d3d9_swapchain.cpp
+++ b/src/d3d9/d3d9_swapchain.cpp
@@ -5,6 +5,8 @@
 #include "d3d9_hud.h"
 #include "d3d9_window.h"
 
+#include "../dxvk/framepacer/dxvk_framepacer.h"
+
 namespace dxvk {
 
   static uint16_t MapGammaControlPoint(float x) {
@@ -1112,6 +1114,9 @@ namespace dxvk {
     }
 
     m_wctx->presenter->setFrameRateLimit(frameRate, GetActualFrameLatency());
+    FramePacer* framePacer = dynamic_cast<FramePacer*>(m_latencyTracker.ptr());
+    if (framePacer != nullptr)
+      framePacer->setTargetFrameRate(frameRate);
     m_targetFrameRate = frameRate;
   }
 
diff --git a/src/dxvk/dxvk_context.cpp b/src/dxvk/dxvk_context.cpp
index ec9fa07617a..d33938dda9d 100644
--- a/src/dxvk/dxvk_context.cpp
+++ b/src/dxvk/dxvk_context.cpp
@@ -113,7 +113,7 @@ namespace dxvk {
   void DxvkContext::beginLatencyTracking(
     const Rc<DxvkLatencyTracker>&     tracker,
           uint64_t                    frameId) {
-    if (tracker && (!m_latencyTracker || m_latencyTracker == tracker)) {
+    if (tracker && m_latencyTracker != tracker) {
       tracker->notifyCsRenderBegin(frameId);
 
       m_latencyTracker = tracker;
diff --git a/src/dxvk/dxvk_device.cpp b/src/dxvk/dxvk_device.cpp
index eed3eb3cf30..cdb59e6c774 100644
--- a/src/dxvk/dxvk_device.cpp
+++ b/src/dxvk/dxvk_device.cpp
@@ -2,6 +2,7 @@
 #include "dxvk_instance.h"
 #include "dxvk_latency_builtin.h"
 #include "dxvk_latency_reflex.h"
+#include "framepacer/dxvk_framepacer.h"
 
 namespace dxvk {
   
@@ -310,13 +311,13 @@ namespace dxvk {
   Rc<DxvkLatencyTracker> DxvkDevice::createLatencyTracker(
     const Rc<Presenter>&            presenter) {
     if (m_options.latencySleep == Tristate::False)
-      return nullptr;
+      return new FramePacer(m_options);
 
     if (m_options.latencySleep == Tristate::Auto) {
       if (m_features.nvLowLatency2)
         return new DxvkReflexLatencyTrackerNv(presenter);
       else
-        return nullptr;
+        return new FramePacer(m_options);
     }
 
     return new DxvkBuiltInLatencyTracker(presenter,
diff --git a/src/dxvk/dxvk_presenter.cpp b/src/dxvk/dxvk_presenter.cpp
index 0e3c87762b1..79e10ad66f5 100644
--- a/src/dxvk/dxvk_presenter.cpp
+++ b/src/dxvk/dxvk_presenter.cpp
@@ -270,7 +270,7 @@ namespace dxvk {
       if (canSignal)
         m_signal->signal(frameId);
     } else {
-      m_fpsLimiter.delay();
+      m_fpsLimiter.delay(tracker);
       m_signal->signal(frameId);
 
       if (tracker)
@@ -1243,15 +1243,14 @@ namespace dxvk {
 
       // Signal latency tracker right away to get more accurate
       // measurements if the frame rate limiter is enabled.
-      if (frame.tracker) {
+      if (frame.tracker)
         frame.tracker->notifyGpuPresentEnd(frame.frameId);
-        frame.tracker = nullptr;
-      }
 
       // Apply FPS limiter here to align it as closely with scanout as we can,
       // and delay signaling the frame latency event to emulate behaviour of a
       // low refresh rate display as closely as we can.
-      m_fpsLimiter.delay();
+      m_fpsLimiter.delay(frame.tracker);
+      frame.tracker = nullptr;
 
       // Wake up any thread that may be waiting for the queue to become empty
       bool canSignal = false;
diff --git a/src/dxvk/dxvk_queue.cpp b/src/dxvk/dxvk_queue.cpp
index 6d2d153b6b0..0c74428a0b5 100644
--- a/src/dxvk/dxvk_queue.cpp
+++ b/src/dxvk/dxvk_queue.cpp
@@ -1,5 +1,6 @@
 #include "dxvk_device.h"
 #include "dxvk_queue.h"
+#include "framepacer/dxvk_framepacer.h"
 
 namespace dxvk {
   
@@ -46,6 +47,8 @@ namespace dxvk {
           DxvkSubmitInfo            submitInfo,
           DxvkLatencyInfo           latencyInfo,
           DxvkSubmitStatus*         status) {
+    if (latencyInfo.tracker)
+      latencyInfo.tracker->notifySubmit();
     std::unique_lock<dxvk::mutex> lock(m_mutex);
 
     m_finishCond.wait(lock, [this] {
@@ -66,6 +69,8 @@ namespace dxvk {
           DxvkPresentInfo           presentInfo,
           DxvkLatencyInfo           latencyInfo,
           DxvkSubmitStatus*         status) {
+    if (latencyInfo.tracker)
+      latencyInfo.tracker->notifyPresent(presentInfo.frameId);
     std::unique_lock<dxvk::mutex> lock(m_mutex);
 
     DxvkSubmitEntry entry = { };
@@ -274,7 +279,9 @@ namespace dxvk {
       } else if (entry.present.presenter != nullptr) {
         // Signal the frame and then immediately destroy the reference.
         // This is necessary since the front-end may want to explicitly
-        // destroy the presenter object. 
+        // destroy the presenter object.
+        if (entry.latency.tracker)
+          entry.latency.tracker->notifyGpuPresentBegin(entry.present.frameId);
         entry.present.presenter->signalFrame(entry.present.frameId, entry.latency.tracker);
         entry.present.presenter = nullptr;
       }
diff --git a/src/util/util_fps_limiter.cpp b/src/util/util_fps_limiter.cpp
index 621e9a45307..95fb79e7e70 100644
--- a/src/util/util_fps_limiter.cpp
+++ b/src/util/util_fps_limiter.cpp
@@ -5,12 +5,15 @@
 #include "util_fps_limiter.h"
 #include "util_sleep.h"
 #include "util_string.h"
+#include "../dxvk/framepacer/dxvk_framepacer.h"
 
 #include "./log/log.h"
 
 using namespace std::chrono_literals;
 
 namespace dxvk {
+
+  std::atomic<bool> FpsLimiter::m_isActive = { false };
   
   FpsLimiter::FpsLimiter() {
     auto override = getEnvironmentOverride();
@@ -48,7 +51,12 @@ namespace dxvk {
   }
 
 
-  void FpsLimiter::delay() {
+  void FpsLimiter::delay(const Rc<DxvkLatencyTracker>& tracker) {
+    FramePacer* framePacer = dynamic_cast<FramePacer*>(tracker.ptr());
+    if (framePacer && framePacer->getMode()) {
+      return;
+    }
+
     std::unique_lock<dxvk::mutex> lock(m_mutex);
     auto interval = m_targetInterval;
     auto latency = m_maxLatency;
@@ -71,8 +79,11 @@ namespace dxvk {
     // that can be written by setTargetFrameRate
     lock.unlock();
 
-    if (t1 < m_nextFrame)
+    m_isActive.store(false);
+    if (t1 < m_nextFrame) {
+      m_isActive.store(true);
       Sleep::sleepUntil(t1, m_nextFrame);
+    }
 
     m_nextFrame = (t1 < m_nextFrame + interval)
       ? m_nextFrame + interval
diff --git a/src/util/util_fps_limiter.h b/src/util/util_fps_limiter.h
index 7c33a559f4b..d5610afd4d0 100644
--- a/src/util/util_fps_limiter.h
+++ b/src/util/util_fps_limiter.h
@@ -7,6 +7,8 @@
 #include "util_time.h"
 
 namespace dxvk {
+
+  class DxvkLatencyTracker;
   
   /**
    * \brief Frame rate limiter
@@ -38,7 +40,7 @@ namespace dxvk {
      * and the time since the last call to \ref delay is
      * shorter than the target interval.
      */
-    void delay();
+    void delay(const Rc<DxvkLatencyTracker>& tracker);
 
     /**
      * \brief Queries environment override
@@ -46,6 +48,8 @@ namespace dxvk {
      */
     static std::optional<double> getEnvironmentOverride();
 
+    static std::atomic<bool> m_isActive;
+
   private:
 
     using TimePoint = dxvk::high_resolution_clock::time_point;

From 2c26eb2118eddc8fee7edbd1c408727cf6f077f1 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Tue, 18 Feb 2025 21:47:03 +0100
Subject: [PATCH 04/81] [hud] Add render latency

---
 src/d3d11/d3d11_swapchain.cpp  | 11 ++++++-
 src/d3d11/d3d11_swapchain.h    |  3 +-
 src/d3d9/d3d9_swapchain.cpp    | 11 ++++++-
 src/d3d9/d3d9_swapchain.h      |  5 +--
 src/dxvk/hud/dxvk_hud.h        |  5 +++
 src/dxvk/hud/dxvk_hud_item.cpp | 58 ++++++++++++++++++++++++++++++++++
 src/dxvk/hud/dxvk_hud_item.h   | 45 ++++++++++++++++++++++++++
 7 files changed, 133 insertions(+), 5 deletions(-)

diff --git a/src/d3d11/d3d11_swapchain.cpp b/src/d3d11/d3d11_swapchain.cpp
index cb5679854a0..e2100eb8d73 100644
--- a/src/d3d11/d3d11_swapchain.cpp
+++ b/src/d3d11/d3d11_swapchain.cpp
@@ -295,6 +295,9 @@ namespace dxvk {
     if (m_latencyHud)
       m_latencyHud->accumulateStats(latencyStats);
 
+    if (m_renderLatencyHud)
+      m_renderLatencyHud->updateLatencyTracker(m_latency);
+
     return hr;
   }
 
@@ -604,8 +607,14 @@ namespace dxvk {
     if (hud) {
       hud->addItem<hud::HudClientApiItem>("api", 1, GetApiName());
 
-      if (m_latency)
+      if (m_latency) {
         m_latencyHud = hud->addItem<hud::HudLatencyItem>("latency", 4);
+        FramePacer* framePacer = dynamic_cast<FramePacer*>(m_latency.ptr());
+        if (framePacer) {
+          int32_t fpsItemPos = hud->getItemPos<hud::HudFpsItem>();
+          m_renderLatencyHud = hud->addItem<hud::HudRenderLatencyItem>("renderlatency", fpsItemPos+1);
+        }
+      }
     }
 
     m_blitter = new DxvkSwapchainBlitter(m_device, std::move(hud));
diff --git a/src/d3d11/d3d11_swapchain.h b/src/d3d11/d3d11_swapchain.h
index 99f09450c7a..6a77c7351d6 100644
--- a/src/d3d11/d3d11_swapchain.h
+++ b/src/d3d11/d3d11_swapchain.h
@@ -125,7 +125,8 @@ namespace dxvk {
     dxvk::mutex               m_frameStatisticsLock;
     DXGI_VK_FRAME_STATISTICS  m_frameStatistics = { };
 
-    Rc<hud::HudLatencyItem>   m_latencyHud;
+    Rc<hud::HudLatencyItem>       m_latencyHud;
+    Rc<hud::HudRenderLatencyItem> m_renderLatencyHud;
 
     Rc<DxvkImageView> GetBackBufferView();
 
diff --git a/src/d3d9/d3d9_swapchain.cpp b/src/d3d9/d3d9_swapchain.cpp
index 05466eca528..539b0815c97 100644
--- a/src/d3d9/d3d9_swapchain.cpp
+++ b/src/d3d9/d3d9_swapchain.cpp
@@ -925,6 +925,9 @@ namespace dxvk {
     if (m_latencyHud)
       m_latencyHud->accumulateStats(latencyStats);
 
+    if (m_renderLatencyHud)
+      m_renderLatencyHud->updateLatencyTracker(m_latencyTracker);
+
     // Rotate swap chain buffers so that the back
     // buffer at index 0 becomes the front buffer.
     for (uint32_t i = 1; i < m_backBuffers.size(); i++)
@@ -1062,8 +1065,14 @@ namespace dxvk {
     if (hud) {
       m_apiHud = hud->addItem<hud::HudClientApiItem>("api", 1, GetApiName());
 
-      if (m_latencyTracking)
+      if (m_latencyTracking) {
         m_latencyHud = hud->addItem<hud::HudLatencyItem>("latency", 4);
+        FramePacer* framePacer = dynamic_cast<FramePacer*>(m_latencyTracker.ptr());
+        if (framePacer) {
+          int32_t fpsItemPos = hud->getItemPos<hud::HudFpsItem>();
+          m_renderLatencyHud = hud->addItem<hud::HudRenderLatencyItem>("renderlatency", fpsItemPos+1);
+        }
+      }
 
       hud->addItem<hud::HudSamplerCount>("samplers", -1, m_parent);
       hud->addItem<hud::HudFixedFunctionShaders>("ffshaders", -1, m_parent);
diff --git a/src/d3d9/d3d9_swapchain.h b/src/d3d9/d3d9_swapchain.h
index 6ea0d96cb33..d06c388a954 100644
--- a/src/d3d9/d3d9_swapchain.h
+++ b/src/d3d9/d3d9_swapchain.h
@@ -183,8 +183,9 @@ namespace dxvk {
     bool                      m_latencyTracking = false;
     Rc<DxvkLatencyTracker>    m_latencyTracker = nullptr;
 
-    Rc<hud::HudClientApiItem> m_apiHud;
-    Rc<hud::HudLatencyItem>   m_latencyHud;
+    Rc<hud::HudClientApiItem>     m_apiHud;
+    Rc<hud::HudLatencyItem>       m_latencyHud;
+    Rc<hud::HudRenderLatencyItem> m_renderLatencyHud;
 
     std::optional<VkHdrMetadataEXT> m_hdrMetadata;
     bool m_unlockAdditionalFormats = false;
diff --git a/src/dxvk/hud/dxvk_hud.h b/src/dxvk/hud/dxvk_hud.h
index 58c383f07ad..388cbf22a0b 100644
--- a/src/dxvk/hud/dxvk_hud.h
+++ b/src/dxvk/hud/dxvk_hud.h
@@ -59,6 +59,11 @@ namespace dxvk::hud {
     Rc<T> addItem(const char* name, int32_t at, Args... args) {
       return m_hudItems.add<T>(name, at, std::forward<Args>(args)...);
     }
+
+    template<typename T>
+    int32_t getItemPos() {
+      return m_hudItems.getItemPos<T>();
+    }
     
     /**
      * \brief Creates the HUD
diff --git a/src/dxvk/hud/dxvk_hud_item.cpp b/src/dxvk/hud/dxvk_hud_item.cpp
index f80ba77d488..138f1333f6c 100644
--- a/src/dxvk/hud/dxvk_hud_item.cpp
+++ b/src/dxvk/hud/dxvk_hud_item.cpp
@@ -1,4 +1,5 @@
 #include "dxvk_hud_item.h"
+#include "../framepacer/dxvk_framepacer.h"
 
 #include <hud_chunk_frag_background.h>
 #include <hud_chunk_frag_visualize.h>
@@ -213,6 +214,63 @@ namespace dxvk::hud {
   }
 
 
+  HudRenderLatencyItem::HudRenderLatencyItem() { }
+  HudRenderLatencyItem::~HudRenderLatencyItem() { }
+
+  void HudRenderLatencyItem::update(dxvk::high_resolution_clock::time_point time) {
+    // we cannot measure latency when fps-limiting is performed in Presenter::runFrameThread()
+    // because it's interfering with getting the right timestamp from vkWaitForPresent()
+    // if we truely wanted to measure it, we would need one additional thread
+    if (FpsLimiter::m_isActive) {
+      m_latency = "N/A";
+      return;
+    }
+
+    const Rc<DxvkLatencyTracker> tracker = m_tracker;
+    const FramePacer* framePacer = dynamic_cast<FramePacer*>( tracker.ptr() );
+    if (!framePacer)
+      return;
+
+    auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(time - m_lastUpdate);
+
+    if (elapsed.count() >= UpdateInterval) {
+      m_lastUpdate = time;
+
+      LatencyMarkersReader reader = framePacer->m_latencyMarkersStorage.getReader(100);
+      const LatencyMarkers* markers;
+      uint32_t count = 0;
+      uint64_t totalLatency = 0;
+      while (reader.getNext(markers)) {
+        totalLatency += markers->presentFinished;
+        ++count;
+      }
+
+      if (!count)
+        return;
+
+      uint64_t latency = totalLatency / count;
+      m_latency = str::format(latency / 1000, ".", (latency/100) % 10, " ms");
+    }
+  }
+
+
+  HudPos HudRenderLatencyItem::render(
+    const DxvkContextObjects& ctx,
+    const HudPipelineKey&     key,
+    const HudOptions&         options,
+          HudRenderer&        renderer,
+          HudPos              position) {
+
+    position.y += 12;
+    renderer.drawText(16, position, 0xff4040ffu, "Render latency:");
+    renderer.drawText(16, { position.x + 195, position.y },
+      0xffffffffu, m_latency);
+
+    position.y += 8;
+    return position;
+  }
+
+
   HudFrameTimeItem::HudFrameTimeItem(const Rc<DxvkDevice>& device, HudRenderer* renderer)
   : m_device            (device),
     m_gfxSetLayout      (createDescriptorSetLayout()),
diff --git a/src/dxvk/hud/dxvk_hud_item.h b/src/dxvk/hud/dxvk_hud_item.h
index 866849b4ea0..fab3fc97fe7 100644
--- a/src/dxvk/hud/dxvk_hud_item.h
+++ b/src/dxvk/hud/dxvk_hud_item.h
@@ -131,6 +131,15 @@ namespace dxvk::hud {
       return value;
     }
 
+    template<typename T>
+    int32_t getItemPos() {
+      for (int i=0; i<(int)m_items.size(); ++i) {
+        if (dynamic_cast<T*>(m_items[i].ptr()))
+          return i;
+      }
+      return -1;
+    }
+
   private:
 
     bool                                          m_enableFull = false;
@@ -244,6 +253,42 @@ namespace dxvk::hud {
   };
 
 
+   /**
+   * \brief HUD item to display render latency
+   */
+  class HudRenderLatencyItem : public HudItem {
+    constexpr static int64_t UpdateInterval = 500'000;
+  public:
+
+    HudRenderLatencyItem();
+
+    ~HudRenderLatencyItem();
+
+    void updateLatencyTracker( const Rc<DxvkLatencyTracker>& tracker ) {
+      m_tracker = tracker;
+    }
+
+    void update(dxvk::high_resolution_clock::time_point time);
+
+    HudPos render(
+      const DxvkContextObjects& ctx,
+      const HudPipelineKey&     key,
+      const HudOptions&         options,
+            HudRenderer&        renderer,
+            HudPos              position);
+
+  private:
+
+    Rc<DxvkLatencyTracker> m_tracker;
+
+    dxvk::high_resolution_clock::time_point m_lastUpdate
+      = dxvk::high_resolution_clock::now();
+
+    std::string m_latency;
+
+  };
+
+
   /**
    * \brief HUD item to display the frame rate
    */

From 9ed43a60a3397957f44a47ade7efcedbab5bf9f8 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Wed, 19 Feb 2025 15:47:45 +0100
Subject: [PATCH 05/81] Revert "[dxvk] Fix lack of forward progress guarantee
 in presenter"

This reverts commit efeb15edbd6dc913030f0846cbc1b587f6fb7c5d.
---
 src/dxvk/dxvk_presenter.cpp | 61 ++++++++++++++-----------------------
 src/dxvk/dxvk_presenter.h   |  1 -
 2 files changed, 23 insertions(+), 39 deletions(-)

diff --git a/src/dxvk/dxvk_presenter.cpp b/src/dxvk/dxvk_presenter.cpp
index 79e10ad66f5..3297d14a0c1 100644
--- a/src/dxvk/dxvk_presenter.cpp
+++ b/src/dxvk/dxvk_presenter.cpp
@@ -259,16 +259,9 @@ namespace dxvk {
       return;
 
     if (m_device->features().khrPresentWait.presentWait) {
-      bool canSignal = false;
-
-      { std::unique_lock lock(m_frameMutex);
-
-        m_lastSignaled = frameId;
-        canSignal = m_lastCompleted >= frameId;
-      }
-
-      if (canSignal)
-        m_signal->signal(frameId);
+      std::lock_guard lock(m_frameMutex);
+      m_lastSignaled = frameId;
+      m_frameCond.notify_one();
     } else {
       m_fpsLimiter.delay(tracker);
       m_signal->signal(frameId);
@@ -1210,26 +1203,25 @@ namespace dxvk {
   void Presenter::runFrameThread() {
     env::setThreadName("dxvk-frame");
 
-    while (true) {
-      PresenterFrame frame = { };
+    std::unique_lock lock(m_frameMutex);
 
+    while (true) {
       // Wait for all GPU work for this frame to complete in order to maintain
       // ordering guarantees of the frame signal w.r.t. objects being released
-      { std::unique_lock lock(m_frameMutex);
+      m_frameCond.wait(lock, [this] {
+        return !m_frameQueue.empty() && m_frameQueue.front().frameId <= m_lastSignaled;
+      });
 
-        m_frameCond.wait(lock, [this] {
-          return !m_frameQueue.empty();
-        });
+      // Use a frame ID of 0 as an exit condition
+      PresenterFrame frame = m_frameQueue.front();
 
-        // Use a frame ID of 0 as an exit condition
-        frame = m_frameQueue.front();
-
-        if (!frame.frameId) {
-          m_frameQueue.pop();
-          return;
-        }
+      if (!frame.frameId) {
+        m_frameQueue.pop();
+        return;
       }
 
+      lock.unlock();
+
       // If the present operation has succeeded, actually wait for it to complete.
       // Don't bother with it on MAILBOX / IMMEDIATE modes since doing so would
       // restrict us to the display refresh rate on some platforms (XWayland).
@@ -1246,28 +1238,21 @@ namespace dxvk {
       if (frame.tracker)
         frame.tracker->notifyGpuPresentEnd(frame.frameId);
 
-      // Apply FPS limiter here to align it as closely with scanout as we can,
+      // Apply FPS limtier here to align it as closely with scanout as we can,
       // and delay signaling the frame latency event to emulate behaviour of a
       // low refresh rate display as closely as we can.
       m_fpsLimiter.delay(frame.tracker);
       frame.tracker = nullptr;
 
-      // Wake up any thread that may be waiting for the queue to become empty
-      bool canSignal = false;
-
-      { std::unique_lock lock(m_frameMutex);
-
-        m_frameQueue.pop();
-        m_frameDrain.notify_one();
-
-        m_lastCompleted = frame.frameId;
-        canSignal = m_lastSignaled >= frame.frameId;
-      }
-
       // Always signal even on error, since failures here
       // are transparent to the front-end.
-      if (canSignal)
-        m_signal->signal(frame.frameId);
+      m_signal->signal(frame.frameId);
+
+      // Wake up any thread that may be waiting for the queue to become empty
+      lock.lock();
+
+      m_frameQueue.pop();
+      m_frameDrain.notify_one();
     }
   }
 
diff --git a/src/dxvk/dxvk_presenter.h b/src/dxvk/dxvk_presenter.h
index 8e403b244ee..afbe465c320 100644
--- a/src/dxvk/dxvk_presenter.h
+++ b/src/dxvk/dxvk_presenter.h
@@ -315,7 +315,6 @@ namespace dxvk {
     std::queue<PresenterFrame>  m_frameQueue;
 
     uint64_t                    m_lastSignaled = 0u;
-    uint64_t                    m_lastCompleted = 0u;
 
     alignas(CACHE_LINE_SIZE)
     FpsLimiter                  m_fpsLimiter;

From 0f3cbd6f667c76c30594144e16b0b9f493134f14 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Sat, 22 Feb 2025 18:21:02 +0100
Subject: [PATCH 06/81] [dxvk] Improve low-latency frame pacing for cpu-limited
 frames

---
 .../framepacer/dxvk_framepacer_mode_low_latency.h    | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index 06fdaf0dd0e..ec1d4f5425a 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -87,7 +87,13 @@ namespace dxvk {
         m->start + microseconds(m->gpuStart+getGpuStartToFinishPrediction()) - now).count();
 
       int32_t targetGpuSync = gpuReadyPrediction + props.gpuSync;
-      int32_t delay = targetGpuSync - props.cpuUntilGpuSync + m_lowLatencyOffset;
+      int32_t gpuDelay = targetGpuSync - props.cpuUntilGpuSync;
+
+      int32_t cpuReadyPrediction = duration_cast<microseconds>(
+        m->start + microseconds(props.csFinished) - now).count();
+      int32_t cpuDelay = cpuReadyPrediction - props.csStart;
+
+      int32_t delay = std::max(gpuDelay, cpuDelay) + m_lowLatencyOffset;
 
       m_lastStart = sleepFor( now, delay );
 
@@ -143,6 +149,8 @@ namespace dxvk {
       props.gpuSync = gpuRun[numLoop-1];
       props.cpuUntilGpuSync = offset + duration_cast<microseconds>( m->gpuSubmit[numLoop-1] - m->start ).count();
       props.optimizedGpuTime = optimizedGpuTime;
+      props.csStart = m->csStart;
+      props.csFinished = m->csFinished;
       props.isOutlier = isOutlier(frameId);
 
       m_propsFinished.store( frameId );
@@ -171,6 +179,8 @@ namespace dxvk {
       int32_t optimizedGpuTime;   // gpu executing packed submits in one go
       int32_t gpuSync;            // us after gpuStart
       int32_t cpuUntilGpuSync;
+      int32_t csStart;
+      int32_t csFinished;
       bool    isOutlier;
     };
 

From a13b821f95ce234c47b80c1c616891a3a6438711 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Sun, 23 Feb 2025 09:54:07 +0100
Subject: [PATCH 07/81] [dxvk] Allow for fps limit < 50 fps in low-latency mode

---
 dxvk.conf                                              | 4 ++--
 src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h | 3 ++-
 src/dxvk/framepacer/dxvk_framepacer_mode_min_latency.h | 3 ++-
 src/util/util_fps_limiter.cpp                          | 3 ++-
 4 files changed, 8 insertions(+), 5 deletions(-)

diff --git a/dxvk.conf b/dxvk.conf
index 0b8deba8cb8..d8ae19950fc 100644
--- a/dxvk.conf
+++ b/dxvk.conf
@@ -39,7 +39,7 @@
 #
 # Supported values: "max-frame-latency", "low-latency", "min-latency"
 
-# dxvk.framePacing = ""
+# dxvk.framePace = ""
 
 
 # Allows fine-tuning the low-latency frame pacing mode.
@@ -149,7 +149,7 @@
 #         The implementation will either use VK_NV_low_latency2 if supported
 #         by the driver, or a custom algorithm.
 # - False: Disable Reflex support as well as built-in latency reduction.
-#         This build defaults to False to enable dxvk.framePacing. You need to
+#         This build defaults to False to enable dxvk.framePace. You need to
 #         enable Reflex manually (Auto) until we support switching back and
 #         forth between Reflex and the low-latency frame pacing - for example
 #         via the ingame options - and more critically we want to enable
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index ec1d4f5425a..28f5f170b3d 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -164,7 +164,8 @@ namespace dxvk {
       int32_t frametime = std::chrono::duration_cast<microseconds>( t - m_lastStart ).count();
       int32_t frametimeDiff = std::max( 0, m_fpsLimitFrametime.load() - frametime );
       delay = std::max( delay, frametimeDiff );
-      delay = std::max( 0, std::min( delay, 20000 ) );
+      int32_t maxDelay = std::max( m_fpsLimitFrametime.load(), 20000 );
+      delay = std::max( 0, std::min( delay, maxDelay ) );
 
       Sleep::TimePoint nextStart = t + microseconds(delay);
       Sleep::sleepUntil( t, nextStart );
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_min_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_min_latency.h
index 763a5368ccc..03e94d0de8d 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_min_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_min_latency.h
@@ -28,7 +28,8 @@ namespace dxvk {
         now - m_lastStart ).count();
       int32_t frametimeDiff = std::max( 0, m_fpsLimitFrametime.load() - frametime );
       int32_t delay = std::max( 0, frametimeDiff );
-      delay = std::min( delay, 20000 );
+      int32_t maxDelay = std::max( m_fpsLimitFrametime.load(), 20000 );
+      delay = std::min( delay, maxDelay );
 
       Sleep::TimePoint nextStart = now + std::chrono::microseconds(delay);
       Sleep::sleepUntil( now, nextStart );
diff --git a/src/util/util_fps_limiter.cpp b/src/util/util_fps_limiter.cpp
index 95fb79e7e70..f8866ff166b 100644
--- a/src/util/util_fps_limiter.cpp
+++ b/src/util/util_fps_limiter.cpp
@@ -57,6 +57,8 @@ namespace dxvk {
       return;
     }
 
+    m_isActive.store(false);
+
     std::unique_lock<dxvk::mutex> lock(m_mutex);
     auto interval = m_targetInterval;
     auto latency = m_maxLatency;
@@ -79,7 +81,6 @@ namespace dxvk {
     // that can be written by setTargetFrameRate
     lock.unlock();
 
-    m_isActive.store(false);
     if (t1 < m_nextFrame) {
       m_isActive.store(true);
       Sleep::sleepUntil(t1, m_nextFrame);

From c802bdf42e993b467f8fa18b2db52da5841164d1 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Sun, 23 Feb 2025 10:00:50 +0100
Subject: [PATCH 08/81] [dxvk] Remove dxvk.lowLatencyAllowCpuFramesOverlap
 config variable

---
 src/dxvk/dxvk_options.cpp                     |  2 --
 src/dxvk/framepacer/dxvk_framepacer.h         |  1 -
 src/dxvk/framepacer/dxvk_framepacer_mode.h    |  4 ----
 .../dxvk_framepacer_mode_low_latency.cpp      | 19 -------------------
 .../dxvk_framepacer_mode_low_latency.h        | 11 ++---------
 5 files changed, 2 insertions(+), 35 deletions(-)

diff --git a/src/dxvk/dxvk_options.cpp b/src/dxvk/dxvk_options.cpp
index 85fc3ec3e4c..a31778e18cc 100644
--- a/src/dxvk/dxvk_options.cpp
+++ b/src/dxvk/dxvk_options.cpp
@@ -20,8 +20,6 @@ namespace dxvk {
     allowFse              = config.getOption<bool>    ("dxvk.allowFse",               false);
     framePace             = config.getOption<std::string>("dxvk.framePace",           "");
     lowLatencyOffset      = config.getOption<int32_t> ("dxvk.lowLatencyOffset",       0);
-    lowLatencyAllowCpuFramesOverlap
-                          = config.getOption<bool>    ("dxvk.lowLatencyAllowCpuFramesOverlap", true);
     deviceFilter          = config.getOption<std::string>("dxvk.deviceFilter",        "");
     tilerMode             = config.getOption<Tristate>("dxvk.tilerMode",              Tristate::Auto);
   }
diff --git a/src/dxvk/framepacer/dxvk_framepacer.h b/src/dxvk/framepacer/dxvk_framepacer.h
index 264dcff5755..0028e1353d6 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.h
+++ b/src/dxvk/framepacer/dxvk_framepacer.h
@@ -53,7 +53,6 @@ namespace dxvk {
       auto now = high_resolution_clock::now();
       LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
       m->csFinished = std::chrono::duration_cast<microseconds>(now - m->start).count();
-      m_mode->signalCsFinished( frameId );
     }
 
     void notifySubmit() override {
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode.h b/src/dxvk/framepacer/dxvk_framepacer_mode.h
index 109a240a277..2109bd57b78 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode.h
@@ -44,9 +44,6 @@ namespace dxvk {
     void signalGpuStart( uint64_t frameId ) {
       if (m_mode) m_fenceGpuStart.signal(frameId); }
 
-    void signalCsFinished( uint64_t frameId ) {
-      if (m_mode) m_fenceCsFinished.signal(frameId); }
-
     void setTargetFrameRate( double frameRate ) {
       if (!m_fpsLimitEnvOverride && frameRate > 1.0)
         m_fpsLimitFrametime.store( 1'000'000/frameRate );
@@ -68,7 +65,6 @@ namespace dxvk {
 
     sync::Fence m_fenceGpuStart    = { sync::Fence(DXGI_MAX_SWAP_CHAIN_BUFFERS) };
     sync::Fence m_fenceGpuFinished = { sync::Fence(DXGI_MAX_SWAP_CHAIN_BUFFERS) };
-    sync::Fence m_fenceCsFinished  = { sync::Fence(DXGI_MAX_SWAP_CHAIN_BUFFERS+50) };
 
   };
 
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
index 4e39145b4c3..4af77f0519b 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
@@ -10,15 +10,6 @@ namespace dxvk {
   }
 
 
-  bool getLowLatencyAllowCpuFramesOverlapFromEnv( bool& allowOverlap ) {
-    int32_t o;
-    if (!FramePacerMode::getIntFromEnv("DXVK_LOW_LATENCY_ALLOW_CPU_FRAMES_OVERLAP", &o))
-      return false;
-    allowOverlap = (bool) o;
-    return true;
-  }
-
-
   int32_t LowLatencyMode::getLowLatencyOffset( const DxvkOptions& options ) {
     int32_t offset = options.lowLatencyOffset;
     int32_t o;
@@ -30,14 +21,4 @@ namespace dxvk {
     return offset;
   }
 
-
-  bool LowLatencyMode::getLowLatencyAllowCpuFramesOverlap( const DxvkOptions& options ) {
-    bool allowOverlap = options.lowLatencyAllowCpuFramesOverlap;
-    bool o;
-    if (getLowLatencyAllowCpuFramesOverlapFromEnv(o))
-      allowOverlap = o;
-    return allowOverlap;
-  }
-
-
 }
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index 28f5f170b3d..2d17df1c7a4 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -44,20 +44,16 @@ namespace dxvk {
 
     LowLatencyMode(Mode mode, LatencyMarkersStorage* storage, const DxvkOptions& options)
     : FramePacerMode(mode, storage),
-      m_lowLatencyOffset(getLowLatencyOffset(options)),
-      m_allowCpuFramesOverlap(getLowLatencyAllowCpuFramesOverlap(options)) {
+      m_lowLatencyOffset(getLowLatencyOffset(options)) {
       Logger::info( str::format("Using lowLatencyOffset: ", m_lowLatencyOffset) );
-      Logger::info( str::format("Using lowLatencyAllowCpuFramesOverlap: ", m_allowCpuFramesOverlap) );
     }
 
     ~LowLatencyMode() {}
 
 
     void startFrame( uint64_t frameId ) override {
-      using std::chrono::duration_cast;
 
-      if (!m_allowCpuFramesOverlap)
-        m_fenceCsFinished.wait( frameId-1 );
+      using std::chrono::duration_cast;
 
       m_fenceGpuStart.wait( frameId-1 );
 
@@ -249,10 +245,7 @@ namespace dxvk {
 
 
     int32_t getLowLatencyOffset( const DxvkOptions& options );
-    bool getLowLatencyAllowCpuFramesOverlap( const DxvkOptions& options );
-
     const int32_t m_lowLatencyOffset;
-    const bool    m_allowCpuFramesOverlap;
 
     Sleep::TimePoint m_lastStart = { high_resolution_clock::now() };
     std::array<SyncProps, 16> m_props;

From 869cf25f7f2b23467c7bb31f22112684142f8e6f Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Sun, 23 Feb 2025 15:09:59 +0100
Subject: [PATCH 09/81] [dxvk] Optimize GPU start measurement for low-latency
 frame pacing

In practice, this change affects oversubscribed threading situations where waking up the "dxvk-queue" thread potentially can cause delays in the 100s of microseconds. For a lot of situations this change isn't affecting measurements in a meaningful way. Possibly affects AMD where vkQueueSubmit execution time is non-zero.
---
 src/dxvk/framepacer/dxvk_framepacer.cpp |  4 +++-
 src/dxvk/framepacer/dxvk_framepacer.h   | 13 ++++---------
 2 files changed, 7 insertions(+), 10 deletions(-)

diff --git a/src/dxvk/framepacer/dxvk_framepacer.cpp b/src/dxvk/framepacer/dxvk_framepacer.cpp
index 63803f1bac0..c520d854d3e 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.cpp
+++ b/src/dxvk/framepacer/dxvk_framepacer.cpp
@@ -54,8 +54,10 @@ namespace dxvk {
     }
 
     // be consistent that every frame has a gpuReady event from the previous frame
-    LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(DXGI_MAX_SWAP_CHAIN_BUFFERS+1);
+    uint64_t firstFrameId = DXGI_MAX_SWAP_CHAIN_BUFFERS+1;
+    LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(firstFrameId);
     m->gpuReady.push_back(high_resolution_clock::now());
+    m_gpuStarts[ firstFrameId % m_gpuStarts.size() ] = gpuReadyBit;
   }
 
 
diff --git a/src/dxvk/framepacer/dxvk_framepacer.h b/src/dxvk/framepacer/dxvk_framepacer.h
index 0028e1353d6..f3e047195dd 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.h
+++ b/src/dxvk/framepacer/dxvk_framepacer.h
@@ -34,13 +34,13 @@ namespace dxvk {
       // potentially wait some more if the cpu gets too much ahead
       m_mode->startFrame(frameId);
       m_latencyMarkersStorage.registerFrameStart(frameId);
-      m_gpuStarts[ frameId % m_gpuStarts.size() ].store(0);
     }
 
     void notifyGpuPresentEnd( uint64_t frameId ) override {
       // the frame has been displayed to the screen
       m_latencyMarkersStorage.registerFrameEnd(frameId);
       m_mode->endFrame(frameId);
+      m_gpuStarts[ (frameId-1) % m_gpuStarts.size() ].store(0);
     }
 
     void notifyCsRenderBegin( uint64_t frameId ) override {
@@ -95,12 +95,6 @@ namespace dxvk {
       }
     }
 
-    void notifyGpuExecutionBegin( uint64_t frameId ) override {
-      assert( frameId == m_lastFinishedFrameId+1 );
-      LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(m_lastFinishedFrameId+1);
-      gpuExecutionCheckGpuStart(frameId, m, high_resolution_clock::now());
-    }
-
     void notifyGpuExecutionEnd( uint64_t frameId ) override {
       auto now = high_resolution_clock::now();
       LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(m_lastFinishedFrameId+1);
@@ -120,7 +114,7 @@ namespace dxvk {
         next->gpuReady.clear();
         next->gpuReady.push_back(now);
 
-        gpuExecutionCheckGpuStart(frameId, m, now);
+        gpuExecutionCheckGpuStart(frameId+1, next, now);
 
         m_latencyMarkersStorage.m_timeline.gpuFinished.store(frameId);
         m_mode->finishRender(frameId);
@@ -149,6 +143,7 @@ namespace dxvk {
     void notifyCpuPresentBegin( uint64_t frameId) override { }
     void notifyCpuPresentEnd( uint64_t frameId ) override { }
     void notifyQueuePresentEnd( uint64_t frameId, VkResult status) override { }
+    void notifyGpuExecutionBegin( uint64_t frameId ) override { }
     void discardTimings() override { }
     DxvkLatencyStats getStatistics( uint64_t frameId ) override
       { return DxvkLatencyStats(); }
@@ -181,7 +176,7 @@ namespace dxvk {
     uint64_t m_lastQueueSubmitFrameId = { DXGI_MAX_SWAP_CHAIN_BUFFERS };
     uint64_t m_lastFinishedFrameId    = { DXGI_MAX_SWAP_CHAIN_BUFFERS };
 
-    std::array< std::atomic< uint16_t >, 16 > m_gpuStarts = { };
+    std::array< std::atomic< uint16_t >, 8 > m_gpuStarts = { };
     static constexpr uint16_t queueSubmitBit = 1;
     static constexpr uint16_t gpuReadyBit    = 2;
 

From 3720d3e0e8a0aaafed9ebeb5381dca1ee95a1361 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Sun, 23 Feb 2025 15:25:34 +0100
Subject: [PATCH 10/81] [dxvk] Removed redundant frameId tracking in frame
 pacer

---
 src/dxvk/dxvk_latency.h               |  3 ++-
 src/dxvk/dxvk_queue.cpp               |  2 +-
 src/dxvk/framepacer/dxvk_framepacer.h | 14 +++-----------
 3 files changed, 6 insertions(+), 13 deletions(-)

diff --git a/src/dxvk/dxvk_latency.h b/src/dxvk/dxvk_latency.h
index f4e74a7cecd..f886e065cfb 100644
--- a/src/dxvk/dxvk_latency.h
+++ b/src/dxvk/dxvk_latency.h
@@ -128,7 +128,8 @@ namespace dxvk {
     virtual void notifyCpuPresentEnd(
             uint64_t                  frameId) = 0;
 
-    virtual void notifySubmit() { }
+    virtual void notifySubmit(
+            uint64_t                  frameId) { }
     virtual void notifyPresent(
             uint64_t                  frameId) { }
 
diff --git a/src/dxvk/dxvk_queue.cpp b/src/dxvk/dxvk_queue.cpp
index 0c74428a0b5..0ddf05c8faf 100644
--- a/src/dxvk/dxvk_queue.cpp
+++ b/src/dxvk/dxvk_queue.cpp
@@ -48,7 +48,7 @@ namespace dxvk {
           DxvkLatencyInfo           latencyInfo,
           DxvkSubmitStatus*         status) {
     if (latencyInfo.tracker)
-      latencyInfo.tracker->notifySubmit();
+      latencyInfo.tracker->notifySubmit(latencyInfo.frameId);
     std::unique_lock<dxvk::mutex> lock(m_mutex);
 
     m_finishCond.wait(lock, [this] {
diff --git a/src/dxvk/framepacer/dxvk_framepacer.h b/src/dxvk/framepacer/dxvk_framepacer.h
index f3e047195dd..1a8cf63f307 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.h
+++ b/src/dxvk/framepacer/dxvk_framepacer.h
@@ -55,8 +55,8 @@ namespace dxvk {
       m->csFinished = std::chrono::duration_cast<microseconds>(now - m->start).count();
     }
 
-    void notifySubmit() override {
-      LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(m_lastSubmitFrameId+1);
+    void notifySubmit( uint64_t frameId ) override {
+      LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
       m->gpuSubmit.push_back(high_resolution_clock::now());
     }
 
@@ -64,7 +64,6 @@ namespace dxvk {
       // dx to vk translation is finished
       if (frameId != 0) {
         auto now = high_resolution_clock::now();
-        m_lastSubmitFrameId = frameId;
         LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
         LatencyMarkers* next = m_latencyMarkersStorage.getMarkers(frameId+1);
         m->gpuSubmit.push_back(now);
@@ -76,7 +75,6 @@ namespace dxvk {
     }
 
     void notifyQueueSubmit( uint64_t frameId ) override {
-      assert( frameId == m_lastQueueSubmitFrameId + 1 );
       auto now = high_resolution_clock::now();
       LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
       m->gpuQueueSubmit.push_back(now);
@@ -86,7 +84,6 @@ namespace dxvk {
     void notifyQueuePresentBegin( uint64_t frameId ) override {
       if (frameId != 0) {
         auto now = high_resolution_clock::now();
-        m_lastQueueSubmitFrameId = frameId;
         LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
         LatencyMarkers* next = m_latencyMarkersStorage.getMarkers(frameId+1);
         m->gpuQueueSubmit.push_back(now);
@@ -97,14 +94,13 @@ namespace dxvk {
 
     void notifyGpuExecutionEnd( uint64_t frameId ) override {
       auto now = high_resolution_clock::now();
-      LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(m_lastFinishedFrameId+1);
+      LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
       m->gpuReady.push_back(now);
     }
 
     virtual void notifyGpuPresentBegin( uint64_t frameId ) override {
       // we get frameId == 0 for repeated presents (SyncInterval)
       if (frameId != 0) {
-        m_lastFinishedFrameId = frameId;
         auto now = high_resolution_clock::now();
 
         LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
@@ -172,10 +168,6 @@ namespace dxvk {
 
     std::unique_ptr<FramePacerMode> m_mode;
 
-    uint64_t m_lastSubmitFrameId      = { DXGI_MAX_SWAP_CHAIN_BUFFERS };
-    uint64_t m_lastQueueSubmitFrameId = { DXGI_MAX_SWAP_CHAIN_BUFFERS };
-    uint64_t m_lastFinishedFrameId    = { DXGI_MAX_SWAP_CHAIN_BUFFERS };
-
     std::array< std::atomic< uint16_t >, 8 > m_gpuStarts = { };
     static constexpr uint16_t queueSubmitBit = 1;
     static constexpr uint16_t gpuReadyBit    = 2;

From bee72c27c86baa2fdd231a4b1350cb0c2d73bbf8 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Sun, 23 Feb 2025 23:07:52 +0100
Subject: [PATCH 11/81] [dxvk] Improve robustness of frame pacer initialization

In d3d9 there were situations where the first frameId was 22, although in d3d11 it always started at 17. This did cause issues especially when waiting for fences which didn't get signaled for these frameIds.
---
 src/d3d9/d3d9_swapchain.cpp             |  2 +-
 src/dxvk/dxvk_device.cpp                |  7 ++++---
 src/dxvk/dxvk_device.h                  |  3 ++-
 src/dxvk/framepacer/dxvk_framepacer.cpp | 18 +++++++++++++-----
 src/dxvk/framepacer/dxvk_framepacer.h   |  2 +-
 5 files changed, 21 insertions(+), 11 deletions(-)

diff --git a/src/d3d9/d3d9_swapchain.cpp b/src/d3d9/d3d9_swapchain.cpp
index 4ab616ed7bc..b858df2aff4 100644
--- a/src/d3d9/d3d9_swapchain.cpp
+++ b/src/d3d9/d3d9_swapchain.cpp
@@ -987,7 +987,7 @@ namespace dxvk {
       entry->second.presenter = CreatePresenter(m_window, entry->second.frameLatencySignal);
 
       if (m_presentParams.hDeviceWindow == m_window && m_latencyTracking)
-        m_latencyTracker = m_device->createLatencyTracker(entry->second.presenter);
+        m_latencyTracker = m_device->createLatencyTracker(entry->second.presenter, entry->second.frameId+1);
     }
 
     m_wctx = &entry->second;
diff --git a/src/dxvk/dxvk_device.cpp b/src/dxvk/dxvk_device.cpp
index cdb59e6c774..b05acf03453 100644
--- a/src/dxvk/dxvk_device.cpp
+++ b/src/dxvk/dxvk_device.cpp
@@ -309,15 +309,16 @@ namespace dxvk {
 
 
   Rc<DxvkLatencyTracker> DxvkDevice::createLatencyTracker(
-    const Rc<Presenter>&            presenter) {
+    const Rc<Presenter>&            presenter,
+    uint64_t                        firstFrameId ) {
     if (m_options.latencySleep == Tristate::False)
-      return new FramePacer(m_options);
+      return new FramePacer(m_options, firstFrameId);
 
     if (m_options.latencySleep == Tristate::Auto) {
       if (m_features.nvLowLatency2)
         return new DxvkReflexLatencyTrackerNv(presenter);
       else
-        return new FramePacer(m_options);
+        return new FramePacer(m_options, firstFrameId);
     }
 
     return new DxvkBuiltInLatencyTracker(presenter,
diff --git a/src/dxvk/dxvk_device.h b/src/dxvk/dxvk_device.h
index 2ec517c2e2a..859b3029754 100644
--- a/src/dxvk/dxvk_device.h
+++ b/src/dxvk/dxvk_device.h
@@ -489,7 +489,8 @@ namespace dxvk {
      * \param [in] presenter Presenter instance
      */
     Rc<DxvkLatencyTracker> createLatencyTracker(
-      const Rc<Presenter>&            presenter);
+      const Rc<Presenter>&            presenter,
+      uint64_t                        firstFrameId = 17);
 
     /**
      * \brief Presents a swap chain image
diff --git a/src/dxvk/framepacer/dxvk_framepacer.cpp b/src/dxvk/framepacer/dxvk_framepacer.cpp
index c520d854d3e..a71b2d31dea 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.cpp
+++ b/src/dxvk/framepacer/dxvk_framepacer.cpp
@@ -8,7 +8,7 @@
 namespace dxvk {
 
 
-  FramePacer::FramePacer( const DxvkOptions& options ) {
+  FramePacer::FramePacer( const DxvkOptions& options, uint64_t firstFrameId ) {
     // we'll default to LOW_LATENCY in the draft-PR for now, for demonstration purposes,
     // highlighting the generally much better input lag and medium-term time consistency.
     // although MAX_FRAME_LATENCY has advantages in many games and is likely the better default,
@@ -53,11 +53,19 @@ namespace dxvk {
       gpuStart.store(0);
     }
 
-    // be consistent that every frame has a gpuReady event from the previous frame
-    uint64_t firstFrameId = DXGI_MAX_SWAP_CHAIN_BUFFERS+1;
-    LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(firstFrameId);
-    m->gpuReady.push_back(high_resolution_clock::now());
+    // be consistent that every frame has a gpuReady event from finishing the previous frame
+    LatencyMarkers* m = m_latencyMarkersStorage.getMarkers( firstFrameId );
+    m->gpuReady.push_back( high_resolution_clock::now() );
     m_gpuStarts[ firstFrameId % m_gpuStarts.size() ] = gpuReadyBit;
+
+    LatencyMarkersTimeline& timeline = m_latencyMarkersStorage.m_timeline;
+    timeline.cpuFinished.store   ( firstFrameId-1 );
+    timeline.gpuStart.store      ( firstFrameId-1 );
+    timeline.gpuFinished.store   ( firstFrameId-1 );
+    timeline.frameFinished.store ( firstFrameId-1 );
+
+    m_mode->signalGpuStart       ( firstFrameId-1 );
+    m_mode->signalRenderFinished ( firstFrameId-1 );
   }
 
 
diff --git a/src/dxvk/framepacer/dxvk_framepacer.h b/src/dxvk/framepacer/dxvk_framepacer.h
index 1a8cf63f307..38d740d1aa9 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.h
+++ b/src/dxvk/framepacer/dxvk_framepacer.h
@@ -23,7 +23,7 @@ namespace dxvk {
     using microseconds = std::chrono::microseconds;
   public:
 
-    FramePacer( const DxvkOptions& options );
+    FramePacer( const DxvkOptions& options, uint64_t firstFrameId );
     ~FramePacer();
 
     void sleepAndBeginFrame(

From 0d018451fd5027140e8a9b86cf9cc0329c8a158e Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Fri, 28 Feb 2025 08:05:46 +0100
Subject: [PATCH 12/81] [dxvk] Optimize flush heuristic for low-latency

Possibly can be optimized more, but just changing these numbers already had a huge effect, especially for games having a small number of submissions to begin with.
---
 src/dxvk/framepacer/dxvk_framepacer.cpp |  5 +++++
 src/dxvk/framepacer/dxvk_framepacer.h   |  2 +-
 src/util/util_flush.cpp                 | 16 ++++++++--------
 src/util/util_flush.h                   |  5 +++++
 4 files changed, 19 insertions(+), 9 deletions(-)

diff --git a/src/dxvk/framepacer/dxvk_framepacer.cpp b/src/dxvk/framepacer/dxvk_framepacer.cpp
index a71b2d31dea..944476817e2 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.cpp
+++ b/src/dxvk/framepacer/dxvk_framepacer.cpp
@@ -2,6 +2,7 @@
 #include "dxvk_framepacer_mode_low_latency.h"
 #include "dxvk_framepacer_mode_min_latency.h"
 #include "dxvk_options.h"
+#include "../../util/util_flush.h"
 #include "../../util/util_env.h"
 #include "../../util/log/log.h"
 
@@ -40,11 +41,15 @@ namespace dxvk {
 
       case FramePacerMode::LOW_LATENCY:
         Logger::info( "Frame pace: low-latency" );
+        GpuFlushTracker::m_minPendingSubmissions = 1;
+        GpuFlushTracker::m_minChunkCount = 1;
         m_mode = std::make_unique<LowLatencyMode>(mode, &m_latencyMarkersStorage, options);
         break;
 
       case FramePacerMode::MIN_LATENCY:
         Logger::info( "Frame pace: min-latency" );
+        GpuFlushTracker::m_minPendingSubmissions = 1;
+        GpuFlushTracker::m_minChunkCount = 1;
         m_mode = std::make_unique<MinLatencyMode>(mode, &m_latencyMarkersStorage);
         break;
     }
diff --git a/src/dxvk/framepacer/dxvk_framepacer.h b/src/dxvk/framepacer/dxvk_framepacer.h
index 38d740d1aa9..2ae4b76e84c 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.h
+++ b/src/dxvk/framepacer/dxvk_framepacer.h
@@ -136,7 +136,7 @@ namespace dxvk {
     // not implemented methods
 
 
-    void notifyCpuPresentBegin( uint64_t frameId) override { }
+    void notifyCpuPresentBegin( uint64_t frameId ) override { }
     void notifyCpuPresentEnd( uint64_t frameId ) override { }
     void notifyQueuePresentEnd( uint64_t frameId, VkResult status) override { }
     void notifyGpuExecutionBegin( uint64_t frameId ) override { }
diff --git a/src/util/util_flush.cpp b/src/util/util_flush.cpp
index 17d2669010b..4a2cd854bff 100644
--- a/src/util/util_flush.cpp
+++ b/src/util/util_flush.cpp
@@ -2,6 +2,10 @@
 
 namespace dxvk {
 
+  std::atomic<uint32_t> GpuFlushTracker::m_minPendingSubmissions = { 2 };
+  std::atomic<uint32_t> GpuFlushTracker::m_minChunkCount         = { 3 };
+  std::atomic<uint32_t> GpuFlushTracker::m_maxChunkCount         = { 20 };
+
   GpuFlushTracker::GpuFlushTracker(GpuFlushType maxType)
   : m_maxType(maxType) {
 
@@ -11,10 +15,6 @@ namespace dxvk {
           GpuFlushType          flushType,
           uint64_t              chunkId,
           uint32_t              lastCompleteSubmissionId) {
-    constexpr uint32_t minPendingSubmissions = 2;
-
-    constexpr uint32_t minChunkCount =  3u;
-    constexpr uint32_t maxChunkCount = 20u;
 
     // Do not flush if there is nothing to flush
     uint32_t chunkCount = uint32_t(chunkId - m_lastFlushChunkId);
@@ -42,14 +42,14 @@ namespace dxvk {
 
       case GpuFlushType::ImplicitStrongHint: {
         // Flush aggressively with a strong hint to reduce readback latency.
-        return chunkCount >= minChunkCount;
+        return chunkCount >= m_minChunkCount;
       }
 
       case GpuFlushType::ImplicitMediumHint:
       case GpuFlushType::ImplicitWeakHint: {
         // Aim for a higher number of chunks per submission with
         // a weak hint in order to avoid submitting too often.
-        if (chunkCount < 2 * minChunkCount)
+        if (chunkCount < 2 * m_minChunkCount)
           return false;
 
         // Actual heuristic is shared with synchronization commands
@@ -60,13 +60,13 @@ namespace dxvk {
         // required if the application is spinning on a query or resource.
         uint32_t pendingSubmissions = uint32_t(m_lastFlushSubmissionId - lastCompleteSubmissionId);
 
-        if (pendingSubmissions < minPendingSubmissions)
+        if (pendingSubmissions < m_minPendingSubmissions)
           return true;
 
         // Use the number of pending submissions to decide whether to flush. Other
         // than ignoring the minimum chunk count condition, we should treat this
         // the same as weak hints to avoid unnecessary synchronization.
-        uint32_t threshold = std::min(maxChunkCount, pendingSubmissions * minChunkCount);
+        uint32_t threshold = std::min(m_maxChunkCount.load(), pendingSubmissions * m_minChunkCount.load());
         return chunkCount >= threshold;
       }
     }
diff --git a/src/util/util_flush.h b/src/util/util_flush.h
index 5d593649d86..8673f404fe6 100644
--- a/src/util/util_flush.h
+++ b/src/util/util_flush.h
@@ -3,6 +3,7 @@
 #include <cstddef>
 #include <cstdint>
 #include <vector>
+#include <atomic>
 
 namespace dxvk {
 
@@ -64,6 +65,10 @@ namespace dxvk {
             uint64_t              chunkId,
             uint64_t              submissionId);
 
+    static std::atomic<uint32_t> m_minPendingSubmissions;
+    static std::atomic<uint32_t> m_minChunkCount;
+    static std::atomic<uint32_t> m_maxChunkCount;
+
   private:
 
     GpuFlushType  m_maxType               = GpuFlushType::ImplicitWeakHint;

From 91c6793b559becd442b86ca4d5be07b67745cf5b Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Fri, 28 Feb 2025 08:37:11 +0100
Subject: [PATCH 13/81] [dxvk] Disallow flush for beginLatencyTracking's emitCs

Not sure if this does anything, but better be safe to correctly track when the first succeeding Cs will get executed.
---
 src/d3d11/d3d11_context.h     | 5 +++--
 src/d3d11/d3d11_swapchain.cpp | 2 +-
 src/d3d9/d3d9_device.cpp      | 2 +-
 src/d3d9/d3d9_device.h        | 5 +++--
 4 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/src/d3d11/d3d11_context.h b/src/d3d11/d3d11_context.h
index a2d6c365982..76b4d7811d9 100644
--- a/src/d3d11/d3d11_context.h
+++ b/src/d3d11/d3d11_context.h
@@ -1084,7 +1084,7 @@ namespace dxvk {
             UINT                              SampleMask);
 
     template<bool AllowFlush = !IsDeferred, typename Cmd>
-    void EmitCs(Cmd&& command) {
+    void EmitCs(Cmd&& command, bool disableFlush=false ) {
       m_cmdData = nullptr;
 
       if (unlikely(!m_csChunk->push(command))) {
@@ -1092,7 +1092,8 @@ namespace dxvk {
         m_csChunk = AllocCsChunk();
 
         if constexpr (AllowFlush)
-          GetTypedContext()->ConsiderFlush(GpuFlushType::ImplicitWeakHint);
+          if (!disableFlush)
+            GetTypedContext()->ConsiderFlush(GpuFlushType::ImplicitWeakHint);
 
         m_csChunk->push(command);
       }
diff --git a/src/d3d11/d3d11_swapchain.cpp b/src/d3d11/d3d11_swapchain.cpp
index e2100eb8d73..3eb6363092d 100644
--- a/src/d3d11/d3d11_swapchain.cpp
+++ b/src/d3d11/d3d11_swapchain.cpp
@@ -472,7 +472,7 @@ namespace dxvk {
           cFrameId = m_frameId
         ] (DxvkContext* ctx) {
           ctx->beginLatencyTracking(cLatency, cFrameId + 1u);
-        });
+        }, true);
       }
     }
 
diff --git a/src/d3d9/d3d9_device.cpp b/src/d3d9/d3d9_device.cpp
index f704723db7a..8d4b86826d9 100644
--- a/src/d3d9/d3d9_device.cpp
+++ b/src/d3d9/d3d9_device.cpp
@@ -6129,7 +6129,7 @@ namespace dxvk {
     ] (DxvkContext* ctx) {
       if (cTracker && cTracker->needsAutoMarkers())
         ctx->beginLatencyTracking(cTracker, cFrameId);
-    });
+    }, true);
   }
 
 
diff --git a/src/d3d9/d3d9_device.h b/src/d3d9/d3d9_device.h
index 3a2a4184dcd..88a60a4b75c 100644
--- a/src/d3d9/d3d9_device.h
+++ b/src/d3d9/d3d9_device.h
@@ -1180,13 +1180,14 @@ namespace dxvk {
   private:
 
     template<bool AllowFlush = true, typename Cmd>
-    void EmitCs(Cmd&& command) {
+    void EmitCs(Cmd&& command, bool disableFlush=false) {
       if (unlikely(!m_csChunk->push(command))) {
         EmitCsChunk(std::move(m_csChunk));
         m_csChunk = AllocCsChunk();
 
         if constexpr (AllowFlush)
-          ConsiderFlush(GpuFlushType::ImplicitWeakHint);
+          if (!disableFlush)
+            ConsiderFlush(GpuFlushType::ImplicitWeakHint);
 
         m_csChunk->push(command);
       }

From 988dcdc08c241d874fb1f91ec3c0767f1017d09d Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Fri, 28 Feb 2025 08:39:40 +0100
Subject: [PATCH 14/81] [dxvk] Improve low-latency frame pacing when gpuStart
 gets signaled earlier than expected

---
 .../dxvk_framepacer_mode_low_latency.h        | 32 ++++---------------
 1 file changed, 6 insertions(+), 26 deletions(-)

diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index 2d17df1c7a4..9193f438e57 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -79,8 +79,10 @@ namespace dxvk {
       // and calculate backwards when we want to start this frame
 
       const SyncProps props = getSyncPrediction();
-      int32_t gpuReadyPrediction = duration_cast<microseconds>(
-        m->start + microseconds(m->gpuStart+getGpuStartToFinishPrediction()) - now).count();
+      int32_t lastFrameStart = duration_cast<microseconds>( m->start - now ).count();
+      int32_t gpuReadyPrediction = lastFrameStart
+        + std::max( props.cpuUntilGpuStart, m->gpuStart )
+        + props.optimizedGpuTime;
 
       int32_t targetGpuSync = gpuReadyPrediction + props.gpuSync;
       int32_t gpuDelay = targetGpuSync - props.cpuUntilGpuSync;
@@ -144,6 +146,7 @@ namespace dxvk {
       SyncProps& props = m_props[frameId % m_props.size()];
       props.gpuSync = gpuRun[numLoop-1];
       props.cpuUntilGpuSync = offset + duration_cast<microseconds>( m->gpuSubmit[numLoop-1] - m->start ).count();
+      props.cpuUntilGpuStart = props.cpuUntilGpuSync - props.gpuSync;
       props.optimizedGpuTime = optimizedGpuTime;
       props.csStart = m->csStart;
       props.csFinished = m->csFinished;
@@ -176,6 +179,7 @@ namespace dxvk {
       int32_t optimizedGpuTime;   // gpu executing packed submits in one go
       int32_t gpuSync;            // us after gpuStart
       int32_t cpuUntilGpuSync;
+      int32_t cpuUntilGpuStart;
       int32_t csStart;
       int32_t csFinished;
       bool    isOutlier;
@@ -203,30 +207,6 @@ namespace dxvk {
     };
 
 
-    int32_t getGpuStartToFinishPrediction() {
-      uint64_t id = m_propsFinished;
-      if (id < DXGI_MAX_SWAP_CHAIN_BUFFERS+7)
-        return 0;
-
-      for (size_t i=0; i<7; ++i) {
-        const SyncProps& props = m_props[ (id-i) % m_props.size() ];
-        if (!props.isOutlier) {
-          const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(id-i);
-          if (m->gpuReady.empty() || m->gpuSubmit.empty())
-            return m->gpuFinished - m->gpuStart;
-
-          time_point t = std::max( m->gpuReady[0], m->gpuSubmit[0] );
-          return std::chrono::duration_cast<microseconds>( t - m->start ).count()
-            + props.optimizedGpuTime
-            - m->gpuStart;
-        }
-      }
-
-      const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(id);
-      return m->gpuFinished - m->gpuStart;
-    };
-
-
     bool isOutlier( uint64_t frameId ) {
       constexpr size_t numLoop = 7;
       int32_t totalCpuTime = 0;

From fd68a08572d2be961294c323e6487720eb191ab2 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Fri, 28 Feb 2025 08:48:36 +0100
Subject: [PATCH 15/81] [dxvk] Improve handling of cpu-frametime related
 stutters for low-latency frame pacing

Stutters less this way because we increase the sensitivity to mark frames as outliers, so that they don't get used for predicting the next frame. The actual "optimal" threshold is still to be fine-tuned, but this one worked really well.
---
 .../dxvk_framepacer_mode_low_latency.h        | 23 ++++++++++---------
 1 file changed, 12 insertions(+), 11 deletions(-)

diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index 9193f438e57..24d8ab60e18 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -116,9 +116,7 @@ namespace dxvk {
       // where gpuSubmit[i] <= gpuRun[i] for all i
 
       std::vector<int32_t>& gpuRun = m_tempGpuRun;
-      std::vector<int32_t>& gpuRunDurations = m_tempGpuRunDurations;
       gpuRun.clear();
-      gpuRunDurations.clear();
       int32_t optimizedGpuTime = 0;
       gpuRun.push_back(optimizedGpuTime);
 
@@ -127,7 +125,6 @@ namespace dxvk {
         int32_t duration = duration_cast<microseconds>( m->gpuReady[i+1] - _gpuRun ).count();
         optimizedGpuTime += duration;
         gpuRun.push_back(optimizedGpuTime);
-        gpuRunDurations.push_back(duration);
       }
 
       int32_t alignment = duration_cast<microseconds>( m->gpuSubmit[numLoop-1] - m->gpuSubmit[0] ).count()
@@ -177,7 +174,7 @@ namespace dxvk {
 
     struct SyncProps {
       int32_t optimizedGpuTime;   // gpu executing packed submits in one go
-      int32_t gpuSync;            // us after gpuStart
+      int32_t gpuSync;            // gpuStart to this sync point, in microseconds
       int32_t cpuUntilGpuSync;
       int32_t cpuUntilGpuStart;
       int32_t csStart;
@@ -187,9 +184,14 @@ namespace dxvk {
 
 
     SyncProps getSyncPrediction() {
-      // in the future we might use more samples to get a prediction
-      // however, simple averaging gives a slightly artificial mouse input
-      // more advanced methods will be investigated
+      // In the future we might use more samples to get a prediction.
+      // Possibly this will be optional, as until now, basing it on
+      // just the previous frame gave us the best mouse input feel.
+      // Simple averaging or median filtering is surely not the way
+      // to go, but more advanced methods will be investigated.
+      // The best place to filter should be on the Present() timeline,
+      // so not sure if we really will do any filtering here other
+      // than outlier removal, which will dampen stuttering effects.
       SyncProps res = {};
       uint64_t id = m_propsFinished;
       if (id < DXGI_MAX_SWAP_CHAIN_BUFFERS+7)
@@ -210,14 +212,14 @@ namespace dxvk {
     bool isOutlier( uint64_t frameId ) {
       constexpr size_t numLoop = 7;
       int32_t totalCpuTime = 0;
-      for (size_t i=0; i<numLoop; ++i) {
+      for (size_t i=1; i<numLoop; ++i) {
         const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(frameId-i);
         totalCpuTime += m->cpuFinished;
       }
 
-      int32_t avgCpuTime = totalCpuTime / numLoop;
+      int32_t avgCpuTime = totalCpuTime / (numLoop-1);
       const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(frameId);
-      if (m->cpuFinished > 1.7*avgCpuTime || m->gpuSubmit.empty() || m->gpuReady.size() != (m->gpuSubmit.size()+1) )
+      if (m->cpuFinished > 1.3*avgCpuTime || m->gpuSubmit.empty() || m->gpuReady.size() != (m->gpuSubmit.size()+1) )
         return true;
 
       return false;
@@ -232,7 +234,6 @@ namespace dxvk {
     std::atomic<uint64_t> m_propsFinished = { 0 };
 
     std::vector<int32_t>  m_tempGpuRun;
-    std::vector<int32_t>  m_tempGpuRunDurations;
 
   };
 

From 775b3dfe715859bf0031ad9531938ebaf5670312 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Fri, 28 Feb 2025 11:23:02 +0100
Subject: [PATCH 16/81] Revert "[dxvk] Remove
 dxvk.lowLatencyAllowCpuFramesOverlap config variable"

This reverts commit c802bdf42e993b467f8fa18b2db52da5841164d1 and makes small adjustments.
Until we have a proper synchronization in place between emitting Cs triggered by the app thread, and fetching them from the queue, to measure the CsThread-caused delay, this config option is still useful for running some rare CsThread-limited games.
---
 src/dxvk/dxvk_options.cpp                     |  2 ++
 src/dxvk/framepacer/dxvk_framepacer.cpp       |  1 +
 src/dxvk/framepacer/dxvk_framepacer.h         |  1 +
 src/dxvk/framepacer/dxvk_framepacer_mode.h    |  4 ++++
 .../dxvk_framepacer_mode_low_latency.cpp      | 19 +++++++++++++++++++
 .../dxvk_framepacer_mode_low_latency.h        | 11 +++++++++--
 6 files changed, 36 insertions(+), 2 deletions(-)

diff --git a/src/dxvk/dxvk_options.cpp b/src/dxvk/dxvk_options.cpp
index a31778e18cc..85fc3ec3e4c 100644
--- a/src/dxvk/dxvk_options.cpp
+++ b/src/dxvk/dxvk_options.cpp
@@ -20,6 +20,8 @@ namespace dxvk {
     allowFse              = config.getOption<bool>    ("dxvk.allowFse",               false);
     framePace             = config.getOption<std::string>("dxvk.framePace",           "");
     lowLatencyOffset      = config.getOption<int32_t> ("dxvk.lowLatencyOffset",       0);
+    lowLatencyAllowCpuFramesOverlap
+                          = config.getOption<bool>    ("dxvk.lowLatencyAllowCpuFramesOverlap", true);
     deviceFilter          = config.getOption<std::string>("dxvk.deviceFilter",        "");
     tilerMode             = config.getOption<Tristate>("dxvk.tilerMode",              Tristate::Auto);
   }
diff --git a/src/dxvk/framepacer/dxvk_framepacer.cpp b/src/dxvk/framepacer/dxvk_framepacer.cpp
index 944476817e2..3ff8791a965 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.cpp
+++ b/src/dxvk/framepacer/dxvk_framepacer.cpp
@@ -71,6 +71,7 @@ namespace dxvk {
 
     m_mode->signalGpuStart       ( firstFrameId-1 );
     m_mode->signalRenderFinished ( firstFrameId-1 );
+    m_mode->signalCsFinished     ( firstFrameId );
   }
 
 
diff --git a/src/dxvk/framepacer/dxvk_framepacer.h b/src/dxvk/framepacer/dxvk_framepacer.h
index 2ae4b76e84c..0d5befc02d8 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.h
+++ b/src/dxvk/framepacer/dxvk_framepacer.h
@@ -53,6 +53,7 @@ namespace dxvk {
       auto now = high_resolution_clock::now();
       LatencyMarkers* m = m_latencyMarkersStorage.getMarkers(frameId);
       m->csFinished = std::chrono::duration_cast<microseconds>(now - m->start).count();
+      m_mode->signalCsFinished( frameId );
     }
 
     void notifySubmit( uint64_t frameId ) override {
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode.h b/src/dxvk/framepacer/dxvk_framepacer_mode.h
index 2109bd57b78..98404ee71bd 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode.h
@@ -44,6 +44,9 @@ namespace dxvk {
     void signalGpuStart( uint64_t frameId ) {
       if (m_mode) m_fenceGpuStart.signal(frameId); }
 
+    void signalCsFinished( uint64_t frameId ) {
+      if (m_mode) m_fenceCsFinished.signal(frameId); }
+
     void setTargetFrameRate( double frameRate ) {
       if (!m_fpsLimitEnvOverride && frameRate > 1.0)
         m_fpsLimitFrametime.store( 1'000'000/frameRate );
@@ -65,6 +68,7 @@ namespace dxvk {
 
     sync::Fence m_fenceGpuStart    = { sync::Fence(DXGI_MAX_SWAP_CHAIN_BUFFERS) };
     sync::Fence m_fenceGpuFinished = { sync::Fence(DXGI_MAX_SWAP_CHAIN_BUFFERS) };
+    sync::Fence m_fenceCsFinished  = { sync::Fence(DXGI_MAX_SWAP_CHAIN_BUFFERS) };
 
   };
 
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
index 4af77f0519b..4e39145b4c3 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
@@ -10,6 +10,15 @@ namespace dxvk {
   }
 
 
+  bool getLowLatencyAllowCpuFramesOverlapFromEnv( bool& allowOverlap ) {
+    int32_t o;
+    if (!FramePacerMode::getIntFromEnv("DXVK_LOW_LATENCY_ALLOW_CPU_FRAMES_OVERLAP", &o))
+      return false;
+    allowOverlap = (bool) o;
+    return true;
+  }
+
+
   int32_t LowLatencyMode::getLowLatencyOffset( const DxvkOptions& options ) {
     int32_t offset = options.lowLatencyOffset;
     int32_t o;
@@ -21,4 +30,14 @@ namespace dxvk {
     return offset;
   }
 
+
+  bool LowLatencyMode::getLowLatencyAllowCpuFramesOverlap( const DxvkOptions& options ) {
+    bool allowOverlap = options.lowLatencyAllowCpuFramesOverlap;
+    bool o;
+    if (getLowLatencyAllowCpuFramesOverlapFromEnv(o))
+      allowOverlap = o;
+    return allowOverlap;
+  }
+
+
 }
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index 24d8ab60e18..59d10909ef0 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -44,17 +44,21 @@ namespace dxvk {
 
     LowLatencyMode(Mode mode, LatencyMarkersStorage* storage, const DxvkOptions& options)
     : FramePacerMode(mode, storage),
-      m_lowLatencyOffset(getLowLatencyOffset(options)) {
+      m_lowLatencyOffset(getLowLatencyOffset(options)),
+      m_allowCpuFramesOverlap(getLowLatencyAllowCpuFramesOverlap(options)) {
       Logger::info( str::format("Using lowLatencyOffset: ", m_lowLatencyOffset) );
+      Logger::info( str::format("Using lowLatencyAllowCpuFramesOverlap: ", m_allowCpuFramesOverlap) );
     }
 
     ~LowLatencyMode() {}
 
 
     void startFrame( uint64_t frameId ) override {
-
       using std::chrono::duration_cast;
 
+      if (!m_allowCpuFramesOverlap)
+        m_fenceCsFinished.wait( frameId-1 );
+
       m_fenceGpuStart.wait( frameId-1 );
 
       time_point now = high_resolution_clock::now();
@@ -227,7 +231,10 @@ namespace dxvk {
 
 
     int32_t getLowLatencyOffset( const DxvkOptions& options );
+    bool getLowLatencyAllowCpuFramesOverlap( const DxvkOptions& options );
+
     const int32_t m_lowLatencyOffset;
+    const bool    m_allowCpuFramesOverlap;
 
     Sleep::TimePoint m_lastStart = { high_resolution_clock::now() };
     std::array<SyncProps, 16> m_props;

From d84c450b97478d1a23007a3dc0f526e22415e3cd Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Fri, 14 Mar 2025 20:47:14 +0100
Subject: [PATCH 17/81] [dxvk] Call vkWaitForPresentKHR for low-latency frame
 pacing

even when not using a FIFO present mode to match render latency measurements more closely to felt input lag. In a lot of cases the present-delay is negligible when using immediate presentation, but for example on Windows there was a large presentation overhead observed using exclusive fullscreen.

Also for thread-heavy games or other situations where a lot of threads were managed by the scheduler, a higher overhead was observed, although it's not clear to which proportion this comes from the measurement itself because it relies on waking up a thread as well.
---
 src/dxvk/dxvk_presenter.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_presenter.cpp b/src/dxvk/dxvk_presenter.cpp
index 86de77a7315..8977af67fcd 100644
--- a/src/dxvk/dxvk_presenter.cpp
+++ b/src/dxvk/dxvk_presenter.cpp
@@ -3,6 +3,7 @@
 #include "dxvk_device.h"
 #include "dxvk_presenter.h"
 
+#include "framepacer/dxvk_framepacer.h"
 #include "../wsi/wsi_window.h"
 
 namespace dxvk {
@@ -1236,7 +1237,8 @@ namespace dxvk {
       // If the present operation has succeeded, actually wait for it to complete.
       // Don't bother with it on MAILBOX / IMMEDIATE modes since doing so would
       // restrict us to the display refresh rate on some platforms (XWayland).
-      if (frame.result >= 0 && (frame.mode == VK_PRESENT_MODE_FIFO_KHR || frame.mode == VK_PRESENT_MODE_FIFO_RELAXED_KHR)) {
+      if (frame.result >= 0 && (frame.mode == VK_PRESENT_MODE_FIFO_KHR || frame.mode == VK_PRESENT_MODE_FIFO_RELAXED_KHR
+        || (dynamic_cast<FramePacer*>(frame.tracker.ptr()) && dynamic_cast<FramePacer*>(frame.tracker.ptr())->getMode()) )) {
         VkResult vr = m_vkd->vkWaitForPresentKHR(m_vkd->device(),
           m_swapchain, frame.frameId, std::numeric_limits<uint64_t>::max());
 

From 156d16208e33de234dc90e4c9d5ded9020a09d45 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Thu, 12 Jun 2025 12:59:02 +0200
Subject: [PATCH 18/81] [dxvk] Remove dxvk_low_latency_* environment variables

since we can just set them via DXVK_CONFIG as well
---
 .../dxvk_framepacer_mode_low_latency.cpp      | 30 -------------------
 .../dxvk_framepacer_mode_low_latency.h        |  2 +-
 2 files changed, 1 insertion(+), 31 deletions(-)

diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
index 4e39145b4c3..575b52ae286 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
@@ -2,42 +2,12 @@
 
 namespace dxvk {
 
-
-  bool getLowLatencyOffsetFromEnv( int32_t& offset ) {
-    if (!FramePacerMode::getIntFromEnv("DXVK_LOW_LATENCY_OFFSET", &offset))
-      return false;
-    return true;
-  }
-
-
-  bool getLowLatencyAllowCpuFramesOverlapFromEnv( bool& allowOverlap ) {
-    int32_t o;
-    if (!FramePacerMode::getIntFromEnv("DXVK_LOW_LATENCY_ALLOW_CPU_FRAMES_OVERLAP", &o))
-      return false;
-    allowOverlap = (bool) o;
-    return true;
-  }
-
-
   int32_t LowLatencyMode::getLowLatencyOffset( const DxvkOptions& options ) {
     int32_t offset = options.lowLatencyOffset;
-    int32_t o;
-    if (getLowLatencyOffsetFromEnv(o))
-      offset = o;
 
     offset = std::max( -10000, offset );
     offset = std::min(  10000, offset );
     return offset;
   }
 
-
-  bool LowLatencyMode::getLowLatencyAllowCpuFramesOverlap( const DxvkOptions& options ) {
-    bool allowOverlap = options.lowLatencyAllowCpuFramesOverlap;
-    bool o;
-    if (getLowLatencyAllowCpuFramesOverlapFromEnv(o))
-      allowOverlap = o;
-    return allowOverlap;
-  }
-
-
 }
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index 59d10909ef0..03c4b4278ae 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -45,7 +45,7 @@ namespace dxvk {
     LowLatencyMode(Mode mode, LatencyMarkersStorage* storage, const DxvkOptions& options)
     : FramePacerMode(mode, storage),
       m_lowLatencyOffset(getLowLatencyOffset(options)),
-      m_allowCpuFramesOverlap(getLowLatencyAllowCpuFramesOverlap(options)) {
+      m_allowCpuFramesOverlap(options.lowLatencyAllowCpuFramesOverlap) {
       Logger::info( str::format("Using lowLatencyOffset: ", m_lowLatencyOffset) );
       Logger::info( str::format("Using lowLatencyAllowCpuFramesOverlap: ", m_allowCpuFramesOverlap) );
     }

From 4d3902394c9f0978f6310f351e8d28d1e676fcf9 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Fri, 13 Jun 2025 10:04:28 +0200
Subject: [PATCH 19/81] [hud] Mark dxvk version as low-latency in hud and log
 file

---
 src/dxvk/dxvk_instance.cpp     | 2 +-
 src/dxvk/hud/dxvk_hud_item.cpp | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/dxvk/dxvk_instance.cpp b/src/dxvk/dxvk_instance.cpp
index dfd48127ca4..f30e8a4d76f 100644
--- a/src/dxvk/dxvk_instance.cpp
+++ b/src/dxvk/dxvk_instance.cpp
@@ -20,7 +20,7 @@ namespace dxvk {
 
   DxvkInstance::DxvkInstance(const DxvkInstanceImportInfo& args, DxvkInstanceFlags flags) {
     Logger::info(str::format("Game: ", env::getExeName()));
-    Logger::info(str::format("DXVK: ", DXVK_VERSION));
+    Logger::info(str::format("DXVK-LOW-LATENCY: ", DXVK_VERSION));
     Logger::info(str::format("Build: ", DXVK_TARGET, " ", DXVK_COMPILER, " ", DXVK_COMPILER_VERSION));
 
     wsi::init();
diff --git a/src/dxvk/hud/dxvk_hud_item.cpp b/src/dxvk/hud/dxvk_hud_item.cpp
index 61ed1bd2266..6c60bf71b34 100644
--- a/src/dxvk/hud/dxvk_hud_item.cpp
+++ b/src/dxvk/hud/dxvk_hud_item.cpp
@@ -105,7 +105,7 @@ namespace dxvk::hud {
           HudRenderer&        renderer,
           HudPos              position) {
     position.y += 16;
-    renderer.drawText(16, position, 0xffffffffu, "DXVK " DXVK_VERSION);
+    renderer.drawText(16, position, 0xffffffffu, "DXVK-LOW-LATENCY " DXVK_VERSION);
 
     position.y += 8;
     return position;

From b3e47724e251f1fada794f4352d8c68bc97945ca Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Thu, 26 Jun 2025 18:57:09 +0200
Subject: [PATCH 20/81] [dxvk] Add a warning when the user provides a wrong
 frame pace string

---
 src/dxvk/framepacer/dxvk_framepacer.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/dxvk/framepacer/dxvk_framepacer.cpp b/src/dxvk/framepacer/dxvk_framepacer.cpp
index 3ff8791a965..034c75d567b 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.cpp
+++ b/src/dxvk/framepacer/dxvk_framepacer.cpp
@@ -31,6 +31,10 @@ namespace dxvk {
       mode = FramePacerMode::LOW_LATENCY;
     } else if (options.framePace.find("min-latency") != std::string::npos) {
       mode = FramePacerMode::MIN_LATENCY;
+    } else if (!configStr.empty()) {
+      Logger::warn( str::format( "DXVK_FRAME_PACE=", configStr, " unknown" ));
+    } else if (!options.framePace.empty()) {
+      Logger::warn( str::format( "dxvk.framePace = ", options.framePace, " unknown" ));
     }
 
     switch (mode) {

From 917507dcf1a36639fd0a84eedb3bd6a8deea7fb5 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Thu, 26 Jun 2025 19:40:44 +0200
Subject: [PATCH 21/81] [dxvk] Separate render latency and present latency

Allows for better analysis.
This change was needed because the present latency depends on driver and display server. Nvidia for example reports low values on vrr v-sync on x11, medium values on KDE Wayland and high values on Gnome Wayland. On xWayland, it doesn't provide any feedback at all.
---
 src/d3d11/d3d11_swapchain.cpp  |  4 +++
 src/d3d11/d3d11_swapchain.h    |  5 +--
 src/d3d9/d3d9_swapchain.cpp    |  4 +++
 src/d3d9/d3d9_swapchain.h      |  7 +++--
 src/dxvk/hud/dxvk_hud_item.cpp | 57 +++++++++++++++++++++++++++++++---
 src/dxvk/hud/dxvk_hud_item.h   | 36 +++++++++++++++++++++
 6 files changed, 104 insertions(+), 9 deletions(-)

diff --git a/src/d3d11/d3d11_swapchain.cpp b/src/d3d11/d3d11_swapchain.cpp
index b018d12239b..9a70a5c47ae 100644
--- a/src/d3d11/d3d11_swapchain.cpp
+++ b/src/d3d11/d3d11_swapchain.cpp
@@ -298,6 +298,9 @@ namespace dxvk {
     if (m_renderLatencyHud)
       m_renderLatencyHud->updateLatencyTracker(m_latency);
 
+    if (m_presentLatencyHud)
+      m_presentLatencyHud->updateLatencyTracker(m_latency);
+
     return hr;
   }
 
@@ -610,6 +613,7 @@ namespace dxvk {
         if (framePacer) {
           int32_t fpsItemPos = hud->getItemPos<hud::HudFpsItem>();
           m_renderLatencyHud = hud->addItem<hud::HudRenderLatencyItem>("renderlatency", fpsItemPos+1);
+          m_presentLatencyHud = hud->addItem<hud::HudPresentLatencyItem>("presentlatency", fpsItemPos+2);
         }
       }
     }
diff --git a/src/d3d11/d3d11_swapchain.h b/src/d3d11/d3d11_swapchain.h
index 6a77c7351d6..5daf407dc01 100644
--- a/src/d3d11/d3d11_swapchain.h
+++ b/src/d3d11/d3d11_swapchain.h
@@ -125,8 +125,9 @@ namespace dxvk {
     dxvk::mutex               m_frameStatisticsLock;
     DXGI_VK_FRAME_STATISTICS  m_frameStatistics = { };
 
-    Rc<hud::HudLatencyItem>       m_latencyHud;
-    Rc<hud::HudRenderLatencyItem> m_renderLatencyHud;
+    Rc<hud::HudLatencyItem>         m_latencyHud;
+    Rc<hud::HudRenderLatencyItem>   m_renderLatencyHud;
+    Rc<hud::HudPresentLatencyItem>  m_presentLatencyHud;
 
     Rc<DxvkImageView> GetBackBufferView();
 
diff --git a/src/d3d9/d3d9_swapchain.cpp b/src/d3d9/d3d9_swapchain.cpp
index a0d52939a18..8e3841d1a85 100644
--- a/src/d3d9/d3d9_swapchain.cpp
+++ b/src/d3d9/d3d9_swapchain.cpp
@@ -927,6 +927,9 @@ namespace dxvk {
     if (m_renderLatencyHud)
       m_renderLatencyHud->updateLatencyTracker(m_latencyTracker);
 
+    if (m_presentLatencyHud)
+      m_presentLatencyHud->updateLatencyTracker(m_latencyTracker);
+
     // Rotate swap chain buffers so that the back
     // buffer at index 0 becomes the front buffer.
     uint32_t rotatingBufferCount = m_backBuffers.size();
@@ -1078,6 +1081,7 @@ namespace dxvk {
         if (framePacer) {
           int32_t fpsItemPos = hud->getItemPos<hud::HudFpsItem>();
           m_renderLatencyHud = hud->addItem<hud::HudRenderLatencyItem>("renderlatency", fpsItemPos+1);
+          m_presentLatencyHud = hud->addItem<hud::HudPresentLatencyItem>("presentlatency", fpsItemPos+2);
         }
       }
 
diff --git a/src/d3d9/d3d9_swapchain.h b/src/d3d9/d3d9_swapchain.h
index e986047a436..550bfec6588 100644
--- a/src/d3d9/d3d9_swapchain.h
+++ b/src/d3d9/d3d9_swapchain.h
@@ -183,9 +183,10 @@ namespace dxvk {
     bool                      m_latencyTracking = false;
     Rc<DxvkLatencyTracker>    m_latencyTracker = nullptr;
 
-    Rc<hud::HudClientApiItem>     m_apiHud;
-    Rc<hud::HudLatencyItem>       m_latencyHud;
-    Rc<hud::HudRenderLatencyItem> m_renderLatencyHud;
+    Rc<hud::HudClientApiItem>       m_apiHud;
+    Rc<hud::HudLatencyItem>         m_latencyHud;
+    Rc<hud::HudRenderLatencyItem>   m_renderLatencyHud;
+    Rc<hud::HudPresentLatencyItem>  m_presentLatencyHud;
 
     std::optional<VkHdrMetadataEXT> m_hdrMetadata;
     bool m_unlockAdditionalFormats = false;
diff --git a/src/dxvk/hud/dxvk_hud_item.cpp b/src/dxvk/hud/dxvk_hud_item.cpp
index 6c60bf71b34..b50d9cea4bf 100644
--- a/src/dxvk/hud/dxvk_hud_item.cpp
+++ b/src/dxvk/hud/dxvk_hud_item.cpp
@@ -218,6 +218,55 @@ namespace dxvk::hud {
   HudRenderLatencyItem::~HudRenderLatencyItem() { }
 
   void HudRenderLatencyItem::update(dxvk::high_resolution_clock::time_point time) {
+    const Rc<DxvkLatencyTracker> tracker = m_tracker;
+    const FramePacer* framePacer = dynamic_cast<FramePacer*>( tracker.ptr() );
+    if (!framePacer)
+      return;
+
+    auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(time - m_lastUpdate);
+
+    if (elapsed.count() >= UpdateInterval) {
+      m_lastUpdate = time;
+
+      LatencyMarkersReader reader = framePacer->m_latencyMarkersStorage.getReader(100);
+      const LatencyMarkers* markers;
+      uint32_t count = 0;
+      uint64_t totalLatency = 0;
+      while (reader.getNext(markers)) {
+        totalLatency += markers->gpuFinished;
+        ++count;
+      }
+
+      if (!count)
+        return;
+
+      uint64_t latency = totalLatency / count;
+      m_latency = str::format(latency / 1000, ".", (latency/100) % 10, " ms");
+    }
+  }
+
+
+  HudPos HudRenderLatencyItem::render(
+    const DxvkContextObjects& ctx,
+    const HudPipelineKey&     key,
+    const HudOptions&         options,
+          HudRenderer&        renderer,
+          HudPos              position) {
+
+    position.y += 12;
+    renderer.drawText(16, position, 0xff4040ffu, "Render latency:");
+    renderer.drawText(16, { position.x + 195, position.y },
+      0xffffffffu, m_latency);
+
+    position.y += 8;
+    return position;
+  }
+
+
+  HudPresentLatencyItem::HudPresentLatencyItem() { }
+  HudPresentLatencyItem::~HudPresentLatencyItem() { }
+
+  void HudPresentLatencyItem::update(dxvk::high_resolution_clock::time_point time) {
     // we cannot measure latency when fps-limiting is performed in Presenter::runFrameThread()
     // because it's interfering with getting the right timestamp from vkWaitForPresent()
     // if we truely wanted to measure it, we would need one additional thread
@@ -241,7 +290,7 @@ namespace dxvk::hud {
       uint32_t count = 0;
       uint64_t totalLatency = 0;
       while (reader.getNext(markers)) {
-        totalLatency += markers->presentFinished;
+        totalLatency += markers->presentFinished - markers->gpuFinished;
         ++count;
       }
 
@@ -254,7 +303,7 @@ namespace dxvk::hud {
   }
 
 
-  HudPos HudRenderLatencyItem::render(
+  HudPos HudPresentLatencyItem::render(
     const DxvkContextObjects& ctx,
     const HudPipelineKey&     key,
     const HudOptions&         options,
@@ -262,8 +311,8 @@ namespace dxvk::hud {
           HudPos              position) {
 
     position.y += 12;
-    renderer.drawText(16, position, 0xff4040ffu, "Render latency:");
-    renderer.drawText(16, { position.x + 195, position.y },
+    renderer.drawText(16, position, 0xff4040ffu, "Present latency:");
+    renderer.drawText(16, { position.x + 206, position.y },
       0xffffffffu, m_latency);
 
     position.y += 8;
diff --git a/src/dxvk/hud/dxvk_hud_item.h b/src/dxvk/hud/dxvk_hud_item.h
index 0f9219124b5..33dae5f85e3 100644
--- a/src/dxvk/hud/dxvk_hud_item.h
+++ b/src/dxvk/hud/dxvk_hud_item.h
@@ -289,6 +289,42 @@ namespace dxvk::hud {
   };
 
 
+     /**
+   * \brief HUD item to display render latency
+   */
+  class HudPresentLatencyItem : public HudItem {
+    constexpr static int64_t UpdateInterval = 500'000;
+  public:
+
+    HudPresentLatencyItem();
+
+    ~HudPresentLatencyItem();
+
+    void updateLatencyTracker( const Rc<DxvkLatencyTracker>& tracker ) {
+      m_tracker = tracker;
+    }
+
+    void update(dxvk::high_resolution_clock::time_point time);
+
+    HudPos render(
+      const DxvkContextObjects& ctx,
+      const HudPipelineKey&     key,
+      const HudOptions&         options,
+            HudRenderer&        renderer,
+            HudPos              position);
+
+  private:
+
+    Rc<DxvkLatencyTracker> m_tracker;
+
+    dxvk::high_resolution_clock::time_point m_lastUpdate
+      = dxvk::high_resolution_clock::now();
+
+    std::string m_latency;
+
+  };
+
+
   /**
    * \brief HUD item to display the frame rate
    */

From 27c75e85646faa7201fb689af580116ffc948ad5 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Tue, 17 Jun 2025 12:34:40 +0200
Subject: [PATCH 22/81] [dxvk] Pick V-Sync present mode for new VRR frame
 pacing mode

---
 src/d3d11/d3d11_swapchain.cpp                            | 1 +
 src/dxvk/dxvk_presenter.cpp                              | 9 ++++++++-
 src/dxvk/dxvk_presenter.h                                | 5 +++++
 src/dxvk/framepacer/dxvk_framepacer.h                    | 4 ++++
 src/dxvk/framepacer/dxvk_framepacer_mode.h               | 4 ++++
 src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp | 9 +++++++++
 src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h   | 3 ++-
 7 files changed, 33 insertions(+), 2 deletions(-)

diff --git a/src/d3d11/d3d11_swapchain.cpp b/src/d3d11/d3d11_swapchain.cpp
index 9a70a5c47ae..f59d3a351a4 100644
--- a/src/d3d11/d3d11_swapchain.cpp
+++ b/src/d3d11/d3d11_swapchain.cpp
@@ -528,6 +528,7 @@ namespace dxvk {
     m_presenter->setFrameRateLimit(m_targetFrameRate, GetActualFrameLatency());
 
     m_latency = m_device->createLatencyTracker(m_presenter);
+    m_presenter->registerLatencyTracker(m_latency);
 
     Com<D3D11ReflexDevice> reflex = GetReflexDevice();
     reflex->RegisterLatencyTracker(m_latency);
diff --git a/src/dxvk/dxvk_presenter.cpp b/src/dxvk/dxvk_presenter.cpp
index 9ce8bb421a7..da9fc6ba173 100644
--- a/src/dxvk/dxvk_presenter.cpp
+++ b/src/dxvk/dxvk_presenter.cpp
@@ -1074,9 +1074,16 @@ namespace dxvk {
           uint32_t                  numSupported,
     const VkPresentModeKHR*         pSupported,
           uint32_t                  syncInterval) {
-    std::array<VkPresentModeKHR, 2> desired = { };
+    std::array<VkPresentModeKHR, 3> desired = { };
     uint32_t numDesired = 0;
 
+    FramePacer* pacer = dynamic_cast<FramePacer*>(m_latencyTracker.ptr());
+    if (pacer) {
+      uint32_t desiredMode;
+      if (pacer->getFramePacerMode()->getDesiredPresentMode(desiredMode))
+        desired[numDesired++] = (VkPresentModeKHR) desiredMode;
+    }
+
     Tristate tearFree = m_device->config().tearFree;
 
     if (!syncInterval) {
diff --git a/src/dxvk/dxvk_presenter.h b/src/dxvk/dxvk_presenter.h
index afbe465c320..2e85d8e1a54 100644
--- a/src/dxvk/dxvk_presenter.h
+++ b/src/dxvk/dxvk_presenter.h
@@ -259,6 +259,10 @@ namespace dxvk {
             uint32_t                timingCount,
             VkLatencyTimingsFrameReportNV* timings);
 
+
+    void registerLatencyTracker( const Rc<DxvkLatencyTracker>& tracker )
+      { m_latencyTracker = tracker; }
+
   private:
 
     Rc<DxvkDevice>              m_device;
@@ -315,6 +319,7 @@ namespace dxvk {
     std::queue<PresenterFrame>  m_frameQueue;
 
     uint64_t                    m_lastSignaled = 0u;
+    Rc<DxvkLatencyTracker>      m_latencyTracker;
 
     alignas(CACHE_LINE_SIZE)
     FpsLimiter                  m_fpsLimiter;
diff --git a/src/dxvk/framepacer/dxvk_framepacer.h b/src/dxvk/framepacer/dxvk_framepacer.h
index 0d5befc02d8..3a9565ee190 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.h
+++ b/src/dxvk/framepacer/dxvk_framepacer.h
@@ -123,6 +123,10 @@ namespace dxvk {
       return m_mode->m_mode;
     }
 
+    FramePacerMode* getFramePacerMode() {
+      return m_mode.get();
+    }
+
     void setTargetFrameRate( double frameRate ) {
       m_mode->setTargetFrameRate(frameRate);
     }
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode.h b/src/dxvk/framepacer/dxvk_framepacer_mode.h
index 98404ee71bd..65cf063bab1 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode.h
@@ -18,6 +18,7 @@ namespace dxvk {
     enum Mode {
       MAX_FRAME_LATENCY = 0,
       LOW_LATENCY,
+      LOW_LATENCY_VRR,
       MIN_LATENCY
     };
 
@@ -35,6 +36,9 @@ namespace dxvk {
 
     virtual void finishRender( uint64_t frameId ) { }
 
+    virtual bool getDesiredPresentMode( uint32_t& presentMode ) const {
+      return false; }
+
     void waitRenderFinished( uint64_t frameId ) {
       if (m_mode) m_fenceGpuFinished.wait(frameId-m_waitLatency); }
 
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
index 575b52ae286..8463621d8f3 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.cpp
@@ -1,7 +1,16 @@
 #include "dxvk_framepacer_mode_low_latency.h"
+#include <vulkan/vulkan_core.h>
 
 namespace dxvk {
 
+  bool LowLatencyMode::getDesiredPresentMode( uint32_t& presentMode ) const {
+    if (m_mode != LOW_LATENCY_VRR)
+      return false;
+
+    presentMode = (uint32_t) VkPresentModeKHR::VK_PRESENT_MODE_FIFO_KHR;
+    return true;
+  }
+
   int32_t LowLatencyMode::getLowLatencyOffset( const DxvkOptions& options ) {
     int32_t offset = options.lowLatencyOffset;
 
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index 03c4b4278ae..99a8fdf7618 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -42,7 +42,7 @@ namespace dxvk {
     using time_point = high_resolution_clock::time_point;
   public:
 
-    LowLatencyMode(Mode mode, LatencyMarkersStorage* storage, const DxvkOptions& options)
+    LowLatencyMode(Mode mode, LatencyMarkersStorage* storage, const DxvkOptions& options, float refreshRate = 10000)
     : FramePacerMode(mode, storage),
       m_lowLatencyOffset(getLowLatencyOffset(options)),
       m_allowCpuFramesOverlap(options.lowLatencyAllowCpuFramesOverlap) {
@@ -52,6 +52,7 @@ namespace dxvk {
 
     ~LowLatencyMode() {}
 
+    bool getDesiredPresentMode( uint32_t& presentMode ) const override;
 
     void startFrame( uint64_t frameId ) override {
       using std::chrono::duration_cast;

From 8a894132fe585c9cf443f7c4b1adb8e569f4381d Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Mon, 23 Jun 2025 23:38:41 +0200
Subject: [PATCH 23/81] [dxvk] Add low-latency VRR frame pacing mode

---
 src/dxvk/framepacer/dxvk_framepacer.cpp       | 18 ++++++++++
 .../dxvk_framepacer_mode_low_latency.h        | 36 +++++++++++++++++--
 2 files changed, 51 insertions(+), 3 deletions(-)

diff --git a/src/dxvk/framepacer/dxvk_framepacer.cpp b/src/dxvk/framepacer/dxvk_framepacer.cpp
index 034c75d567b..d15194766f2 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.cpp
+++ b/src/dxvk/framepacer/dxvk_framepacer.cpp
@@ -8,6 +8,10 @@
 
 namespace dxvk {
 
+  int getRefreshRate( std::string s ) {
+    return std::abs( std::atoi( s.substr(16).c_str() ) );
+  }
+
 
   FramePacer::FramePacer( const DxvkOptions& options, uint64_t firstFrameId ) {
     // we'll default to LOW_LATENCY in the draft-PR for now, for demonstration purposes,
@@ -16,17 +20,24 @@ namespace dxvk {
     // for its higher fps throughput and less susceptibility to short-term time inconsistencies.
     // which mode being smoother depends on the game.
     FramePacerMode::Mode mode = FramePacerMode::LOW_LATENCY;
+    int refreshRate = 0;
 
     std::string configStr = env::getEnvVar("DXVK_FRAME_PACE");
 
     if (configStr.find("max-frame-latency") != std::string::npos) {
       mode = FramePacerMode::MAX_FRAME_LATENCY;
+    } else if (configStr.find("low-latency-vrr-") != std::string::npos) {
+      mode = FramePacerMode::LOW_LATENCY_VRR;
+      refreshRate = getRefreshRate(configStr);
     } else if (configStr.find("low-latency") != std::string::npos) {
       mode = FramePacerMode::LOW_LATENCY;
     } else if (configStr.find("min-latency") != std::string::npos) {
       mode = FramePacerMode::MIN_LATENCY;
     } else if (options.framePace.find("max-frame-latency") != std::string::npos) {
       mode = FramePacerMode::MAX_FRAME_LATENCY;
+    } else if (options.framePace.find("low-latency-vrr-") != std::string::npos) {
+      mode = FramePacerMode::LOW_LATENCY_VRR;
+      refreshRate = getRefreshRate(options.framePace);
     } else if (options.framePace.find("low-latency") != std::string::npos) {
       mode = FramePacerMode::LOW_LATENCY;
     } else if (options.framePace.find("min-latency") != std::string::npos) {
@@ -50,6 +61,13 @@ namespace dxvk {
         m_mode = std::make_unique<LowLatencyMode>(mode, &m_latencyMarkersStorage, options);
         break;
 
+      case FramePacerMode::LOW_LATENCY_VRR:
+        Logger::info( "Frame pace: low-latency-vrr" );
+        GpuFlushTracker::m_minPendingSubmissions = 1;
+        GpuFlushTracker::m_minChunkCount = 1;
+        m_mode = std::make_unique<LowLatencyMode>(mode, &m_latencyMarkersStorage, options, refreshRate);
+        break;
+
       case FramePacerMode::MIN_LATENCY:
         Logger::info( "Frame pace: min-latency" );
         GpuFlushTracker::m_minPendingSubmissions = 1;
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index 99a8fdf7618..2bd1b7d9610 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -42,12 +42,18 @@ namespace dxvk {
     using time_point = high_resolution_clock::time_point;
   public:
 
-    LowLatencyMode(Mode mode, LatencyMarkersStorage* storage, const DxvkOptions& options, float refreshRate = 10000)
+    LowLatencyMode(Mode mode, LatencyMarkersStorage* storage, const DxvkOptions& options, int refreshRate = 0)
     : FramePacerMode(mode, storage),
       m_lowLatencyOffset(getLowLatencyOffset(options)),
       m_allowCpuFramesOverlap(options.lowLatencyAllowCpuFramesOverlap) {
       Logger::info( str::format("Using lowLatencyOffset: ", m_lowLatencyOffset) );
       Logger::info( str::format("Using lowLatencyAllowCpuFramesOverlap: ", m_allowCpuFramesOverlap) );
+
+      if (refreshRate > 0) {
+        m_vrrRefreshInterval = 1'000'000 / refreshRate;
+        Logger::info( str::format("Using vrr refresh rate: ", refreshRate) );
+      }
+
     }
 
     ~LowLatencyMode() {}
@@ -55,6 +61,7 @@ namespace dxvk {
     bool getDesiredPresentMode( uint32_t& presentMode ) const override;
 
     void startFrame( uint64_t frameId ) override {
+
       using std::chrono::duration_cast;
 
       if (!m_allowCpuFramesOverlap)
@@ -68,8 +75,15 @@ namespace dxvk {
         return;
 
       if (finishedId == frameId-1) {
-        // we are the only in-flight frame, nothing to do other then to apply fps-limiter if needed
-        m_lastStart = sleepFor( now, 0 );
+        // we are the only in-flight frame, nothing to do other then
+        // to sync to v-blank and apply fps-limiter if needed
+        int32_t delay = 0;
+        if (m_mode == LOW_LATENCY_VRR) {
+          const SyncProps props = getSyncPrediction();
+          delay = std::max(delay, getVrrDelay(frameId, props, now));
+        }
+
+        m_lastStart = sleepFor( now, delay );
         return;
       }
 
@@ -98,6 +112,10 @@ namespace dxvk {
 
       int32_t delay = std::max(gpuDelay, cpuDelay) + m_lowLatencyOffset;
 
+      if (m_mode == LOW_LATENCY_VRR) {
+        delay = std::max(delay, getVrrDelay(frameId, props, now));
+      }
+
       m_lastStart = sleepFor( now, delay );
 
     }
@@ -231,6 +249,16 @@ namespace dxvk {
     }
 
 
+    int32_t getVrrDelay( uint64_t frameId, const SyncProps& props, const time_point& now ) {
+      uint64_t frameFinishedId = m_latencyMarkersStorage->getTimeline()->frameFinished.load();
+      int32_t lastVBlank = std::chrono::duration_cast<microseconds> (
+        m_latencyMarkersStorage->getConstMarkers(frameFinishedId)->end - now ).count();
+
+      int32_t targetVBlank = lastVBlank + (frameId - frameFinishedId) * m_vrrRefreshInterval;
+      return targetVBlank - props.optimizedGpuTime - props.cpuUntilGpuStart;
+    }
+
+
     int32_t getLowLatencyOffset( const DxvkOptions& options );
     bool getLowLatencyAllowCpuFramesOverlap( const DxvkOptions& options );
 
@@ -238,6 +266,8 @@ namespace dxvk {
     const bool    m_allowCpuFramesOverlap;
 
     Sleep::TimePoint m_lastStart = { high_resolution_clock::now() };
+    int32_t m_vrrRefreshInterval = { 0 };
+
     std::array<SyncProps, 16> m_props;
     std::atomic<uint64_t> m_propsFinished = { 0 };
 

From 2fbbb3081341a3d41521a2f76bdd8bfcf3c7155a Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Tue, 24 Jun 2025 14:53:25 +0200
Subject: [PATCH 24/81] [dxvk] Take presentation delay into account for VRR
 pacing

This is needed for Wine-Wayland since the driver reports different presentation delays (much more) than on x11. Might help in other situations too.
---
 .../dxvk_framepacer_mode_low_latency.h        | 45 ++++++++++++-----
 .../framepacer/dxvk_presentation_latency.h    | 50 +++++++++++++++++++
 2 files changed, 82 insertions(+), 13 deletions(-)
 create mode 100644 src/dxvk/framepacer/dxvk_presentation_latency.h

diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index 2bd1b7d9610..c6684006039 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include "dxvk_framepacer_mode.h"
+#include "dxvk_presentation_latency.h"
 #include "../dxvk_options.h"
 #include "../../util/log/log.h"
 #include "../../util/util_string.h"
@@ -81,6 +82,7 @@ namespace dxvk {
         if (m_mode == LOW_LATENCY_VRR) {
           const SyncProps props = getSyncPrediction();
           delay = std::max(delay, getVrrDelay(frameId, props, now));
+          delay += m_lowLatencyOffset;
         }
 
         m_lastStart = sleepFor( now, delay );
@@ -110,12 +112,13 @@ namespace dxvk {
         m->start + microseconds(props.csFinished) - now).count();
       int32_t cpuDelay = cpuReadyPrediction - props.csStart;
 
-      int32_t delay = std::max(gpuDelay, cpuDelay) + m_lowLatencyOffset;
+      int32_t delay = std::max(gpuDelay, cpuDelay);
 
       if (m_mode == LOW_LATENCY_VRR) {
         delay = std::max(delay, getVrrDelay(frameId, props, now));
       }
 
+      delay += m_lowLatencyOffset;
       m_lastStart = sleepFor( now, delay );
 
     }
@@ -177,22 +180,17 @@ namespace dxvk {
     }
 
 
-    Sleep::TimePoint sleepFor( const Sleep::TimePoint t, int32_t delay ) {
-
-      // account for the fps limit and ensure we won't sleep too long, just in case
-      int32_t frametime = std::chrono::duration_cast<microseconds>( t - m_lastStart ).count();
-      int32_t frametimeDiff = std::max( 0, m_fpsLimitFrametime.load() - frametime );
-      delay = std::max( delay, frametimeDiff );
-      int32_t maxDelay = std::max( m_fpsLimitFrametime.load(), 20000 );
-      delay = std::max( 0, std::min( delay, maxDelay ) );
+    void endFrame( uint64_t frameId ) override {
 
-      Sleep::TimePoint nextStart = t + microseconds(delay);
-      Sleep::sleepUntil( t, nextStart );
-      return nextStart;
+      if (m_mode == LOW_LATENCY_VRR) {
+        const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(frameId);
+        m_presentationLatency.push( m->presentFinished - m->gpuFinished );
+      }
 
     }
 
 
+
   private:
 
     struct SyncProps {
@@ -253,12 +251,32 @@ namespace dxvk {
       uint64_t frameFinishedId = m_latencyMarkersStorage->getTimeline()->frameFinished.load();
       int32_t lastVBlank = std::chrono::duration_cast<microseconds> (
         m_latencyMarkersStorage->getConstMarkers(frameFinishedId)->end - now ).count();
+      int32_t presentLatency = m_presentationLatency.getMedian();
+
+      int32_t targetVBlank = lastVBlank
+        + (frameId - frameFinishedId) * m_vrrRefreshInterval
+        - presentLatency;
 
-      int32_t targetVBlank = lastVBlank + (frameId - frameFinishedId) * m_vrrRefreshInterval;
       return targetVBlank - props.optimizedGpuTime - props.cpuUntilGpuStart;
     }
 
 
+    Sleep::TimePoint sleepFor( const Sleep::TimePoint t, int32_t delay ) {
+
+      // account for the fps limit and ensure we won't sleep too long, just in case
+      int32_t frametime = std::chrono::duration_cast<microseconds>( t - m_lastStart ).count();
+      int32_t frametimeDiff = std::max( 0, m_fpsLimitFrametime.load() - frametime );
+      delay = std::max( delay, frametimeDiff );
+      int32_t maxDelay = std::max( m_fpsLimitFrametime.load(), 20000 );
+      delay = std::max( 0, std::min( delay, maxDelay ) );
+
+      Sleep::TimePoint nextStart = t + microseconds(delay);
+      Sleep::sleepUntil( t, nextStart );
+      return nextStart;
+
+    }
+
+
     int32_t getLowLatencyOffset( const DxvkOptions& options );
     bool getLowLatencyAllowCpuFramesOverlap( const DxvkOptions& options );
 
@@ -267,6 +285,7 @@ namespace dxvk {
 
     Sleep::TimePoint m_lastStart = { high_resolution_clock::now() };
     int32_t m_vrrRefreshInterval = { 0 };
+    PresentationLatency m_presentationLatency;
 
     std::array<SyncProps, 16> m_props;
     std::atomic<uint64_t> m_propsFinished = { 0 };
diff --git a/src/dxvk/framepacer/dxvk_presentation_latency.h b/src/dxvk/framepacer/dxvk_presentation_latency.h
new file mode 100644
index 00000000000..51e464b386f
--- /dev/null
+++ b/src/dxvk/framepacer/dxvk_presentation_latency.h
@@ -0,0 +1,50 @@
+#pragma once
+
+#include <stdint.h>
+#include <array>
+#include <atomic>
+#include <assert.h>
+
+
+namespace dxvk {
+
+  class PresentationLatency {
+
+  public:
+
+    void push( int32_t latency ) {
+
+      assert( latency >= 0 );
+      size_t index = latency / 8;
+      index = std::min( m_buckets.size()-1, index );
+
+      m_buckets[index]++;
+      m_numLatencies++;
+
+    }
+
+
+    int32_t getMedian() {
+
+      uint64_t targetCount = m_numLatencies / 2;
+      uint64_t count = 0;
+      size_t index = 0;
+      while (count < targetCount && index < m_buckets.size()) {
+        count += m_buckets[index];
+        ++index;
+      }
+
+      return index * 8;
+
+    }
+
+
+  private:
+
+    constexpr static int32_t maxLatency = 50000;
+    std::array< std::atomic<int64_t>, maxLatency / 8 > m_buckets = { };
+    std::atomic< uint64_t > m_numLatencies = { 0 };
+
+  };
+
+}

From ffd61f6522c454e650f0eface99eb5cee46b1466 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Thu, 26 Jun 2025 15:49:29 +0200
Subject: [PATCH 25/81] [dxvk] Limit presentation stats tracking to 5 seconds
 for VRR pacing

so it adjust to the current situation.
---
 .../dxvk_framepacer_mode_low_latency.h        | 15 +++-
 .../framepacer/dxvk_presentation_latency.h    | 50 -----------
 src/dxvk/framepacer/dxvk_presentation_stats.h | 85 +++++++++++++++++++
 3 files changed, 96 insertions(+), 54 deletions(-)
 delete mode 100644 src/dxvk/framepacer/dxvk_presentation_latency.h
 create mode 100644 src/dxvk/framepacer/dxvk_presentation_stats.h

diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index c6684006039..ce788b5a206 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -1,7 +1,7 @@
 #pragma once
 
 #include "dxvk_framepacer_mode.h"
-#include "dxvk_presentation_latency.h"
+#include "dxvk_presentation_stats.h"
 #include "../dxvk_options.h"
 #include "../../util/log/log.h"
 #include "../../util/util_string.h"
@@ -184,7 +184,7 @@ namespace dxvk {
 
       if (m_mode == LOW_LATENCY_VRR) {
         const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(frameId);
-        m_presentationLatency.push( m->presentFinished - m->gpuFinished );
+        m_presentationStats.push( m->end, m->presentFinished - m->gpuFinished );
       }
 
     }
@@ -251,7 +251,14 @@ namespace dxvk {
       uint64_t frameFinishedId = m_latencyMarkersStorage->getTimeline()->frameFinished.load();
       int32_t lastVBlank = std::chrono::duration_cast<microseconds> (
         m_latencyMarkersStorage->getConstMarkers(frameFinishedId)->end - now ).count();
-      int32_t presentLatency = m_presentationLatency.getMedian();
+
+      // Presentation latency should be fairly stable, but drivers may report back
+      // different levels of latency (Nvidia reports very low latencies on x11 flip compared
+      // to Wayland). We take the median within a recent time window to adjust to that.
+
+      // Presentation latency may vary though for other reasons, like when compiling shaders
+      // on all cpu cores we will get thread starvation and higher latency.
+      int32_t presentLatency = m_presentationStats.getMedian();
 
       int32_t targetVBlank = lastVBlank
         + (frameId - frameFinishedId) * m_vrrRefreshInterval
@@ -285,7 +292,7 @@ namespace dxvk {
 
     Sleep::TimePoint m_lastStart = { high_resolution_clock::now() };
     int32_t m_vrrRefreshInterval = { 0 };
-    PresentationLatency m_presentationLatency;
+    PresentationStats m_presentationStats;
 
     std::array<SyncProps, 16> m_props;
     std::atomic<uint64_t> m_propsFinished = { 0 };
diff --git a/src/dxvk/framepacer/dxvk_presentation_latency.h b/src/dxvk/framepacer/dxvk_presentation_latency.h
deleted file mode 100644
index 51e464b386f..00000000000
--- a/src/dxvk/framepacer/dxvk_presentation_latency.h
+++ /dev/null
@@ -1,50 +0,0 @@
-#pragma once
-
-#include <stdint.h>
-#include <array>
-#include <atomic>
-#include <assert.h>
-
-
-namespace dxvk {
-
-  class PresentationLatency {
-
-  public:
-
-    void push( int32_t latency ) {
-
-      assert( latency >= 0 );
-      size_t index = latency / 8;
-      index = std::min( m_buckets.size()-1, index );
-
-      m_buckets[index]++;
-      m_numLatencies++;
-
-    }
-
-
-    int32_t getMedian() {
-
-      uint64_t targetCount = m_numLatencies / 2;
-      uint64_t count = 0;
-      size_t index = 0;
-      while (count < targetCount && index < m_buckets.size()) {
-        count += m_buckets[index];
-        ++index;
-      }
-
-      return index * 8;
-
-    }
-
-
-  private:
-
-    constexpr static int32_t maxLatency = 50000;
-    std::array< std::atomic<int64_t>, maxLatency / 8 > m_buckets = { };
-    std::atomic< uint64_t > m_numLatencies = { 0 };
-
-  };
-
-}
diff --git a/src/dxvk/framepacer/dxvk_presentation_stats.h b/src/dxvk/framepacer/dxvk_presentation_stats.h
new file mode 100644
index 00000000000..ebadcd86573
--- /dev/null
+++ b/src/dxvk/framepacer/dxvk_presentation_stats.h
@@ -0,0 +1,85 @@
+#pragma once
+
+#include <stdint.h>
+#include <array>
+#include <atomic>
+#include <deque>
+#include <assert.h>
+
+#include "../../util/util_time.h"
+
+
+namespace dxvk {
+
+  class PresentationStats {
+
+  public:
+
+    using time_point = high_resolution_clock::time_point;
+
+    void push( time_point t, int32_t latency ) {
+
+      int32_t index = getBucketIndex(latency);
+
+      ++m_buckets[index];
+      ++m_numLatencies;
+
+      QueueItem item = {
+        .timeStamp = t,
+        .latency   = latency
+      };
+
+      m_queue.push_back(item);
+
+      // remove old items from the queue
+      while (!m_queue.empty() && m_queue.front().timeStamp
+        < high_resolution_clock::now() - std::chrono::milliseconds(5000) ) {
+        index = getBucketIndex(m_queue.front().latency);
+        --m_buckets[index];
+        --m_numLatencies;
+        m_queue.pop_front();
+      }
+
+    }
+
+
+    int32_t getMedian() {
+
+      uint64_t targetCount = m_numLatencies / 2;
+      uint64_t count = 0;
+      size_t index = 0;
+      while (count < targetCount && index < m_buckets.size()) {
+        count += m_buckets[index];
+        ++index;
+      }
+
+      return index * 8;
+
+    }
+
+
+  private:
+
+    int getBucketIndex( int32_t latency ) {
+      assert( latency >= 0 );
+      size_t index = latency / 8;
+      return std::min( m_buckets.size()-1, index );
+    }
+
+    // if presents take longer than 5 ms, we probably have a problem?
+    constexpr static int32_t maxLatency = 5000;
+
+    std::array< std::atomic<int64_t>, maxLatency / 8 > m_buckets = { };
+    std::atomic< int64_t > m_numLatencies = { 0 };
+
+    struct QueueItem {
+      time_point timeStamp;
+      int32_t    latency;
+    };
+
+    // should only be accessed from one thread
+    std::deque< QueueItem > m_queue;
+
+  };
+
+}

From 848f94e6e8a3975e7a3fae28fd120516413bb86b Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Sun, 6 Jul 2025 20:03:40 +0200
Subject: [PATCH 26/81] [dxvk] Prevent presentation stats median drift for VRR
 pacing

---
 .../framepacer/dxvk_framepacer_mode_low_latency.h  | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index ce788b5a206..81c2340bc70 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -182,9 +182,17 @@ namespace dxvk {
 
     void endFrame( uint64_t frameId ) override {
 
-      if (m_mode == LOW_LATENCY_VRR) {
-        const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(frameId);
-        m_presentationStats.push( m->end, m->presentFinished - m->gpuFinished );
+      if (m_mode == LOW_LATENCY_VRR && frameId > 100) {
+        const LatencyMarkers* m1 = m_latencyMarkersStorage->getConstMarkers(frameId-1);
+        const LatencyMarkers* m2 = m_latencyMarkersStorage->getConstMarkers(frameId);
+
+        int32_t gpuFinishedInterval = std::chrono::duration_cast<microseconds>(
+          (m2->start + microseconds(m2->gpuFinished)) - (m1->start + microseconds(m1->gpuFinished))).count();
+
+        // Only push values where we probably weren't running into v-sync buffering.
+        // Otherwise we can get a presentation stats median drift due to feedback loop.
+        if (gpuFinishedInterval >= 0.99 * m_vrrRefreshInterval)
+          m_presentationStats.push( m2->end, m2->presentFinished - m2->gpuFinished );
       }
 
     }

From e9a18e8abf5c66a6a2d7c78d68b365195933fca4 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Sun, 6 Jul 2025 20:19:11 +0200
Subject: [PATCH 27/81] [dxvk] Sleep potentially twice before starting a frame
 in low-latency modes

---
 .../dxvk_framepacer_mode_low_latency.h        | 90 +++++++++++--------
 1 file changed, 53 insertions(+), 37 deletions(-)

diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index 81c2340bc70..00a526b6c12 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -71,55 +71,71 @@ namespace dxvk {
       m_fenceGpuStart.wait( frameId-1 );
 
       time_point now = high_resolution_clock::now();
-      uint64_t finishedId = m_latencyMarkersStorage->getTimeline()->gpuFinished.load();
-      if (finishedId <= DXGI_MAX_SWAP_CHAIN_BUFFERS+1ull)
-        return;
-
-      if (finishedId == frameId-1) {
-        // we are the only in-flight frame, nothing to do other then
-        // to sync to v-blank and apply fps-limiter if needed
-        int32_t delay = 0;
-        if (m_mode == LOW_LATENCY_VRR) {
-          const SyncProps props = getSyncPrediction();
-          delay = std::max(delay, getVrrDelay(frameId, props, now));
-          delay += m_lowLatencyOffset;
+      time_point nextStart { };
+
+      for (int i=0; i<2; ++i) {
+        // We run this loop twice since there may be new information available
+        // after the first sleep that lead to a second sleep.
+        // While this may not happen that often, this is very relevant in certain situations
+        // in which this can lead to up to 20% latency reduction. This may not only happen
+        // for single frames, but the time span of this situation can be a second or more.
+
+        // Note: This works as is, because Sleep::sleepUntil doesn't work how it's advertised. It reads:
+        // "Convenience function that sleeps for the time difference between t1 and t0.",
+        // but it seems to just sleep until t1, regardless of t0, which is exactly what we need.
+
+        uint64_t finishedId = m_latencyMarkersStorage->getTimeline()->gpuFinished.load();
+        if (finishedId <= DXGI_MAX_SWAP_CHAIN_BUFFERS+1ull)
+          return;
+
+        if (finishedId == frameId-1) {
+          // we are the only in-flight frame, nothing to do other then
+          // to sync to v-blank and apply fps-limiter if needed
+          int32_t delay = 0;
+          if (m_mode == LOW_LATENCY_VRR) {
+            const SyncProps props = getSyncPrediction();
+            delay = std::max(delay, getVrrDelay(frameId, props, now));
+            delay += m_lowLatencyOffset;
+          }
+
+          nextStart = sleepFor( now, delay );
+          continue;
         }
 
-        m_lastStart = sleepFor( now, delay );
-        return;
-      }
+        if (finishedId != frameId-2) {
+          Logger::err( str::format("internal error during low-latency frame pacing: expected finished frameId=",
+            frameId-2, ", got: ", finishedId) );
+        }
 
-      if (finishedId != frameId-2) {
-        Logger::err( str::format("internal error during low-latency frame pacing: expected finished frameId=",
-          frameId-2, ", got: ", finishedId) );
-      }
+        const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(frameId-1);
 
-      const LatencyMarkers* m = m_latencyMarkersStorage->getConstMarkers(frameId-1);
+        // estimate the target gpu sync point for this frame
+        // and calculate backwards when we want to start this frame
 
-      // estimate the target gpu sync point for this frame
-      // and calculate backwards when we want to start this frame
+        const SyncProps props = getSyncPrediction();
+        int32_t lastFrameStart = duration_cast<microseconds>( m->start - now ).count();
+        int32_t gpuReadyPrediction = lastFrameStart
+          + std::max( props.cpuUntilGpuStart, m->gpuStart )
+          + props.optimizedGpuTime;
 
-      const SyncProps props = getSyncPrediction();
-      int32_t lastFrameStart = duration_cast<microseconds>( m->start - now ).count();
-      int32_t gpuReadyPrediction = lastFrameStart
-        + std::max( props.cpuUntilGpuStart, m->gpuStart )
-        + props.optimizedGpuTime;
+        int32_t targetGpuSync = gpuReadyPrediction + props.gpuSync;
+        int32_t gpuDelay = targetGpuSync - props.cpuUntilGpuSync;
 
-      int32_t targetGpuSync = gpuReadyPrediction + props.gpuSync;
-      int32_t gpuDelay = targetGpuSync - props.cpuUntilGpuSync;
+        int32_t cpuReadyPrediction = duration_cast<microseconds>(
+          m->start + microseconds(props.csFinished) - now).count();
+        int32_t cpuDelay = cpuReadyPrediction - props.csStart;
 
-      int32_t cpuReadyPrediction = duration_cast<microseconds>(
-        m->start + microseconds(props.csFinished) - now).count();
-      int32_t cpuDelay = cpuReadyPrediction - props.csStart;
+        int32_t delay = std::max(gpuDelay, cpuDelay);
 
-      int32_t delay = std::max(gpuDelay, cpuDelay);
+        if (m_mode == LOW_LATENCY_VRR) {
+          delay = std::max(delay, getVrrDelay(frameId, props, now));
+        }
 
-      if (m_mode == LOW_LATENCY_VRR) {
-        delay = std::max(delay, getVrrDelay(frameId, props, now));
+        delay += m_lowLatencyOffset;
+        nextStart = sleepFor( now, delay );
       }
 
-      delay += m_lowLatencyOffset;
-      m_lastStart = sleepFor( now, delay );
+      m_lastStart = nextStart;
 
     }
 

From c675c6063f1800afcd58bad77076e80e47373144 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Sun, 6 Jul 2025 20:52:20 +0200
Subject: [PATCH 28/81] [dxvk] Don't measure and display present latency for
 Mailbox

Mailbox latencies aren't reported truthfully by the driver (/Wayland WM?) to begin with and special treatment would be needed, because many frames might map to one present, from which we would need to select the best one.

There may be still an issue that Immediate might map to Mailbox, but that seems to be a driver/Wayland issue as well.
---
 src/dxvk/dxvk_presenter.cpp                | 9 +++++++--
 src/dxvk/framepacer/dxvk_framepacer_mode.h | 6 ++++++
 src/dxvk/hud/dxvk_hud_item.cpp             | 7 ++++++-
 3 files changed, 19 insertions(+), 3 deletions(-)

diff --git a/src/dxvk/dxvk_presenter.cpp b/src/dxvk/dxvk_presenter.cpp
index da9fc6ba173..12c1f4d11bb 100644
--- a/src/dxvk/dxvk_presenter.cpp
+++ b/src/dxvk/dxvk_presenter.cpp
@@ -597,6 +597,9 @@ namespace dxvk {
 
     m_presentMode = pickPresentMode(modes.size(), modes.data(), m_preferredSyncInterval);
 
+    FramePacer* pacer = dynamic_cast<FramePacer*>(m_latencyTracker.ptr());
+    if (pacer) pacer->getFramePacerMode()->setPresentMode(m_presentMode);
+
     // Check whether we can change present modes dynamically. This may
     // influence the image count as well as further swap chain creation.
     std::vector<VkPresentModeKHR> dynamicModes = {{
@@ -1102,7 +1105,7 @@ namespace dxvk {
           return pSupported[j];
       }
     }
-    
+
     // Guaranteed to be available
     return VK_PRESENT_MODE_FIFO_KHR;
   }
@@ -1253,11 +1256,13 @@ namespace dxvk {
 
       lock.unlock();
 
+      FramePacer* pacer = dynamic_cast<FramePacer*>(frame.tracker.ptr());
+
       // If the present operation has succeeded, actually wait for it to complete.
       // Don't bother with it on MAILBOX / IMMEDIATE modes since doing so would
       // restrict us to the display refresh rate on some platforms (XWayland).
       if (frame.result >= 0 && (frame.mode == VK_PRESENT_MODE_FIFO_KHR || frame.mode == VK_PRESENT_MODE_FIFO_RELAXED_KHR
-        || (dynamic_cast<FramePacer*>(frame.tracker.ptr()) && dynamic_cast<FramePacer*>(frame.tracker.ptr())->getMode()) )) {
+        || (pacer && pacer->getMode() && frame.mode != VK_PRESENT_MODE_MAILBOX_KHR))) {
         VkResult vr = m_vkd->vkWaitForPresentKHR(m_vkd->device(),
           m_swapchain, frame.frameId, std::numeric_limits<uint64_t>::max());
 
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode.h b/src/dxvk/framepacer/dxvk_framepacer_mode.h
index 65cf063bab1..abe626c8336 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode.h
@@ -39,6 +39,11 @@ namespace dxvk {
     virtual bool getDesiredPresentMode( uint32_t& presentMode ) const {
       return false; }
 
+    void setPresentMode( uint32_t presentMode ) {
+      m_presentMode = presentMode; }
+
+    uint32_t getPresentMode() { return m_presentMode; }
+
     void waitRenderFinished( uint64_t frameId ) {
       if (m_mode) m_fenceGpuFinished.wait(frameId-m_waitLatency); }
 
@@ -67,6 +72,7 @@ namespace dxvk {
 
     const uint32_t m_waitLatency;
     LatencyMarkersStorage* m_latencyMarkersStorage;
+    std::atomic<uint32_t> m_presentMode;
     std::atomic<int32_t> m_fpsLimitFrametime = { 0 };
     bool m_fpsLimitEnvOverride = { false };
 
diff --git a/src/dxvk/hud/dxvk_hud_item.cpp b/src/dxvk/hud/dxvk_hud_item.cpp
index b50d9cea4bf..b4ecc6bf6fb 100644
--- a/src/dxvk/hud/dxvk_hud_item.cpp
+++ b/src/dxvk/hud/dxvk_hud_item.cpp
@@ -276,10 +276,15 @@ namespace dxvk::hud {
     }
 
     const Rc<DxvkLatencyTracker> tracker = m_tracker;
-    const FramePacer* framePacer = dynamic_cast<FramePacer*>( tracker.ptr() );
+    FramePacer* framePacer = dynamic_cast<FramePacer*>( tracker.ptr() );
     if (!framePacer)
       return;
 
+    if (framePacer->getFramePacerMode()->getPresentMode() == VK_PRESENT_MODE_MAILBOX_KHR) {
+      m_latency = "N/A";
+      return;
+    }
+
     auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(time - m_lastUpdate);
 
     if (elapsed.count() >= UpdateInterval) {

From 45a350ab31c7cc0662a5b5cb744a7582f342f26e Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Mon, 7 Jul 2025 11:06:05 +0200
Subject: [PATCH 29/81] [meta] Add readme for dxvk low-latency

---
 README.md | 117 +++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 116 insertions(+), 1 deletion(-)

diff --git a/README.md b/README.md
index 2f8edf41435..30a0dd7ab98 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,119 @@
-# DXVK
+# DXVK LOW-LATENCY
+
+Enhances the original [dxvk](https://github.com/doitsujin/dxvk) with low-latency frame pacing capabilities to improve game responsiveness and input lag. It also improves latency stability over time, usually resulting in a more accurate playback speed of the generated video.
+
+### Installation
+
+The most common way to install is to replace the dxvk .dll files within the Proton directory. You can theoretically do this with Steam's Proton, but since Steam will periodically update Proton, it will regularly overwrite the .dll files, and thus it's instead recommended to put a Proton version into `$HOME/.local/share/Steam/compatibilitytools.d`, such as [Proton-GE](https://github.com/GloriousEggroll/proton-ge-custom) where you can find the .dll files in `files/lib/wine/dxvk`, `i386-windows` for 32 bit and `x86_64-windows` for 64 bit. Depending on the particular Proton version, the folders might be structured slightly differently. This Proton version then can be selected in Steam, Lutris, Heroic, etc.
+
+When using dxvk low-latency in Wine directly, see [How to use](https://github.com/netborg-afps/dxvk/?tab=readme-ov-file#how-to-use).
+
+### Options
+
+#### dxvk.framePace
+
+dxvk low-latency is configured such that it achieves its goal without setting any options. The exception to this currently is that the user might want to enable the VRR mode manually. Fine-tuning the pacing via options is also possible.
+
+The config variable `dxvk.framePace` in `dxvk.conf` can be set to
+
+- `"max-frame-latency"` is the behaviour of upstream dxvk. Frame `i` won't start as long as frame `(i-1)-x` isn't finished, where `x` is the value of `dxgi.maxFrameLatency` / `d3d9.maxFrameLatency`. This pacing usually looks smooth, but has latency issues when GPU bound. Optimized for highest fps.
+- `"min-latency"` is essential like `max-frame-latency-0` (not selectable for the mode above), which means the start of a frame will wait until the previous one is finished. CPU/GPU no longer overlap during the transition from one frame to another and thus a lot of fps are sacrificed for prioritizing low latency. This mode is generally not recommended, but might be useful to get insights.
+- `"low-latency"` is the default mode: It combines high fps throughput with excellent game responsiveness and low input lag. Looking at a scale of a few seconds, pacing is usually more accurate in time than `max-frame-latency` since latency variations are minimized, especially when moving in and out of the GPU limit and when GPU frametimes vary a lot while being GPU bound. Looking at the pacing frame by frame, this mode relies on the game providing stable frame times for smoothness. When the game generates occasional stutters, these are filtered out nicely such that they don't interfere with the presentation of the other frames.
+- `"low-latency-vrr-240"` enhances the above mode by taking v-blank information into account, which prevents additional v-sync buffering latency. This mode automatically enables v-sync to get informed when v-blanks are happening. It will make the pacer predict future v-blanks based on the given refresh rate of 240 Hz. Replace 240 with the refresh rate of your monitor. This mode works with x11-flip and native Wayland (can be enabled in Wine via `DISPLAY= `), but cannot work on Xwayland because v-blank information is not available there (tested on Nvidia). Care has to be taken that the system is configured such that the display is indeed using a variable refresh rate, otherwise this mode won't work properly.
+
+Setting the frame pacing via the environment variable `DXVK_FRAME_PACE` is also supported.
+
+#### d3d9/dxgi.maxFrameRate
+
+Fps limiting is very helpful when used together with VRR to give the pacing enough space to not hit the v-sync buffering. For 240 Hz VRR, a limit of about 225 fps is recommended, and similarly for other refresh rates. Finding the best fps-limit for VRR will require some testing and also depends on the game and how much frametime variation it generates on the user's system. 
+
+Fps limiting is also useful in other modes to improve consistency and/or to save power. Limiting in the low-latency modes is tightly integrated into the frame pacing and is strongly recommended to be used in place of most ingame limiters. 
+
+If setting an fps limit so low that it will bore your GPU, this may result in your driver's heuristic clocking down the GPU, which can cause the latency to quadruple if you are unlucky. So you may want to watch out for that and take appropriate measures if desired.
+
+Setting the fps limit via the environment variable `DXVK_FRAME_RATE` is also supported.
+
+#### dxvk.hud
+
+Latencies can be visualized by adding the following to `dxvk.hud`/`DXVK_HUD`. Average over 100 frames.
+
+- `renderlatency`: start of frame (usually when the game starts processing input) until the GPU did finish rendering this frame. Note that this will not work when a game's fps limiter is enabled, as there is no way to detect when a game will stall processing before reading input.
+- `presentlatency`: time it takes to present the finished image to the screen. Relies on the driver implementation of `vkWaitForPresentKHR`, which may or may not be accurate. `VK_PRESENT_MODE_MAILBOX_KHR` is currently not supported, because it needs special treatment.
+
+#### dxvk.lowLatencyOffset
+
+You can fine-tune the low-latency pacing options towards more fps or towards better latency. `dxvk.lowLatencyOffset = 0` is the default, a negative value will make frames start earlier by the given amount (in microseconds), and thus those frames will more likely run into buffering, which in turns may increase fps. A positive value will make frames start later by the given amount (in microseconds), which make it less likely to run into buffering and thus may improve latency.
+
+In other words, this option has an effect on the percentage of frames which go into GPU buffering and/or v-sync buffering. A value of zero will make 50% of frames go (mostly slightly) into buffering, since for most games, the prediction is so accurate that it will average out to 0 microseconds.
+
+For 360 fps gameplay, you may want to experiment with values in the range of -100 to 100. For less fps, you may want to use larger values respectively.
+
+The offset is applied after predictions have been made to align the frame, but doesn't affect fps limiting.
+
+#### dxvk.lowLatencyAllowCpuFramesOverlap
+
+In case a game is generating a very high load (or specific load) on dxvk's CS thread (see `DXVK_HUD=cs`), setting `dxvk.lowLatencyAllowCpuFramesOverlap = False` will prevent the CS thread queue to create additional latency. 
+
+Can be set to `False` on a game by game basis. By default, this option is set to `True`, because setting it to `False` can lead to certain type of stutters being magnified, for example from shader compiling, which can lead to strong fps loss in those cases.
+
+### Additional considerations
+
+#### Frame pipelining
+
+Generating one frame of a video game typically can be seen as a sequence of the following operations:
+
+`input sampling -> frame simulation -> frame rendering -> present()`
+
+This frame pacing relies on games/engines following the simple principle of starting to process a new frame after finishing the previous one by calling the present() method of D3D. In the author's opinion, most games are actually doing this (at least for mouse input), as this is baked into the Direct 3D methodology, and games which care for input lag basically don't have another option. 
+
+However, this is not guaranteed. There may be games out there not following this principle. For those, perfect frame pacing is impossible to achieve in the D3D domain.
+
+#### Display Manager Presentation
+
+When dxvk is finished rendering a frame, the resulting image still needs to be transported to the display which is relevant for latency too. 
+
+Since there is not that much information available on this topic, the author has tested some configurations which may help you to make an informed decision. The following results were obtained running a game at 1800 fps, which has the option to flash a monitor region instantly during a mouse button press, such that Nvidia's Reflex Analyzer can be used to measure button-to-pixel latency on an Nvidia GPU (575.57.08 driver). These results may or may not be applicable to other hardware/drivers like AMD or Intel GPUs. 
+
+The top of the screen was selected as monitor region to make VRR, Mailbox and V-Sync more comparable to tearing (Immediate) in terms of latency. Since the measured latency will depend on the state of the screen refresh when the mouse button was pressed, many such samples give a latency range. Note that Wine Wayland is still experimental (June 2025):
+
+| Presentation      | Latency | fps |
+| :---------------- | :------: | :----: |
+| x11 flip immediate      |   1.0-4.1 ms   | 1700 fps |
+| x11 flip v-sync         |   5.9-8.8 ms   | 360 fps |
+|  |  |  |
+| Xwayland mailbox KDE   |  4.5-7.3 ms     | 1800 fps |
+| Xwayland v-sync KDE    |  11.9-14.7 ms   | 360 fps |
+| Wine Wayland mailbox KDE   |  6.4-9.1 ms     | 360 fps | ## muss ich rechecken
+| Wine Wayland v-sync KDE    |  5.5-8.3 ms  | 360 fps |
+|  |  |  |
+| Xwayland mailbox Gnome    |  3.7-6.4 ms  | 1800 fps |
+| Xwayland v-sync Gnome    |  12.1-14.9 ms  | 360 fps |
+| Wine Wayland mailbox Gnome    |  7.3-10.8 ms  | 1400 fps |
+| Wine Wayland v-sync Gnome    |  5.9-8.7 ms  | 360 fps |
+|  |  |  |
+| x11 flip v-sync VRR | 1.4-4.4 ms | 357 fps |
+| Wine Wayland KDE VRR| 1.7-4.6 ms | 357 fps |
+| Wine Wayland Gnome VRR| 2.0-4.9 ms | 357 fps |
+
+If you want to use x11, be sure that flip is enabled. This only works on single monitor configurations. On Nvidia, you can check if flip is enabled with `__GL_SHOW_GRAPHICS_OSD=1`. Gnome has had trouble to activate flip with Proton 10, but should work fine with Proton 9. KDE should enable flip pretty straight forward, as does startx and possibly other lightweight window managers.
+
+#### Wiki
+
+There are more things relevant to latency. SMT/Hyperthreading for example may increase latency by about 10% and may increase frame time variance depending on the game. SMT doesn't need to get disabled in BIOS, it can be turned on and off via command line too:
+
+`sudo sh -c "echo off > /sys/devices/system/cpu/smt/control"`
+
+The kernel/scheduler also plays a role for latency.
+
+There will be a wiki section soon, discussing all these latency topics not directly related to dxvk.
+
+#### Original behaviour
+
+When `dxvk.framePace = "max-frame-latency"` and `dxvk.latencySleep = Auto` are set, dxvk low-latency will behave exactly how upstream dxvk does.
+
+
+
+# DXVK (Original Description)
 
 A Vulkan-based translation layer for Direct3D 8/9/10/11 which allows running 3D applications on Linux using Wine.
 

From 776085c9c2cf06853f1fb97f1450b2564ce96af3 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Mon, 7 Jul 2025 14:41:21 +0200
Subject: [PATCH 30/81] [build] Don't use designated initializers to fix MSVC
 build

Well, it's a c++20 feature, but we still use c++17 and gcc is somehow fine with designated initializers.
---
 src/dxvk/framepacer/dxvk_presentation_stats.h | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/src/dxvk/framepacer/dxvk_presentation_stats.h b/src/dxvk/framepacer/dxvk_presentation_stats.h
index ebadcd86573..b6174a9f8be 100644
--- a/src/dxvk/framepacer/dxvk_presentation_stats.h
+++ b/src/dxvk/framepacer/dxvk_presentation_stats.h
@@ -24,10 +24,9 @@ namespace dxvk {
       ++m_buckets[index];
       ++m_numLatencies;
 
-      QueueItem item = {
-        .timeStamp = t,
-        .latency   = latency
-      };
+      QueueItem item;
+      item.timeStamp = t;
+      item.latency   = latency;
 
       m_queue.push_back(item);
 

From 605fb1d89f5ca5ee6be61f0ba2444e013c87bca7 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Tue, 8 Jul 2025 02:40:08 +0200
Subject: [PATCH 31/81] [build] No artifacts for every push

---
 .github/workflows/artifacts.yml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/.github/workflows/artifacts.yml b/.github/workflows/artifacts.yml
index f61cecfc24e..6ec82523e01 100644
--- a/.github/workflows/artifacts.yml
+++ b/.github/workflows/artifacts.yml
@@ -1,6 +1,6 @@
 name: Artifacts (Package)
 
-on: [push, pull_request, workflow_dispatch]
+on: [pull_request, workflow_dispatch]
 
 jobs:
   artifacts-mingw-w64:

From d7a0a28da98c1acff53ff78c3da6611a5d941ddc Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Tue, 8 Jul 2025 02:41:44 +0200
Subject: [PATCH 32/81] [build] No builds for every push

---
 .github/workflows/test-build-windows.yml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/.github/workflows/test-build-windows.yml b/.github/workflows/test-build-windows.yml
index eb8a4518d45..80feca3015a 100644
--- a/.github/workflows/test-build-windows.yml
+++ b/.github/workflows/test-build-windows.yml
@@ -1,6 +1,6 @@
 name: Test Builds on Windows
 
-on: [push, pull_request, workflow_dispatch]
+on: [pull_request, workflow_dispatch]
 
 jobs:
   build-set-windows:

From 6214a6a26dd8af8d6b876744d82657f6b0581abf Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Thu, 10 Jul 2025 03:46:38 +0200
Subject: [PATCH 33/81] [dxvk] Change maxPushConstantsSize (TotalPushDataSize)
 from 256 to 128

Allows DXVK to work properly on drivers that have maxPushConstantsSize = 128
DXVK minimum requirements for maxPushConstantsSize is 64 - Link:  https://github.com/doitsujin/dxvk/commit/1261b2a1b56118bdb2698e8c950900a2a48fe220
---
 src/dxvk/dxvk_limits.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_limits.h b/src/dxvk/dxvk_limits.h
index 87de5aa35b2..069eba45f80 100644
--- a/src/dxvk/dxvk_limits.h
+++ b/src/dxvk/dxvk_limits.h
@@ -19,7 +19,7 @@ namespace dxvk {
     MaxNumSpecConstants         =    12,
     MaxUniformBufferSize        = 65536,
     MaxVertexBindingStride      =  2048,
-    MaxTotalPushDataSize        =   256,
+    MaxTotalPushDataSize        =   128,
     MaxSharedPushDataSize       =    64,
     MaxPerStagePushDataSize     =    32,
     MaxReservedPushDataSize     =    32,

From 782223eebeca16b05ef20086f488992ab0b9960b Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Thu, 10 Jul 2025 03:54:13 +0200
Subject: [PATCH 34/81] [dxvk] Change maxPushConstantsSize (TotalPushDataSize)
 from 256 to 128

Allows DXVK to work properly on drivers that have maxPushConstantsSize = 128
DXVK minimum requirements for maxPushConstantsSize is 64 - Link:  https://github.com/doitsujin/dxvk/commit/1261b2a1b56118bdb2698e8c950900a2a48fe220
---
 VP_DXVK_requirements.json | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/VP_DXVK_requirements.json b/VP_DXVK_requirements.json
index ccca75805d9..c4719e96f5a 100644
--- a/VP_DXVK_requirements.json
+++ b/VP_DXVK_requirements.json
@@ -94,13 +94,13 @@
             },
             "properties": {
                 "VkPhysicalDeviceProperties": {
-                    "maxPushConstantsSize" : 256
+                    "maxPushConstantsSize" : 128
                 }
             }
         },
         "dxvk_common_optional": {
             "extensions": {
-                "VK_KHR_load_store_op_none": 1,
+                "VK_EXT_load_store_op_none": 1,
                 "VK_KHR_maintenance6": 1,
                 "VK_KHR_maintenance7": 1,
                 "VK_KHR_present_id": 1,

From 6afddf418834c370a9a1cf8ecaa1cf59c76048b6 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Fri, 11 Jul 2025 01:15:32 +0200
Subject: [PATCH 35/81] [dxvk] Adapt VK_EXT_LOAD_STORE_OP_NONE enablement for
 DXVK-GPLALL 2.7

---
 src/dxvk/dxvk_context.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_context.cpp b/src/dxvk/dxvk_context.cpp
index a394e7056b9..695b82ab0f1 100644
--- a/src/dxvk/dxvk_context.cpp
+++ b/src/dxvk/dxvk_context.cpp
@@ -2651,7 +2651,7 @@ namespace dxvk {
     if (access == DxvkAccess::None) {
       // If the attachment is not accessed at all, we can set both the
       // load and store op to NONE if supported by the implementation.
-      bool hasLoadOpNone = m_device->features().khrLoadStoreOpNone;
+      bool hasLoadOpNone = m_device->features().extLoadStoreOpNone;
 
       attachment.loadOp = hasLoadOpNone
         ? VK_ATTACHMENT_LOAD_OP_NONE

From a4fba696a3f04bdd3b22b40ce9f2365d04bb5a53 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Fri, 11 Jul 2025 01:17:26 +0200
Subject: [PATCH 36/81] [dxvk] Adapt VK_EXT_LOAD_STORE_OP_NONE enablement for
 DXVK-GPLALL 2.7

---
 src/dxvk/dxvk_device_info.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/dxvk/dxvk_device_info.cpp b/src/dxvk/dxvk_device_info.cpp
index 9a45f10ae25..ec45aa311bb 100644
--- a/src/dxvk/dxvk_device_info.cpp
+++ b/src/dxvk/dxvk_device_info.cpp
@@ -42,7 +42,7 @@ namespace dxvk {
     HANDLE_EXT(extVertexAttributeDivisor);         \
     HANDLE_EXT(khrExternalMemoryWin32);            \
     HANDLE_EXT(khrExternalSemaphoreWin32);         \
-    HANDLE_EXT(khrLoadStoreOpNone);                \
+    HANDLE_EXT(extLoadStoreOpNone);                \
     HANDLE_EXT(khrMaintenance5);                   \
     HANDLE_EXT(khrMaintenance6);                   \
     HANDLE_EXT(khrMaintenance7);                   \
@@ -867,7 +867,7 @@ namespace dxvk {
       ENABLE_EXT(khrExternalSemaphoreWin32, false),
 
       /* LOAD_OP_NONE for certain tiler optimizations */
-      ENABLE_EXT(khrLoadStoreOpNone, false),
+      ENABLE_EXT(extLoadStoreOpNone, false),
 
       /* Maintenance features, relied on in various parts of the code */
       ENABLE_EXT_FEATURE(khrMaintenance5, maintenance5, true),

From 6b0c7440f5d70a803274a8caa50e57cfb8fb3898 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Fri, 11 Jul 2025 01:19:39 +0200
Subject: [PATCH 37/81] [dxvk] Adapt VK_EXT_LOAD_STORE_OP_NONE enablement for
 DXVK-GPLALL 2.7

---
 src/dxvk/dxvk_device_info.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/dxvk/dxvk_device_info.h b/src/dxvk/dxvk_device_info.h
index 1fb8374fa2d..3311313738b 100644
--- a/src/dxvk/dxvk_device_info.h
+++ b/src/dxvk/dxvk_device_info.h
@@ -80,7 +80,7 @@ namespace dxvk {
     VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT         extVertexAttributeDivisor       = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES };
     VkBool32                                                  khrExternalMemoryWin32          = VK_FALSE;
     VkBool32                                                  khrExternalSemaphoreWin32       = VK_FALSE;
-    VkBool32                                                  khrLoadStoreOpNone              = VK_FALSE;
+    VkBool32                                                  extLoadStoreOpNone              = VK_FALSE;
     VkPhysicalDeviceMaintenance5FeaturesKHR                   khrMaintenance5                 = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR };
     VkPhysicalDeviceMaintenance6FeaturesKHR                   khrMaintenance6                 = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR };
     VkPhysicalDeviceMaintenance7FeaturesKHR                   khrMaintenance7                 = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR };
@@ -137,7 +137,7 @@ namespace dxvk {
     VkExtensionProperties extVertexAttributeDivisor         = vk::makeExtension(VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME);
     VkExtensionProperties khrExternalMemoryWin32            = vk::makeExtension(VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME);
     VkExtensionProperties khrExternalSemaphoreWin32         = vk::makeExtension(VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME);
-    VkExtensionProperties khrLoadStoreOpNone                = vk::makeExtension(VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME);
+    VkExtensionProperties extLoadStoreOpNone                = vk::makeExtension(VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME);
     VkExtensionProperties khrMaintenance5                   = vk::makeExtension(VK_KHR_MAINTENANCE_5_EXTENSION_NAME);
     VkExtensionProperties khrMaintenance6                   = vk::makeExtension(VK_KHR_MAINTENANCE_6_EXTENSION_NAME);
     VkExtensionProperties khrMaintenance7                   = vk::makeExtension(VK_KHR_MAINTENANCE_7_EXTENSION_NAME);

From 1883e6bd077d36843279287ea5014ecd199b7f60 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Fri, 11 Jul 2025 01:44:26 +0200
Subject: [PATCH 38/81] [build] Adapt meson.build for DXVK-GPLALL 2.7

---
 meson.build | 27 +++++++++++++++++++++------
 1 file changed, 21 insertions(+), 6 deletions(-)

diff --git a/meson.build b/meson.build
index 20b86953ce9..a683f74c02e 100644
--- a/meson.build
+++ b/meson.build
@@ -10,10 +10,16 @@ cc = meson.get_compiler('c')
 dxvk_is_msvc = cpp.get_argument_syntax() == 'msvc'
 
 compiler_args = [
+  '-O3',
+  '-pipe',
+  '-march=x86-64',
+  '-mtune=x86-64',
   '-msse',
   '-msse2',
-  '-msse3',
   '-mfpmath=sse',
+  '-fno-semantic-interposition',
+  '-flto=auto',
+  '-fuse-linker-plugin',
   '-Wimplicit-fallthrough',
   # gcc
   '-Wno-missing-field-initializers',
@@ -28,7 +34,9 @@ compiler_args = [
   '-Wno-missing-braces',
 ]
 
-link_args = []
+link_args = [
+  '-s',
+]
 
 if get_option('build_id')
   link_args += [
@@ -92,14 +100,21 @@ if platform == 'windows'
       ]
     endif
   else
-    # setup file alignment + enable PDB output for MSVC builds
-    # PDBs are useful for Windows consumers of DXVK 
+    # Windows (MSVC) Compiler Options
     compiler_args += [
-      '/Z7'
+      '/arch:SSE2',
+      '/O2',
+      '/Ob3',
+      '/GL',
+      '/Gw'
     ]
+    # MSVC Linker Options
     link_args += [
       '/FILEALIGN:4096',
-      '/DEBUG:FULL'
+      '/INCREMENTAL:NO',
+      '/OPT:REF,ICF',
+      '/LTCG',
+      '/DEBUG:NONE'
     ]
   endif
 

From 9e24b9c7451206fab30cc76db610cec69227dad9 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Fri, 11 Jul 2025 04:09:06 +0200
Subject: [PATCH 39/81] [dxvk] Port changes to workerCount logic for
 DXVK-GPLALL 2.7

---
 src/dxvk/dxvk_pipemanager.cpp | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_pipemanager.cpp b/src/dxvk/dxvk_pipemanager.cpp
index b0b03f9f8fe..18f907002f6 100644
--- a/src/dxvk/dxvk_pipemanager.cpp
+++ b/src/dxvk/dxvk_pipemanager.cpp
@@ -81,10 +81,17 @@ namespace dxvk {
 
   void DxvkPipelineWorkers::startWorkers() {
     if (!std::exchange(m_workersRunning, true)) {
-      // Use all available cores by default
+      // Get number of CPU logical threads
       uint32_t workerCount = dxvk::thread::hardware_concurrency();
 
+      // Use (number of CPU logical threads - 2) pipeline workers.
+      // Less stuttering when compiling shaders while playing,
+      // in comparison to using all CPU logical threads.
+      workerCount = workerCount - 2;
+
+      // Catching systems with less than 4 threads
       if (workerCount <  1) workerCount =  1;
+      // Catching systems with more than 64 threads
       if (workerCount > 64) workerCount = 64;
 
       // Reduce worker count on 32-bit to save adderss space

From 302f900da61022c5c584976cc2dfa7e7e654006b Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Fri, 11 Jul 2025 04:22:09 +0200
Subject: [PATCH 40/81] [hud] Port changes to info item for DXVK-GPLALL 2.7

---
 src/dxvk/hud/dxvk_hud_item.cpp | 23 ++++++++++++-----------
 1 file changed, 12 insertions(+), 11 deletions(-)

diff --git a/src/dxvk/hud/dxvk_hud_item.cpp b/src/dxvk/hud/dxvk_hud_item.cpp
index 141618faf33..e1349104509 100644
--- a/src/dxvk/hud/dxvk_hud_item.cpp
+++ b/src/dxvk/hud/dxvk_hud_item.cpp
@@ -105,7 +105,7 @@ namespace dxvk::hud {
           HudRenderer&        renderer,
           HudPos              position) {
     position.y += 16;
-    renderer.drawText(16, position, 0xffffffffu, "DXVK-LOW-LATENCY " DXVK_VERSION);
+    renderer.drawText(16, position, 0xffffffffu, "DXVK-GPLALL " DXVK_VERSION);
 
     position.y += 8;
     return position;
@@ -140,16 +140,17 @@ namespace dxvk::hud {
 
 
   HudDeviceInfoItem::HudDeviceInfoItem(const Rc<DxvkDevice>& device) {
-    const auto& props = device->properties();
-
-    std::string driverInfo = props.vk12.driverInfo;
-
-    if (driverInfo.empty())
-      driverInfo = props.driverVersion.toString();
-
-    m_deviceName = props.core.properties.deviceName;
-    m_driverName = str::format("Driver:  ", props.vk12.driverName);
-    m_driverVer = str::format("Version: ", driverInfo);
+    VkPhysicalDeviceProperties props = device->adapter()->deviceProperties();
+
+    m_deviceName = props.deviceName;
+    m_vulkanVer = str::format("VLK: ",
+      VK_VERSION_MAJOR(props.apiVersion), ".",
+      VK_VERSION_MINOR(props.apiVersion), ".",
+      VK_VERSION_PATCH(props.apiVersion));
+    m_driverVer = str::format("VLK Drv: ",
+      VK_VERSION_MAJOR(props.driverVersion), ".",
+      VK_VERSION_MINOR(props.driverVersion), ".",
+      VK_VERSION_PATCH(props.driverVersion));
   }
 
 

From 99488fbee82baa6a253a8b3fc29f07f87a01aa2a Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Fri, 11 Jul 2025 04:23:18 +0200
Subject: [PATCH 41/81] [hud] Port changes to info item for DXVK-GPLALL 2.7

---
 src/dxvk/hud/dxvk_hud_item.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/dxvk/hud/dxvk_hud_item.h b/src/dxvk/hud/dxvk_hud_item.h
index c92e5a4d859..6ad2db2e9fc 100644
--- a/src/dxvk/hud/dxvk_hud_item.h
+++ b/src/dxvk/hud/dxvk_hud_item.h
@@ -216,7 +216,7 @@ namespace dxvk::hud {
   private:
 
     std::string m_deviceName;
-    std::string m_driverName;
+    std::string m_vulkanVer;
     std::string m_driverVer;
 
   };

From 36e9eac70da08405f3f938852abcac99bd3fe97a Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 13 Jul 2025 04:08:21 +0200
Subject: [PATCH 42/81] [util] Port changes from dxvk-gplasync

---
 src/util/config/config.cpp | 15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

diff --git a/src/util/config/config.cpp b/src/util/config/config.cpp
index c9864798c61..a29fd96e01f 100644
--- a/src/util/config/config.cpp
+++ b/src/util/config/config.cpp
@@ -1615,8 +1615,19 @@ namespace dxvk {
     // Open the file if it exists
     std::ifstream stream(str::topath(filePath.c_str()).c_str());
 
-    if (!stream && confLine.empty())
-      return config;
+    if (!stream && confLine.empty()) {
+      filePath = "/home/" + env::getEnvVar("USER") + "/.config/dxvk.conf";
+      stream.open(str::topath(filePath.c_str()).c_str());
+#ifdef _WIN32
+      if (!stream) {
+		    filePath = env::getEnvVar("APPDATA") + "/dxvk.conf";
+        stream.open(str::topath(filePath.c_str()).c_str());
+      }
+#endif
+
+		  if (!stream)
+			  return config;
+    }
 
     // Initialize parser context
     ConfigContext ctx;

From 48da110324c76098c7f8decdee3ec4677e6f7a59 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 13 Jul 2025 04:50:45 +0200
Subject: [PATCH 43/81] [build] Port dxvk-gplasync changes to DXVK-GPLALL 2.7

---
 meson.build | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/meson.build b/meson.build
index a683f74c02e..e45bb5439d8 100644
--- a/meson.build
+++ b/meson.build
@@ -214,7 +214,7 @@ glsl_generator = generator(
 )
 
 dxvk_version = vcs_tag(
-  command: ['git', 'describe', '--dirty=+'],
+  command: ['git', 'describe', '--dirty=-gplall'],
   input:  'version.h.in',
   output: 'version.h',
 )

From d5652aef97e724fcedcd0d925eeb802313420dae Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 13 Jul 2025 04:52:41 +0200
Subject: [PATCH 44/81] [dxvk] Port dxvk-gplasync changes to DXVK-GPLALL 2.7

---
 src/dxvk/dxvk_context.cpp | 20 +++++++++++++++++---
 1 file changed, 17 insertions(+), 3 deletions(-)

diff --git a/src/dxvk/dxvk_context.cpp b/src/dxvk/dxvk_context.cpp
index 695b82ab0f1..ed3315aec2c 100644
--- a/src/dxvk/dxvk_context.cpp
+++ b/src/dxvk/dxvk_context.cpp
@@ -6075,7 +6075,8 @@ namespace dxvk {
                          DxvkContextFlag::GpDirtyDepthBias));
 
     // Retrieve and bind actual Vulkan pipeline handle
-    auto pipelineInfo = m_state.gp.pipeline->getPipelineHandle(m_state.gp.state);
+    auto pipelineInfo = m_state.gp.pipeline->getPipelineHandle(m_state.gp.state,
+      this->checkAsyncCompilationCompat());
 
     if (unlikely(!pipelineInfo.handle))
       return false;
@@ -6714,7 +6715,7 @@ namespace dxvk {
   }
 
 
-  void DxvkContext::updateRenderTargets() {
+  void DxvkContext::updateRenderTargets(bool isDraw) {
     if (m_flags.test(DxvkContextFlag::GpDirtyRenderTargets)) {
       m_flags.clr(DxvkContextFlag::GpDirtyRenderTargets);
 
@@ -6755,6 +6756,11 @@ namespace dxvk {
 
       m_state.om.framebufferInfo = std::move(fbInfo);
 
+      if (isDraw) {
+        for (uint32_t i = 0; i < fbInfo.numAttachments(); i++)
+          fbInfo.getAttachment(i).view->setRtBindingFrameId(m_device->getCurrentFrameId());
+      }
+
       m_flags.set(DxvkContextFlag::GpDirtyPipelineState);
     } else if (m_flags.test(DxvkContextFlag::GpRenderPassNeedsFlush)) {
       // End render pass to flush pending resolves
@@ -6762,6 +6768,14 @@ namespace dxvk {
     }
   }
 
+  bool DxvkContext::checkAsyncCompilationCompat() const {
+    for (uint32_t i = 0; i < m_state.om.framebufferInfo.numAttachments(); i++) {
+      const auto& [view] = m_state.om.framebufferInfo.getAttachment(i);
+      if (!view->getRtBindingAsyncCompilationCompat())
+        return false;
+    }
+    return true;
+  }
 
   void DxvkContext::applyRenderTargetLoadLayouts() {
     for (uint32_t i = 0; i < MaxNumRenderTargets; i++)
@@ -7428,7 +7442,7 @@ namespace dxvk {
     // End render pass if there are pending resolves
     if (m_flags.any(DxvkContextFlag::GpDirtyRenderTargets,
                     DxvkContextFlag::GpRenderPassNeedsFlush))
-      this->updateRenderTargets();
+      this->updateRenderTargets(true);
 
     if (m_flags.test(DxvkContextFlag::GpXfbActive)) {
       // If transform feedback is active and there is a chance that we might

From dca81d5620e5b92385fafaafd2f94c7b1b23a8bc Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 13 Jul 2025 04:53:52 +0200
Subject: [PATCH 45/81] [dxvk] Port dxvk-gplasync changes to DXVK-GPLALL 2.7

---
 src/dxvk/dxvk_context.h | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_context.h b/src/dxvk/dxvk_context.h
index 2389c0c955e..ee0e294051b 100644
--- a/src/dxvk/dxvk_context.h
+++ b/src/dxvk/dxvk_context.h
@@ -1723,7 +1723,7 @@ namespace dxvk {
     DxvkFramebufferInfo makeFramebufferInfo(
       const DxvkRenderTargets&      renderTargets);
 
-    void updateRenderTargets();
+    void updateRenderTargets(bool isDraw = false);
     
     void applyRenderTargetLoadLayouts();
 
@@ -1856,6 +1856,8 @@ namespace dxvk {
     Rc<DxvkSampler> createBlitSampler(
             VkFilter                  filter);
 
+    [[nodiscard]] bool checkAsyncCompilationCompat() const;
+
     DxvkGraphicsPipeline* lookupGraphicsPipeline(
       const DxvkGraphicsPipelineShaders&  shaders);
 

From ae8e0f79eece02b7cb2e49f074d8086e3dc13e42 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 13 Jul 2025 04:56:29 +0200
Subject: [PATCH 46/81] [dxvk] Port dxvk-gplasync changes to DXVK-GPLALL 2.7

---
 src/dxvk/dxvk_graphics.cpp | 20 +++++++++++++++++---
 1 file changed, 17 insertions(+), 3 deletions(-)

diff --git a/src/dxvk/dxvk_graphics.cpp b/src/dxvk/dxvk_graphics.cpp
index b9fbaadc654..f9d0878d454 100644
--- a/src/dxvk/dxvk_graphics.cpp
+++ b/src/dxvk/dxvk_graphics.cpp
@@ -1061,7 +1061,8 @@ namespace dxvk {
 
 
   DxvkGraphicsPipelineHandle DxvkGraphicsPipeline::getPipelineHandle(
-    const DxvkGraphicsPipelineStateInfo& state) {
+    const DxvkGraphicsPipelineStateInfo& state,
+    const bool                           async) {
     DxvkGraphicsPipelineInstance* instance = this->findInstance(state);
 
     if (unlikely(!instance)) {
@@ -1069,11 +1070,22 @@ namespace dxvk {
       if (!this->validatePipelineState(state, true))
         return DxvkGraphicsPipelineHandle();
 
+      const bool useAsync = async && m_device->config().enableAsync && env::getEnvVar("DXVK_ASYNC") != "0";
+
       // Prevent other threads from adding new instances and check again
-      std::unique_lock<dxvk::mutex> lock(m_mutex);
+      std::unique_lock<dxvk::mutex> lock(useAsync ? m_asyncMutex : m_mutex);
       instance = this->findInstance(state);
 
       if (!instance) {
+        if (useAsync) {
+          m_async.store(true, std::memory_order_release);
+          lock.unlock();
+
+          m_workers->compileGraphicsPipeline(this, state, DxvkPipelinePriority::High);
+
+          return DxvkGraphicsPipelineHandle();
+        }
+
         // Keep pipeline object locked, at worst we're going to stall
         // a state cache worker and the current thread needs priority.
         bool canCreateBasePipeline = this->canCreateBasePipeline(state);
@@ -1108,7 +1120,7 @@ namespace dxvk {
 
       // Do not compile if this pipeline can be fast linked. This essentially
       // disables the state cache for pipelines that do not benefit from it.
-      if (this->canCreateBasePipeline(state))
+      if (!m_async.load(std::memory_order_acquire) && this->canCreateBasePipeline(state))
         return;
 
       // Prevent other threads from adding new instances and check again
@@ -1384,6 +1396,8 @@ namespace dxvk {
     if (handle)
       m_fastPipelines.insert({ key, handle });
 
+    m_async.store(false, std::memory_order_release);
+
     return handle;
   }
 

From dab04d003d09ccdf11d5d14b8aae1975a9245c66 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 13 Jul 2025 04:58:14 +0200
Subject: [PATCH 47/81] [dxvk] Port dxvk-gplasync changes to DXVK-GPLALL 2.7

---
 src/dxvk/dxvk_graphics.h | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/dxvk/dxvk_graphics.h b/src/dxvk/dxvk_graphics.h
index 3f0bcffe19c..956d1ed1093 100644
--- a/src/dxvk/dxvk_graphics.h
+++ b/src/dxvk/dxvk_graphics.h
@@ -550,11 +550,13 @@ namespace dxvk {
      * Retrieves a pipeline handle for the given pipeline
      * state. If necessary, a new pipeline will be created.
      * \param [in] state Pipeline state vector
+     * \param [in] async Compile asynchronously
      * \returns Pipeline handle and handle type
      */
     DxvkGraphicsPipelineHandle getPipelineHandle(
-      const DxvkGraphicsPipelineStateInfo&    state);
-    
+      const DxvkGraphicsPipelineStateInfo&    state,
+            bool                              async);
+
     /**
      * \brief Compiles a pipeline
      * 
@@ -617,6 +619,11 @@ namespace dxvk {
 
     alignas(CACHE_LINE_SIZE)
     dxvk::mutex                                   m_mutex;
+    alignas(CACHE_LINE_SIZE)
+    dxvk::mutex                                   m_asyncMutex;
+
+    std::atomic<bool>                             m_async{false};
+
     sync::List<DxvkGraphicsPipelineInstance>      m_pipelines;
     uint32_t                                      m_useCount = 0;
 

From 26ded8bdf441e6dddda5d9a9be3cd0364a6b0aea Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 13 Jul 2025 04:59:42 +0200
Subject: [PATCH 48/81] [dxvk] Port dxvk-gplasync changes to DXVK-GPLALL 2.7

---
 src/dxvk/dxvk_image.h | 34 ++++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/src/dxvk/dxvk_image.h b/src/dxvk/dxvk_image.h
index 63cba2819dd..c3e2b3479b5 100644
--- a/src/dxvk/dxvk_image.h
+++ b/src/dxvk/dxvk_image.h
@@ -274,6 +274,37 @@ namespace dxvk {
           && this->info().format   == view->info().format;
     }
 
+    /**
+     * \brief Sets render target usage frame number
+     *
+     * The image view will track internally when
+     * it was last used as a render target. This
+     * info is used for async shader compilation.
+     * \param [in] frameId Frame number+     */
+    void setRtBindingFrameId(const uint32_t frameId) {
+      if (frameId != m_rtBindingFrameId) {
+        if (frameId == m_rtBindingFrameId + 1)
+          m_rtBindingFrameCount += 1;
+        else
+          m_rtBindingFrameCount = 0;
+
+        m_rtBindingFrameId = frameId;
+      }
+    }
+
+    /**
+     * \brief Checks for async pipeline compatibility
+     *
+     * Asynchronous pipeline compilation may be enabled if the
+     * render target has been drawn to in the previous frames.
+     * \param [in] frameId Current frame ID
+     * \returns \c true if async compilation is supported
+     */
+    [[nodiscard]] bool getRtBindingAsyncCompilationCompat() const {
+      return m_rtBindingFrameCount >= 5;
+    }
+
+
     /**
      * \brief Checks whether this view overlaps with another one
      *
@@ -327,6 +358,9 @@ namespace dxvk {
 
     std::array<const DxvkDescriptor*, ViewCount> m_views = { };
 
+    uint32_t m_rtBindingFrameId    = 0;
+    uint32_t m_rtBindingFrameCount = 0;
+
     const DxvkDescriptor* createView(VkImageViewType type) const;
 
     void updateViews();

From b0dec042853987ca4f737dc466905d686df02de5 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 13 Jul 2025 05:00:46 +0200
Subject: [PATCH 49/81] [dxvk] Port dxvk-gplasync changes to DXVK-GPLALL 2.7

---
 src/dxvk/dxvk_options.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/dxvk/dxvk_options.cpp b/src/dxvk/dxvk_options.cpp
index cc02723e83a..eac84c66424 100644
--- a/src/dxvk/dxvk_options.cpp
+++ b/src/dxvk/dxvk_options.cpp
@@ -3,6 +3,7 @@
 namespace dxvk {
 
   DxvkOptions::DxvkOptions(const Config& config) {
+    enableAsync           = config.getOption<bool>    ("dxvk.enableAsync",            true);
     enableDebugUtils      = config.getOption<bool>    ("dxvk.enableDebugUtils",       false);
     enableMemoryDefrag    = config.getOption<Tristate>("dxvk.enableMemoryDefrag",     Tristate::Auto);
     numCompilerThreads    = config.getOption<int32_t> ("dxvk.numCompilerThreads",     0);

From 4ef3032d0d41bb50295b720d324e127ff489b019 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 13 Jul 2025 05:01:48 +0200
Subject: [PATCH 50/81] [dxvk] Port dxvk-gplasync changes to DXVK-GPLALL 2.7

---
 src/dxvk/dxvk_options.h | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/dxvk/dxvk_options.h b/src/dxvk/dxvk_options.h
index 0702f0ae922..be9ecd438d5 100644
--- a/src/dxvk/dxvk_options.h
+++ b/src/dxvk/dxvk_options.h
@@ -29,6 +29,9 @@ namespace dxvk {
     /// Enables pipeline lifetime tracking
     Tristate trackPipelineLifetime = Tristate::Auto;
 
+    /// Enable async pipelines
+    bool enableAsync = true;
+
     /// Shader-related options
     Tristate useRawSsbo = Tristate::Auto;
 

From 6a3f44199e6f23c5d2a70ecd4e7b3dd9d1fee298 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 13 Jul 2025 05:13:00 +0200
Subject: [PATCH 51/81] [dxvk] Disable GPL in DXVK-GPLALL 2.7

---
 src/dxvk/dxvk_options.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_options.cpp b/src/dxvk/dxvk_options.cpp
index eac84c66424..169a746bb54 100644
--- a/src/dxvk/dxvk_options.cpp
+++ b/src/dxvk/dxvk_options.cpp
@@ -7,7 +7,7 @@ namespace dxvk {
     enableDebugUtils      = config.getOption<bool>    ("dxvk.enableDebugUtils",       false);
     enableMemoryDefrag    = config.getOption<Tristate>("dxvk.enableMemoryDefrag",     Tristate::Auto);
     numCompilerThreads    = config.getOption<int32_t> ("dxvk.numCompilerThreads",     0);
-    enableGraphicsPipelineLibrary = config.getOption<Tristate>("dxvk.enableGraphicsPipelineLibrary", Tristate::Auto);
+    enableGraphicsPipelineLibrary = config.getOption<Tristate>("dxvk.enableGraphicsPipelineLibrary", Tristate::False);
     enableDescriptorBuffer = config.getOption<Tristate>("dxvk.enableDescriptorBuffer", Tristate::Auto);
     trackPipelineLifetime = config.getOption<Tristate>("dxvk.trackPipelineLifetime",  Tristate::Auto);
     useRawSsbo            = config.getOption<Tristate>("dxvk.useRawSsbo",             Tristate::Auto);

From 5297cbbb2f4e8db98c2b9a1870cd3a45b30af04a Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 13 Jul 2025 05:15:23 +0200
Subject: [PATCH 52/81] [dxvk] Disable GPL in DXVK-GPLALL 2.7

---
 src/dxvk/dxvk_options.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_options.h b/src/dxvk/dxvk_options.h
index be9ecd438d5..8ae2e492fa1 100644
--- a/src/dxvk/dxvk_options.h
+++ b/src/dxvk/dxvk_options.h
@@ -21,7 +21,7 @@ namespace dxvk {
     int32_t numCompilerThreads = 0;
 
     /// Enable graphics pipeline library
-    Tristate enableGraphicsPipelineLibrary = Tristate::Auto;
+    Tristate enableGraphicsPipelineLibrary = Tristate::False;
 
     /// Enable descriptor buffer
     Tristate enableDescriptorBuffer = Tristate::Auto;

From 789e49e2a2b6b4f2ca7c0c15603206c7e720a061 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 13 Jul 2025 05:18:27 +0200
Subject: [PATCH 53/81] [dxvk] Adapt dxvk.conf for DXVK-GPLALL 2.7

---
 dxvk.conf | 142 +++++++++++++++++++++++++++++++++++++++++-------------
 1 file changed, 108 insertions(+), 34 deletions(-)

diff --git a/dxvk.conf b/dxvk.conf
index 8b305d8aa6a..b78dd1d4916 100644
--- a/dxvk.conf
+++ b/dxvk.conf
@@ -1,3 +1,22 @@
+# dxvk.conf Config File Location
+
+# By default, DXVK has built-in configs 
+# https://github.com/doitsujin/dxvk/blob/master/src/util/config/config.cpp
+# for specific games and GPU drivers. If user needs to change default DXVK settings, 
+# then it can be done by changing default settings in dxvk.conf configuration file 
+# or by using DXVK_CONFIG environment variable.
+
+# User can create dxvk.conf configuration file at 
+# application's main executable folder (per-application configuration file - first priority) 
+# or at %APPDATA%/dxvk.conf (one global configuration file - second priority) for Windows OS 
+# or at /home/$USER/.config/dxvk.conf (one global configuration file - second priority) for Linux/MacOS.
+# User can change default dxvk.conf global coniguration file location 
+# by specifying path in DXVK_CONFIG_FILE environment variable:
+
+# Example (Windows): DXVK_CONFIG_FILE=%USERPROFILE%/Documents/dxvk.conf
+# Example (Linux): DXVK_CONFIG_FILE=$XDG_DATA_HOME/dxvk.conf
+# Example (MacOS): DXVK_CONFIG_FILE=$HOME/Library/dxvk.conf
+
 # Device filter. Only exposes devices whose Vulkan device name contains
 # the given string. May be useful to force an application to run on a
 # specific GPU, but not applications launched by that application.
@@ -17,46 +36,100 @@
 
 # dxgi.enableHDR = True
 
-
-# Frame pacing mode managing CPU-GPU synchronization.
-# Defaults to "low-latency" in the draft-PR for demonstration purposes.
-#
-# "max-frame-latency" provides stable latency in the GPU-limit as long as
-# GPU render times are stable. Latency generally is higher but offers great
-# visual smoothness.
+# Originally started as hacky solution for shader compilation stutter in dxvk.
+# Similar solution was later added to dxvk itself and promptly removed.
+# This option allows to enable or disable that solution. 
+# Enabling this solution results in a lot less shader compilation stuttering
+# by not blocking the main thread when compiling async pipelines and 
+# (not necessarily) 
+# miscellaneous graphical issues while shaders are compiling for the first time.
 #
-# "low-latency" provides lower latency in the GPU-limit and can be fine-tuned
-# via dxvk.lowLatencyOffset and dxvk.lowLatencyAllowCpuFramesOverlap.
-#
-# "min-latency" possibly provides the lowest latency (low-latency can be
-# quicker in some situations), and offers less fps in the GPU-limit
-# due to stalling the GPU between frames. Generally not recommended,
-# but helpful to get insights to fine-tune the low-latency mode and
-# possibly is useful for running games in the CPU-limit.
-#
-# "low/min-latency" also supports its own fps-limiting enabled via common
-# variables.
+# Default: True
+# Supported values: True, False
 #
-# Supported values: "max-frame-latency", "low-latency", "min-latency"
+# DXVK_ASYNC environment variable provides control for this option too. 
+# DXVK_ASYNC=1 is equivalent to dxvk.enableAsync = True
+# DXVK_ASYNC=0 is equivalent to dxvk.enableAsync = False
 
-# dxvk.framePace = ""
+# dxvk.enableAsync = True
 
 
-# Allows fine-tuning the low-latency frame pacing mode.
-# Positive values make a frame begin later which might improve responsiveness,
-# although only very slightly, but may be relevant for edge cases.
-# Negative values make a frame begin earlier which might improve fps.
-# Values are given in microseconds. Defaults to 0.
+# Frame pacing mode managing CPU-GPU synchronization.
+#
+# "max-frame-latency" provides stable latency in the GPU-limit as long as GPU render times are stable. 
+# Latency generally is higher but offers great visual smoothness. 
+# "max-frame-latency" is the behaviour of upstream dxvk. 
+# Frame i won't start as long as frame (i-1)-x isn't finished, 
+# where x is the value of dxgi.maxFrameLatency / d3d9.#maxFrameLatency. 
+# This pacing usually looks smooth, but has latency issues when GPU bound. Optimized for highest fps.
+#
+# "min-latency" possibly provides the lowest latency (low-latency can be quicker in some situations), 
+# and offers less fps in the GPU-limit due to stalling the GPU between frames. 
+# Generally not recommended, but helpful to get insights to fine-tune the low-latency mode 
+# and possibly is useful for running games in the CPU-limit. 
+# "min-latency" is essential like max-frame-latency-0 (not selectable for the mode above), 
+# which means the start of a frame will wait until the previous one is finished. 
+# CPU/GPU no longer overlap during the transition from one frame to another 
+# and thus a lot of fps are sacrificed for prioritizing low latency. 
+# This mode is generally not recommended, but might be useful to get insights.
+#
+# "low-latency"  provides lower latency in the GPU-limit
+# and can be fine-tuned via dxvk.lowLatencyOffset and dxvk.lowLatencyAllowCpuFramesOverlap.
+#`"low-latency" is the default mode: 
+# It combines high fps throughput with excellent game responsiveness and low input lag. 
+# Looking at a scale of a few seconds, pacing is usually more accurate in time than max-frame-latency
+# since latency variations are minimized, especially when moving in and out of the GPU limit 
+# and when GPU frametimes vary a lot while being GPU bound. 
+# Looking at the pacing frame by frame, this mode relies on the game providing stable frame times for smoothness. 
+# When the game generates occasional stutters, 
+# these are filtered out nicely such that they don't interfere with the presentation of the other frames.
+#
+# "low-latency-vrr-x" is a special option, which requires to specify display refresh rate, instead of "x". 
+# For example, if user has 360 Hz VRR display, then option must be "low-latency-vrr-360". 
+# Important: Care has to be taken that the system is configured such 
+# that the display is indeed using a variable refresh rate, otherwise this mode won't work properly.
+# "low-latency-vrr-x" enhances the  "low-latency"  mode by taking v-blank information into account, 
+# which prevents additional v-sync buffering latency. 
+# This mode automatically enables v-sync to get informed when v-blanks are happening. 
+# It will make the pacer predict future v-blanks based on the given refresh rate of "x" Hz. 
+# Replace "x" with the refresh rate of your monitor. 
+# This mode works with x11-flip and native Wayland (can be enabled in Wine via DISPLAY= ), 
+# but cannot work on Xwayland because v-blank information is not available there (tested on Nvidia).
+#
+# Supported values: "max-frame-latency", "min-latency", "low-latency" and "low-latency-vrr-x", where "x" is VRR display refresh rate.
+
+# dxvk.framePace = "low-latency"
+
+
+# Allows fine-tuning the "low-latency" frame pacing mode. 
+#
+# Positive value will make frames start later by the given amount (in microseconds), 
+# which make it less likely to run into buffering and thus may improve latency. 
+# Positive value might improve responsiveness, although only very slightly, but may be relevant for edge cases. 
+# Negative values will make frames start earlier by the given amount (in microseconds), 
+# and thus those frames will more likely run into buffering, which in turns may increase fps.
+# In other words, this option has an effect on the percentage of frames which go into GPU buffering and/or v-sync buffering. 
+# A value of zero will make 50% of frames go (mostly slightly) into buffering, since for most games, 
+# the prediction is so accurate that it will average out to 0 microseconds.
+# For 360 fps gameplay, you may want to experiment with values in the range of -100 to 100. 
+# For less fps, you may want to use larger values respectively.
+# The offset is applied after predictions have been made to align the frame, but doesn't affect fps limiting.
 #
 # Supported values: -10000 to 10000
 
 # dxvk.lowLatencyOffset = 0
 
-
-# Determines whether a frame is allowed to begin before finishing processing
-# the cpu-part of the previous one, when low-latency frame pacing is used.
-# Snappiness may be improved when disallowing overlap. On the other hand, this
-# might also decrease fps in certain cases. Defaults to True.
+# Determines whether a frame is allowed to begin 
+# before finishing processing the cpu-part of the previous one, 
+# when low-latency frame pacing is used. 
+# Snappiness may be improved when disallowing overlap. 
+# On the other hand, this might also decrease fps in certain cases.
+# In case a game is generating a very high load (or specific load) on dxvk's CS thread (see DXVK_HUD=cs), 
+# setting dxvk.lowLatencyAllowCpuFramesOverlap = False 
+# will prevent the CS thread queue from creating additional latency. 
+# By default, this option is set to True, because setting it to False 
+# can lead to certain type of stutters being magnified, for example from shader compiling, 
+# which can lead to strong fps loss in those cases.
 #
 # Supported values: True, False
 
@@ -477,7 +550,7 @@
 # these threads will be reserved for high-priority work.
 #
 # Supported values:
-# - 0 to use all available CPU cores
+# - 0 to use (CPULogicalThreads - 2) compiler threads
 # - any positive number to enforce the thread count
 
 # dxvk.numCompilerThreads = 0
@@ -501,15 +574,16 @@
 # Controls graphics pipeline library behaviour
 #
 # Can be used to change VK_EXT_graphics_pipeline_library usage for
-# debugging purpose. Doing so will likely result in increased stutter
-# or degraded performance.
+# debugging purpose. This feature is replaced by Async, 
+# which does not require any specific driver/extension support
+# and provides better performance than using DXVK with GPL.
 #
 # Supported values:
 # - Auto: Enable if supported, and compile optimized pipelines in the background
 # - True: Enable if supported, but do not compile optimized pipelines
 # - False: Always disable the feature
 
-# dxvk.enableGraphicsPipelineLibrary = Auto
+# dxvk.enableGraphicsPipelineLibrary = False
 
 
 # Controls descriptor model

From 924d7617d868290b9123ee6b7058a31dfe66349a Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 13 Jul 2025 05:31:18 +0200
Subject: [PATCH 54/81] [meta] Adapt README.md for DXVK-GPLALL 2.7

---
 README.md | 263 ++++++++++++++++++++++++++++--------------------------
 1 file changed, 138 insertions(+), 125 deletions(-)

diff --git a/README.md b/README.md
index 30a0dd7ab98..fcbc0def258 100644
--- a/README.md
+++ b/README.md
@@ -1,130 +1,53 @@
-# DXVK LOW-LATENCY
+# DXVK GPLAsync-LowLatency (DXVK-GPLALL)
 
-Enhances the original [dxvk](https://github.com/doitsujin/dxvk) with low-latency frame pacing capabilities to improve game responsiveness and input lag. It also improves latency stability over time, usually resulting in a more accurate playback speed of the generated video.
-
-### Installation
-
-The most common way to install is to replace the dxvk .dll files within the Proton directory. You can theoretically do this with Steam's Proton, but since Steam will periodically update Proton, it will regularly overwrite the .dll files, and thus it's instead recommended to put a Proton version into `$HOME/.local/share/Steam/compatibilitytools.d`, such as [Proton-GE](https://github.com/GloriousEggroll/proton-ge-custom) where you can find the .dll files in `files/lib/wine/dxvk`, `i386-windows` for 32 bit and `x86_64-windows` for 64 bit. Depending on the particular Proton version, the folders might be structured slightly differently. This Proton version then can be selected in Steam, Lutris, Heroic, etc.
-
-When using dxvk low-latency in Wine directly, see [How to use](https://github.com/netborg-afps/dxvk/?tab=readme-ov-file#how-to-use).
-
-### Options
-
-#### dxvk.framePace
-
-dxvk low-latency is configured such that it achieves its goal without setting any options. The exception to this currently is that the user might want to enable the VRR mode manually. Fine-tuning the pacing via options is also possible.
-
-The config variable `dxvk.framePace` in `dxvk.conf` can be set to
-
-- `"max-frame-latency"` is the behaviour of upstream dxvk. Frame `i` won't start as long as frame `(i-1)-x` isn't finished, where `x` is the value of `dxgi.maxFrameLatency` / `d3d9.maxFrameLatency`. This pacing usually looks smooth, but has latency issues when GPU bound. Optimized for highest fps.
-- `"min-latency"` is essential like `max-frame-latency-0` (not selectable for the mode above), which means the start of a frame will wait until the previous one is finished. CPU/GPU no longer overlap during the transition from one frame to another and thus a lot of fps are sacrificed for prioritizing low latency. This mode is generally not recommended, but might be useful to get insights.
-- `"low-latency"` is the default mode: It combines high fps throughput with excellent game responsiveness and low input lag. Looking at a scale of a few seconds, pacing is usually more accurate in time than `max-frame-latency` since latency variations are minimized, especially when moving in and out of the GPU limit and when GPU frametimes vary a lot while being GPU bound. Looking at the pacing frame by frame, this mode relies on the game providing stable frame times for smoothness. When the game generates occasional stutters, these are filtered out nicely such that they don't interfere with the presentation of the other frames.
-- `"low-latency-vrr-240"` enhances the above mode by taking v-blank information into account, which prevents additional v-sync buffering latency. This mode automatically enables v-sync to get informed when v-blanks are happening. It will make the pacer predict future v-blanks based on the given refresh rate of 240 Hz. Replace 240 with the refresh rate of your monitor. This mode works with x11-flip and native Wayland (can be enabled in Wine via `DISPLAY= `), but cannot work on Xwayland because v-blank information is not available there (tested on Nvidia). Care has to be taken that the system is configured such that the display is indeed using a variable refresh rate, otherwise this mode won't work properly.
-
-Setting the frame pacing via the environment variable `DXVK_FRAME_PACE` is also supported.
-
-#### d3d9/dxgi.maxFrameRate
-
-Fps limiting is very helpful when used together with VRR to give the pacing enough space to not hit the v-sync buffering. For 240 Hz VRR, a limit of about 225 fps is recommended, and similarly for other refresh rates. Finding the best fps-limit for VRR will require some testing and also depends on the game and how much frametime variation it generates on the user's system. 
-
-Fps limiting is also useful in other modes to improve consistency and/or to save power. Limiting in the low-latency modes is tightly integrated into the frame pacing and is strongly recommended to be used in place of most ingame limiters. 
-
-If setting an fps limit so low that it will bore your GPU, this may result in your driver's heuristic clocking down the GPU, which can cause the latency to quadruple if you are unlucky. So you may want to watch out for that and take appropriate measures if desired.
-
-Setting the fps limit via the environment variable `DXVK_FRAME_RATE` is also supported.
-
-#### dxvk.hud
-
-Latencies can be visualized by adding the following to `dxvk.hud`/`DXVK_HUD`. Average over 100 frames.
-
-- `renderlatency`: start of frame (usually when the game starts processing input) until the GPU did finish rendering this frame. Note that this will not work when a game's fps limiter is enabled, as there is no way to detect when a game will stall processing before reading input.
-- `presentlatency`: time it takes to present the finished image to the screen. Relies on the driver implementation of `vkWaitForPresentKHR`, which may or may not be accurate. `VK_PRESENT_MODE_MAILBOX_KHR` is currently not supported, because it needs special treatment.
-
-#### dxvk.lowLatencyOffset
+A Vulkan-based translation layer for Direct3D 8/9/10/11 which allows running 3D applications on: 
 
-You can fine-tune the low-latency pacing options towards more fps or towards better latency. `dxvk.lowLatencyOffset = 0` is the default, a negative value will make frames start earlier by the given amount (in microseconds), and thus those frames will more likely run into buffering, which in turns may increase fps. A positive value will make frames start later by the given amount (in microseconds), which make it less likely to run into buffering and thus may improve latency.
+1. Windows 10/11, if GPU has Vulkan driver that is Vulkan 1.3 compliant. Requires SSE2 CPU.
+2. Linux using Wine, if GPU has Vulkan driver that is Vulkan 1.3 compliant. Requires SSE2 CPU.
+3. MacOS using Wine/CrossOver, if GPU has Vulkan driver that is Vulkan 1.3 compliant. Requires SSE2 CPU.
 
-In other words, this option has an effect on the percentage of frames which go into GPU buffering and/or v-sync buffering. A value of zero will make 50% of frames go (mostly slightly) into buffering, since for most games, the prediction is so accurate that it will average out to 0 microseconds.
+For GPUs that do not have Vulkan 1.3 compliant driver, it is recommended to use [DXVK-Sarek](https://github.com/pythonlover02/DXVK-Sarek). It supports Windows 7/8/10/11, Linux/Mac, requires SSE2 CPU, GPU with Vulkan driver that is Vulkan 1.1 compliant. It has implemented Direct3D 8/9/10/11 and a build with Asynchronous pipeline compilation (Async).
 
-For 360 fps gameplay, you may want to experiment with values in the range of -100 to 100. For less fps, you may want to use larger values respectively.
+## Major changes compared to [upstream DXVK](https://github.com/doitsujin/dxvk)
 
-The offset is applied after predictions have been made to align the frame, but doesn't affect fps limiting.
+1. Implemented Low Latency frame pacing mode that aims to greatly reduce latency with minimal impact in fps. Author - [netborg-afps](https://github.com/netborg-afps/dxvk/releases)
+2. Implemented Asynchronous pipeline compilation (Async) that aims to greatly reduce shader compilation stutter by not blocking the main thread when compiling async pipelines. Authors - [jomihaka](https://github.com/jomihaka/dxvk-poe-hack) and [Sporif](https://github.com/Sporif/dxvk-async)
+3. Implemented the ability to use both (together or separately) Graphics Pipeline Library (GPL) and Asynchronous pipeline compilation (Async) on DXVK 2.1 and later. Author - [Ph42oN](https://gitlab.com/Ph42oN/dxvk-gplasync/). Contributor - [Britt Yazel](https://gitlab.com/Ph42oN/dxvk-gplasync/-/merge_requests/12)
+4. Implemented all of aforementioned in one DXVK package. Author - [Digger1955](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases)
+5. Provided various GCC (for any OS) builds of DXVK-GPLALL:
 
-#### dxvk.lowLatencyAllowCpuFramesOverlap
+   a) optimized for `SSE2` (`-march=x86-64, -mtune=x86-64`) CPUs with Link-Time Optimization (`LTO`, a.k.a. `-flto=auto`) and `-O3` optimization level;
 
-In case a game is generating a very high load (or specific load) on dxvk's CS thread (see `DXVK_HUD=cs`), setting `dxvk.lowLatencyAllowCpuFramesOverlap = False` will prevent the CS thread queue to create additional latency. 
+   b) optimized for `SSE4.2` (`-march=x86-64-v2, -mtune=intel`) and newer Intel CPUs with Link-Time Optimization (`LTO`, a.k.a. `-flto=auto`) and `-O3` optimization level.
 
-Can be set to `False` on a game by game basis. By default, this option is set to `True`, because setting it to `False` can lead to certain type of stutters being magnified, for example from shader compiling, which can lead to strong fps loss in those cases.
+   c) optimized for `SSE4.2` (`-march=x86-64-v2, -mtune=generic`) and newer CPUs with Link-Time Optimization (`LTO`, a.k.a. `-flto=auto`) and `-O3` optimization level.
 
-### Additional considerations
+Author - [Digger1955](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases)
 
-#### Frame pipelining
+6. Provided various MSVC (only for Windows, requires [MSVCRT](https://www.techpowerup.com/download/visual-c-redistributable-runtime-package-all-in-one/)) builds of DXVK-GPLALL:
 
-Generating one frame of a video game typically can be seen as a sequence of the following operations:
+   a) optimized for `SSE2` (`/arch:SSE2`) CPUs with Link-Time Optimization (`LTO`, a.k.a. `/LTCG`) and `/O2` optimization level;
 
-`input sampling -> frame simulation -> frame rendering -> present()`
+   b) optimized for `SSE4.2` (`/arch:SSE4.2`) and newer Intel (`/favor:INTEL64` a.k.a. `/favor:EM64T`) CPUs with Link-Time Optimization (`LTO`, a.k.a. `/LTCG`) and `/O2` optimization level;
 
-This frame pacing relies on games/engines following the simple principle of starting to process a new frame after finishing the previous one by calling the present() method of D3D. In the author's opinion, most games are actually doing this (at least for mouse input), as this is baked into the Direct 3D methodology, and games which care for input lag basically don't have another option. 
+   c) optimized for `AVX2` (`/arch:AVX2`) and newer AMD (`/favor:AMD64`) CPUs with Link-Time Optimization (`LTO`, a.k.a. `/LTCG`) and `/O2` optimization level.
 
-However, this is not guaranteed. There may be games out there not following this principle. For those, perfect frame pacing is impossible to achieve in the D3D domain.
+Author - [Digger1955](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases)
 
-#### Display Manager Presentation
+Detailed Changelog provided in [Wiki](https://github.com/Digger1955/dxvk-gplasync-lowlatency/wiki/Detailed-Changelog).
 
-When dxvk is finished rendering a frame, the resulting image still needs to be transported to the display which is relevant for latency too. 
+Builds Reference Guide provided in [Wiki](https://github.com/Digger1955/dxvk-gplasync-lowlatency/wiki/Builds-Reference-Guide).
 
-Since there is not that much information available on this topic, the author has tested some configurations which may help you to make an informed decision. The following results were obtained running a game at 1800 fps, which has the option to flash a monitor region instantly during a mouse button press, such that Nvidia's Reflex Analyzer can be used to measure button-to-pixel latency on an Nvidia GPU (575.57.08 driver). These results may or may not be applicable to other hardware/drivers like AMD or Intel GPUs. 
+## How to use (Windows 10/11)
 
-The top of the screen was selected as monitor region to make VRR, Mailbox and V-Sync more comparable to tearing (Immediate) in terms of latency. Since the measured latency will depend on the state of the screen refresh when the mouse button was pressed, many such samples give a latency range. Note that Wine Wayland is still experimental (June 2025):
+1. Download DXVK package from [release](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases) page.
+2. Copy appropriate [DLL dependencies](https://github.com/Digger1955/dxvk-gplasync-lowlatency/blob/test/README.md#dll-dependencies) to the location of application's main executable folder.
+3. Run application.
 
-| Presentation      | Latency | fps |
-| :---------------- | :------: | :----: |
-| x11 flip immediate      |   1.0-4.1 ms   | 1700 fps |
-| x11 flip v-sync         |   5.9-8.8 ms   | 360 fps |
-|  |  |  |
-| Xwayland mailbox KDE   |  4.5-7.3 ms     | 1800 fps |
-| Xwayland v-sync KDE    |  11.9-14.7 ms   | 360 fps |
-| Wine Wayland mailbox KDE   |  6.4-9.1 ms     | 360 fps | ## muss ich rechecken
-| Wine Wayland v-sync KDE    |  5.5-8.3 ms  | 360 fps |
-|  |  |  |
-| Xwayland mailbox Gnome    |  3.7-6.4 ms  | 1800 fps |
-| Xwayland v-sync Gnome    |  12.1-14.9 ms  | 360 fps |
-| Wine Wayland mailbox Gnome    |  7.3-10.8 ms  | 1400 fps |
-| Wine Wayland v-sync Gnome    |  5.9-8.7 ms  | 360 fps |
-|  |  |  |
-| x11 flip v-sync VRR | 1.4-4.4 ms | 357 fps |
-| Wine Wayland KDE VRR| 1.7-4.6 ms | 357 fps |
-| Wine Wayland Gnome VRR| 2.0-4.9 ms | 357 fps |
+**Important**: It is **STRONGLY RECOMMENDED** to create `dxvk.conf` at application's main executable folder (per-application configuration file - first priority) or at `%APPDATA%/dxvk.conf` (one global configuration file - second priority) with your desired DXVK settings.
 
-If you want to use x11, be sure that flip is enabled. This only works on single monitor configurations. On Nvidia, you can check if flip is enabled with `__GL_SHOW_GRAPHICS_OSD=1`. Gnome has had trouble to activate flip with Proton 10, but should work fine with Proton 9. KDE should enable flip pretty straight forward, as does startx and possibly other lightweight window managers.
-
-#### Wiki
-
-There are more things relevant to latency. SMT/Hyperthreading for example may increase latency by about 10% and may increase frame time variance depending on the game. SMT doesn't need to get disabled in BIOS, it can be turned on and off via command line too:
-
-`sudo sh -c "echo off > /sys/devices/system/cpu/smt/control"`
-
-The kernel/scheduler also plays a role for latency.
-
-There will be a wiki section soon, discussing all these latency topics not directly related to dxvk.
-
-#### Original behaviour
-
-When `dxvk.framePace = "max-frame-latency"` and `dxvk.latencySleep = Auto` are set, dxvk low-latency will behave exactly how upstream dxvk does.
-
-
-
-# DXVK (Original Description)
-
-A Vulkan-based translation layer for Direct3D 8/9/10/11 which allows running 3D applications on Linux using Wine.
-
-For the current status of the project, please refer to the [project wiki](https://github.com/doitsujin/dxvk/wiki).
-
-The most recent development builds can be found [here](https://github.com/doitsujin/dxvk/actions/workflows/artifacts.yml?query=branch%3Amaster).
-
-Release builds can be found [here](https://github.com/doitsujin/dxvk/releases).
-
-## How to use
-In order to install a DXVK package obtained from the [release](https://github.com/doitsujin/dxvk/releases) page into a given wine prefix, copy or symlink the DLLs into the following directories as follows, then open `winecfg` and manually add `native` DLL overrides for `d3d8`, `d3d9`, `d3d10core`, `d3d11` and `dxgi` under the Libraries tab.
+## How to use (Linux/MacOS)
+In order to install a DXVK package obtained from the [release](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases) page into a given wine prefix, copy or symlink the DLLs into the following directories as follows, then open `winecfg` and manually add `native` DLL overrides for `d3d8`, `d3d9`, `d3d10core`, `d3d11` and `dxgi` under the Libraries tab.
 
 In a default Wine prefix that would be as follows:
 ```
@@ -147,7 +70,9 @@ In order to remove DXVK from a prefix, remove the DLLs and DLL overrides, and ru
 
 Tools such as Steam Play, Lutris, Bottles, Heroic Launcher, etc will automatically handle setup of dxvk on their own when enabled.
 
-#### DLL dependencies 
+**Important**: It is **STRONGLY RECOMMENDED** to create `dxvk.conf` at application's main executable folder (per-application configuration file - first priority) or at `/home/$USER/.config/dxvk.conf` (one global configuration file - second priority) with your desired DXVK settings.
+
+## DLL dependencies 
 Listed below are the DLL requirements for using DXVK with any single API.
 
 - d3d8: `d3d8.dll` and `d3d9.dll`
@@ -155,15 +80,33 @@ Listed below are the DLL requirements for using DXVK with any single API.
 - d3d10: `d3d10core.dll`, `d3d11.dll` and `dxgi.dll`
 - d3d11: `d3d11.dll` and `dxgi.dll`
 
-### Notes on Vulkan drivers
+## Notes on Vulkan drivers
 Before reporting an issue, please check the [Wiki](https://github.com/doitsujin/dxvk/wiki/Driver-support) page on the current driver status and make sure you run a recent enough driver version for your hardware.
 
-### Online multi-player games
-Manipulation of Direct3D libraries in multi-player games may be considered cheating and can get your account **banned**. This may also apply to single-player games with an embedded or dedicated multiplayer portion. **Use at your own risk.**
+## Online multiplayer games
+Manipulation of Direct3D libraries in multiplayer games may be considered cheating and can get your account **banned**. This may also apply to singleplayer games with an embedded or dedicated multiplayer portion. 
+
+Async could theoretically trigger client-side anti-cheats, and as such, may be risky to use inside of multiplayer games. There is no information about someone getting banned for using DXVK or DXVK with Async, but - **Use at your own risk.**
+
+## `dxvk.conf` Config File Location
+
+By default, DXVK has [built-in configs](https://github.com/doitsujin/dxvk/blob/master/src/util/config/config.cpp) for specific games and GPU drivers. If user needs to change default DXVK settings, then it can be done by changing default settings in `dxvk.conf` configuration file or by using `DXVK_CONFIG` environment variable.
 
-### HUD
+User can create `dxvk.conf` configuration file at application's main executable folder (per-application configuration file - first priority) or at `%APPDATA%/dxvk.conf` (one global configuration file - second priority) for Windows OS or at `/home/$USER/.config/dxvk.conf` (one global configuration file - second priority) for Linux/MacOS.
+
+User can change default `dxvk.conf` global coniguration file location by specifying path in `DXVK_CONFIG_FILE` environment variable:
+
+- Example (Windows): `DXVK_CONFIG_FILE=%USERPROFILE%/Documents/dxvk.conf`
+- Example (Linux): `DXVK_CONFIG_FILE=$XDG_DATA_HOME/dxvk.conf`
+- Example (MacOS): `DXVK_CONFIG_FILE=$HOME/Library/dxvk.conf`
+
+User can create `DXVK_CONFIG` to set config variables through the environment instead of a configuration file using the same syntax as in `dxvk.conf`. `;` is used as a seperator.
+
+- Example: `DXVK_CONFIG="dxgi.hideAmdGpu = True; dxgi.syncInterval = 0"`
+
+## HUD
 The `DXVK_HUD` environment variable controls a HUD which can display the framerate and some stat counters. It accepts a comma-separated list of the following options:
-- `devinfo`: Displays the name of the GPU and the driver version.
+- `devinfo`: Displays the name of the GPU, Vulkan Headers version and Vulkan Driver version.
 - `fps`: Shows the current frame rate.
 - `frametimes`: Shows a frame time graph.
 - `submissions`: Shows the number of command buffers submitted per frame.
@@ -182,45 +125,115 @@ The `DXVK_HUD` environment variable controls a HUD which can display the framera
 - `swvp`: Shows whether or not the device is running in software vertex processing mode *[D3D9 Only]*
 - `scale=x`: Scales the HUD by a factor of `x` (e.g. `1.5`)
 - `opacity=y`: Adjusts the HUD opacity by a factor of `y` (e.g. `0.5`, `1.0` being fully opaque).
+- `renderlatency`: Start of frame (usually when the game starts processing input) until the GPU did finish rendering this frame. Note that this will not work when a game's fps limiter is enabled, as there is no way to detect when a game will stall processing before reading input. Average over 100 frames.
+- `presentlatency`: time it takes to present the finished image to the screen. Relies on the driver implementation of `vkWaitForPresentKHR`, which may or may not be accurate. `VK_PRESENT_MODE_MAILBOX_KHR` is currently not supported, because it needs special treatment. Average over 100 frames.
 
 Additionally, `DXVK_HUD=1` has the same effect as `DXVK_HUD=devinfo,fps`, and `DXVK_HUD=full` enables all available HUD elements.
 
-### Logs
+## Logs
 When used with Wine, DXVK will print log messages to `stderr`. Additionally, standalone log files can optionally be generated by setting the `DXVK_LOG_PATH` variable, where log files in the given directory will be called `app_d3d11.log`, `app_dxgi.log` etc., where `app` is the name of the game executable.
 
 On Windows, log files will be created in the game's working directory by default, which is usually next to the game executable.
 
-### Frame rate limit
-The `DXVK_FRAME_RATE` environment variable can be used to limit the frame rate. A value of `0` uncaps the frame rate, while any positive value will limit rendering to the given number of frames per second. Alternatively, the configuration file can be used.
+## Frame rate limit
+The `DXVK_FRAME_RATE` environment variable can be used to limit the frame rate. 
 
-### Device filter
+A value of `0` limits the frame rate to the selected display refresh rate when vertical synchronization is enabled if the actual display mode does not match the game's one. 
+
+Any positive value will limit rendering to the given number of frames per second. 
+
+A value of `-1` always disables the limiter.
+
+`DXVK_FRAME_RATE` environment variable represented in `dxvk.conf`:
+- For D3D8 and D3D9 - `d3d9.maxFrameRate`. Default value is `d3d9.maxFrameRate = 0`
+- For D3D10 and D3D11 - `dxgi.maxFrameRate` . Default value is `dxgi.maxFrameRate = 0`
+
+## Device filter
 Some applications do not provide a method to select a different GPU. In that case, DXVK can be forced to use a given device:
 - `DXVK_FILTER_DEVICE_NAME="Device Name"` Selects devices with a matching Vulkan device name, which can be retrieved with tools such as `vulkaninfo`. Matches on substrings, so "VEGA" or "AMD RADV VEGA10" is supported if the full device name is "AMD RADV VEGA10 (LLVM 9.0.0)", for example. If the substring matches more than one device, the first device matched will be used.
-- `DXVK_FILTER_DEVICE_UUID="00000000000000000000000000000001"` Selects a device by matching its Vulkan device UUID, which can also be retrieved using tools such as `vulkaninfo`. The UUID must be a 32-character hexadecimal string with no dashes. This method provides more precise selection, especially when using multiple identical GPUs.
 
 **Note:** If the device filter is configured incorrectly, it may filter out all devices and applications will be unable to create a D3D device.
 
-### Debugging
+## Debugging
 The following environment variables can be used for **debugging** purposes.
 - `VK_INSTANCE_LAYERS=VK_LAYER_KHRONOS_validation` Enables Vulkan debug layers. Highly recommended for troubleshooting rendering issues and driver crashes. Requires the Vulkan SDK to be installed on the host system.
 - `DXVK_LOG_LEVEL=none|error|warn|info|debug` Controls message logging.
 - `DXVK_LOG_PATH=/some/directory` Changes path where log files are stored. Set to `none` to disable log file creation entirely, without disabling logging.
 - `DXVK_DEBUG=markers|validation` Enables use of the `VK_EXT_debug_utils` extension for translating performance event markers, or to enable Vulkan validation, respecticely.
-- `DXVK_CONFIG_FILE=/xxx/dxvk.conf` Sets path to the configuration file.
-- `DXVK_CONFIG="dxgi.hideAmdGpu = True; dxgi.syncInterval = 0"` Can be used to set config variables through the environment instead of a configuration file using the same syntax. `;` is used as a seperator.
 
-### Graphics Pipeline Library
+## Graphics Pipeline Library (GPL)
 On drivers which support `VK_EXT_graphics_pipeline_library` Vulkan shaders will be compiled at the time the game loads its D3D shaders, rather than at draw time. This reduces or eliminates shader compile stutter in many games when compared to the previous system.
 
 In games that load their shaders during loading screens or in the menu, this can lead to prolonged periods of very high CPU utilization, especially on weaker CPUs. For affected games it is recommended to wait for shader compilation to finish before starting the game to avoid stutter and low performance. Shader compiler activity can be monitored with `DXVK_HUD=compiler`.
 
+**Important**: Usage of Graphics Pipeline Library significantly increases VRAM usage, due to this if you are low on VRAM, it can be better to disable it. That can be done with option `dxvk.enableGraphicsPipelineLibrary = False` in `dxvk.conf`.
+
 **Note:** Games which only load their D3D shaders at draw time (e.g. most Unreal Engine games) will still exhibit some stutter, although it should still be less severe than without this feature.
 
+**IMPORTANT**: Disabled by default since DXVK-GPLALL 2.6.1-4. Reasons have been specified in [Wiki](https://github.com/Digger1955/dxvk-gplasync-lowlatency/wiki/dxvk.conf-Options-Guide#dxvkenablegraphicspipelinelibrary)
+
+## State cache (DXVK-GPLALL 2.6.1 only)
+DXVK-GPLALL up to version 2.6.1-6 caches pipeline state by default, so that shaders can be recompiled ahead of time on subsequent runs of an application, even if the driver's own shader cache got invalidated in the meantime. This cache is enabled by default, and generally reduces stuttering.
+
+State cache can be used together with GPL that is not possible on upstream DXVK, but it can be useful depending on game.
+
+The following environment variables can be used to control the cache:
+- `DXVK_STATE_CACHE`: Controls the state cache. The following values are supported:
+  - `disable`: Disables the cache entirely.
+  - `reset`: Clears the cache file.
+- `DXVK_STATE_CACHE_PATH=/some/directory` Specifies a directory where to put the cache files. Defaults to the current working directory of the application.
+
+**Important**: The state cache has been removed from the [upstream DXVK since version 2.7](https://github.com/doitsujin/dxvk/releases/tag/v2.7), and is therefore not available in DXVK-GPLALL 2.7 and later.
+
+## Asynchronous pipeline compilation (Async)
+
+Originally started as hacky solution for shader compilation stutter in dxvk. Similar solution was later added to dxvk itself and promptly removed.
+
+Enabling this solution results in a lot less shader compilation stuttering by not blocking the main thread when compiling async pipelines and (not necessarily) miscellaneous graphical issues while shaders are compiling for the first time.
+
+Asynchronous pipeline compilation is enabled with `DXVK_ASYNC=1` environment variable and is equivalent to `dxvk.enableAsync = True` in `dxvk.conf`. It is enabled by default.
+
+Asynchronous pipeline compilation is disabled with `DXVK_ASYNC=0` environment variable and is equivalent to `dxvk.enableAsync = False` in `dxvk.conf`.
+
+## GPLAsync and State cache (DXVK-GPLALL 2.6.1 only)
+
+State cache fixes for GPL and Async are enabled with `DXVK_GPLASYNCCACHE=1` environment variable and is equivalent to `dxvk.gplAsyncCache = True` in `dxvk.conf`. It is enabled by default.
+
+State cache fixes for GPL and Async are disabled with `DXVK_GPLASYNCCACHE=0` environment variable and is equivalent to `dxvk.gplAsyncCache = False` in `dxvk.conf`.
+
+**Important**: The state cache has been removed from the [upstream DXVK since version 2.7](https://github.com/doitsujin/dxvk/releases/tag/v2.7), and is therefore not available in DXVK-GPLALL 2.7 and later.
+
+## Low Latency frame pacing
+
+Enhances the original [dxvk](https://github.com/doitsujin/dxvk) with low-latency frame pacing capabilities to improve game responsiveness and input lag. It also improves latency stability over time, usually resulting in a more accurate playback speed of the generated video.
+
+Low-Latency frame pacing mode aims to reduce latency with minimal impact in fps. Effective when operating in the GPU-limit. Efficient to be used in the CPU-limit as well.
+
+Greatly reduces input lag variations when switching between CPU- and GPU-limit, and compared to the max-frame-latency approach, it has a much more stable input lag when GPU running times change dramatically, which can happen for example when rotating within a scene.
+
+Latency has been decreased dramatically in some games by speeding up the dxvk-internal flush heuristic delivering GPU submissions quicker, which was presumably tuned for bandwidth/fps.
+
+An interesting observation while playtesting was that not only the input lag was affected, but the video generated did progress more cleanly in time as well with regards to the wow and flutter effect.
+
+Optimized for Variable Refresh Rate (VRR) displays, `VK_PRESENT_MODE_IMMEDIATE_KHR` (V-Sync Off) and `VK_PRESENT_MODE_FIFO_KHR` (V-Sync On). It also comes with its own fps-limiter which is typically used to prevent the game's fps exceeding the monitor's refresh rate.
+
+### Usage
+
+`DXVK_FRAME_PACE` environment variable has the next options: `max-frame-latency`, `min-latency`, `low-latency` and `low-latency-vrr-x`. Default is `DXVK_FRAME_PACE=low-latency`.
+`low-latency-vrr-x` is a special option, which requires to specify display refresh rate, instead of `x`. For example, if user has 360 Hz VRR display, then option must be `low-latency-vrr-360`. **Important:** Care has to be taken that the system is configured such that the display is indeed using a variable refresh rate, otherwise this mode won't work properly.
+
+`DXVK_FRAME_PACE` environment variable represented in the `dxvk.conf` as `dxvk.framePace`. Default is `dxvk.framePace = "low-latency"`
+
+`dxvk.lowLatencyOffset` option in `dxvk.conf` allows for fine-tuning the `low-latency mode`. Values are in microseconds. Positive values might improve responsiveness even further, although only very slightly, this may be relevant for edge cases. Negative values might improve fps. Default is `dxvk.lowLatencyOffset = 0`
+
+`dxvk.lowLatencyAllowCpuFramesOverlap` option in `dxvk.conf` controls whether a frame is allowed to begin before finishing processing the cpu-part of the previous one, when low-latency frame pacing is used. Snappiness may be improved when disallowing overlap. On the other hand, this might also decrease fps in certain cases. Default is `dxvk.lowLatencyAllowCpuFramesOverlap = True`
+
+
 ## Build instructions
 
 In order to pull in all submodules that are needed for building, clone the repository using the following command:
 ```
-git clone --recursive https://github.com/doitsujin/dxvk.git
+git clone --recursive https://github.com/Digger1955/dxvk-gplasync-lowlatency
 ```
 
 ### Requirements:
@@ -276,13 +289,13 @@ does have `--enable-threads=posix` enabled during configure. If your distro does
 ship its mingw-w64-gcc binary with `--enable-threads=win32` you might have to
 recompile locally or open a bug at your distro's bugtracker to ask for it. 
 
-# DXVK Native
+## DXVK Native
 
 DXVK Native is a version of DXVK which allows it to be used natively without Wine.
 
 This is primarily useful for game and application ports to either avoid having to write another rendering backend, or to help with port bringup during development.
 
-[Release builds](https://github.com/doitsujin/dxvk/releases) are built using the Steam Runtime.
+[Release builds](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases) are built using the Steam Runtime.
 
 ### How does it work?
 

From 46fd93c41af3fc684189bde3bde4124ec3e5cf79 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Mon, 14 Jul 2025 00:53:56 +0200
Subject: [PATCH 55/81] [hud] Adjust HUD info item for DXVK-GPLALL 2.7

New info item format is better for Linux/MacOS and tolerable on Windows.
---
 src/dxvk/hud/dxvk_hud_item.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/dxvk/hud/dxvk_hud_item.h b/src/dxvk/hud/dxvk_hud_item.h
index 6ad2db2e9fc..c92e5a4d859 100644
--- a/src/dxvk/hud/dxvk_hud_item.h
+++ b/src/dxvk/hud/dxvk_hud_item.h
@@ -216,7 +216,7 @@ namespace dxvk::hud {
   private:
 
     std::string m_deviceName;
-    std::string m_vulkanVer;
+    std::string m_driverName;
     std::string m_driverVer;
 
   };

From 4ecd01a3b50c96f12ad23b1c3d98304141635707 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Mon, 14 Jul 2025 00:55:23 +0200
Subject: [PATCH 56/81] [hud] Adjust HUD info item for DXVK-GPLALL 2.7

New info item format is better for Linux/MacOS and tolerable on Windows.
---
 src/dxvk/hud/dxvk_hud_item.cpp | 21 ++++++++++-----------
 1 file changed, 10 insertions(+), 11 deletions(-)

diff --git a/src/dxvk/hud/dxvk_hud_item.cpp b/src/dxvk/hud/dxvk_hud_item.cpp
index e1349104509..a57d3fc233a 100644
--- a/src/dxvk/hud/dxvk_hud_item.cpp
+++ b/src/dxvk/hud/dxvk_hud_item.cpp
@@ -140,17 +140,16 @@ namespace dxvk::hud {
 
 
   HudDeviceInfoItem::HudDeviceInfoItem(const Rc<DxvkDevice>& device) {
-    VkPhysicalDeviceProperties props = device->adapter()->deviceProperties();
-
-    m_deviceName = props.deviceName;
-    m_vulkanVer = str::format("VLK: ",
-      VK_VERSION_MAJOR(props.apiVersion), ".",
-      VK_VERSION_MINOR(props.apiVersion), ".",
-      VK_VERSION_PATCH(props.apiVersion));
-    m_driverVer = str::format("VLK Drv: ",
-      VK_VERSION_MAJOR(props.driverVersion), ".",
-      VK_VERSION_MINOR(props.driverVersion), ".",
-      VK_VERSION_PATCH(props.driverVersion));
+    const auto& props = device->properties();
+
+    std::string driverInfo = props.vk12.driverInfo;
+
+    if (driverInfo.empty())
+      driverInfo = props.driverVersion.toString();
+
+    m_deviceName = props.core.properties.deviceName;
+    m_driverName = str::format("Drv: ", props.vk12.driverName);
+    m_driverVer = str::format("Inf: ", driverInfo);
   }
 
 

From 6e604677dec69c05f0f6df0729316a2f59a37b13 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Mon, 14 Jul 2025 02:24:39 +0200
Subject: [PATCH 57/81] [dxvk] Revert "Change maxPushConstantsSize
 (TotalPushDataSize) from 256 to 128"

Unfortunately, this change allows only to run applications, but does not allow them to work properly on tested GPU and driver.
---
 src/dxvk/dxvk_limits.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_limits.h b/src/dxvk/dxvk_limits.h
index 069eba45f80..87de5aa35b2 100644
--- a/src/dxvk/dxvk_limits.h
+++ b/src/dxvk/dxvk_limits.h
@@ -19,7 +19,7 @@ namespace dxvk {
     MaxNumSpecConstants         =    12,
     MaxUniformBufferSize        = 65536,
     MaxVertexBindingStride      =  2048,
-    MaxTotalPushDataSize        =   128,
+    MaxTotalPushDataSize        =   256,
     MaxSharedPushDataSize       =    64,
     MaxPerStagePushDataSize     =    32,
     MaxReservedPushDataSize     =    32,

From 3c3f3d2b87d7dee5e444960bfac9f9f2d8843ea2 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Mon, 14 Jul 2025 02:25:41 +0200
Subject: [PATCH 58/81] [dxvk] Revert "Change maxPushConstantsSize
 (TotalPushDataSize) from 256 to 128"

Unfortunately, this change allows only to run applications, but does not allow them to work properly on tested GPU and driver.
---
 VP_DXVK_requirements.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/VP_DXVK_requirements.json b/VP_DXVK_requirements.json
index c4719e96f5a..ec53f919fde 100644
--- a/VP_DXVK_requirements.json
+++ b/VP_DXVK_requirements.json
@@ -94,7 +94,7 @@
             },
             "properties": {
                 "VkPhysicalDeviceProperties": {
-                    "maxPushConstantsSize" : 128
+                    "maxPushConstantsSize" : 256
                 }
             }
         },

From 7e10216743b4cb15fe2e602f266a6616d25ac04b Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Mon, 14 Jul 2025 03:35:08 +0200
Subject: [PATCH 59/81] [meta] Adapt README.md for DXVK-GPLALL 2.7

---
 README.md | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/README.md b/README.md
index fcbc0def258..aa714e87b26 100644
--- a/README.md
+++ b/README.md
@@ -172,8 +172,8 @@ In games that load their shaders during loading screens or in the menu, this can
 
 **IMPORTANT**: Disabled by default since DXVK-GPLALL 2.6.1-4. Reasons have been specified in [Wiki](https://github.com/Digger1955/dxvk-gplasync-lowlatency/wiki/dxvk.conf-Options-Guide#dxvkenablegraphicspipelinelibrary)
 
-## State cache (DXVK-GPLALL 2.6.1 only)
-DXVK-GPLALL up to version 2.6.1-6 caches pipeline state by default, so that shaders can be recompiled ahead of time on subsequent runs of an application, even if the driver's own shader cache got invalidated in the meantime. This cache is enabled by default, and generally reduces stuttering.
+## State cache (DXVK-GPLALL 2.6.x only)
+DXVK-GPLALL up to version 2.6.x caches pipeline state by default, so that shaders can be recompiled ahead of time on subsequent runs of an application, even if the driver's own shader cache got invalidated in the meantime. This cache is enabled by default, and generally reduces stuttering.
 
 State cache can be used together with GPL that is not possible on upstream DXVK, but it can be useful depending on game.
 
@@ -195,7 +195,7 @@ Asynchronous pipeline compilation is enabled with `DXVK_ASYNC=1` environment var
 
 Asynchronous pipeline compilation is disabled with `DXVK_ASYNC=0` environment variable and is equivalent to `dxvk.enableAsync = False` in `dxvk.conf`.
 
-## GPLAsync and State cache (DXVK-GPLALL 2.6.1 only)
+## GPLAsync and State cache (DXVK-GPLALL 2.6.x only)
 
 State cache fixes for GPL and Async are enabled with `DXVK_GPLASYNCCACHE=1` environment variable and is equivalent to `dxvk.gplAsyncCache = True` in `dxvk.conf`. It is enabled by default.
 

From 71f881ca30469f33fff74cbc6dfb3aa9c65e9b9d Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Mon, 14 Jul 2025 04:06:03 +0200
Subject: [PATCH 60/81] [release] DXVK-GPLAsync-LowLatency 2.7-1 (DXVK-GPLALL
 2.7-1)

DXVK-GPLAsync-LowLatency 2.7-1 (DXVK-GPLALL 2.7-1)

Detailed Changelog provided in Wiki.
---
 RELEASE | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/RELEASE b/RELEASE
index 1effb003408..078bae215a5 100644
--- a/RELEASE
+++ b/RELEASE
@@ -1 +1 @@
-2.7
+2.7-1

From 1b5f3ac6b451ec405722ea6e52988cd22bb74b19 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Tue, 15 Jul 2025 17:15:16 +0200
Subject: [PATCH 61/81] [dxvk] Improve v-blank prediction for VRR pacing

---
 .../dxvk_framepacer_mode_low_latency.h        | 50 +++++++++++++++----
 src/dxvk/framepacer/dxvk_presentation_stats.h | 34 +++++++++++--
 2 files changed, 71 insertions(+), 13 deletions(-)

diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index 00a526b6c12..a2d8693d3c3 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -102,7 +102,7 @@ namespace dxvk {
           continue;
         }
 
-        if (finishedId != frameId-2) {
+        if (unlikely(finishedId != frameId-2)) {
           Logger::err( str::format("internal error during low-latency frame pacing: expected finished frameId=",
             frameId-2, ", got: ", finishedId) );
         }
@@ -128,7 +128,7 @@ namespace dxvk {
         int32_t delay = std::max(gpuDelay, cpuDelay);
 
         if (m_mode == LOW_LATENCY_VRR) {
-          delay = std::max(delay, getVrrDelay(frameId, props, now));
+          delay = std::max(delay, getVrrDelay(frameId, props, now, gpuReadyPrediction));
         }
 
         delay += m_lowLatencyOffset;
@@ -271,24 +271,56 @@ namespace dxvk {
     }
 
 
-    int32_t getVrrDelay( uint64_t frameId, const SyncProps& props, const time_point& now ) {
+    int32_t getVrrDelay( uint64_t frameId, const SyncProps& props, const time_point& t, int32_t gpuReadyPrediction = 0 ) {
+
       uint64_t frameFinishedId = m_latencyMarkersStorage->getTimeline()->frameFinished.load();
       int32_t lastVBlank = std::chrono::duration_cast<microseconds> (
-        m_latencyMarkersStorage->getConstMarkers(frameFinishedId)->end - now ).count();
+        m_latencyMarkersStorage->getConstMarkers(frameFinishedId)->end - t ).count();
 
       // Presentation latency should be fairly stable, but drivers may report back
       // different levels of latency (Nvidia reports very low latencies on x11 flip compared
       // to Wayland). We take the median within a recent time window to adjust to that.
 
       // Presentation latency may vary though for other reasons, like when compiling shaders
-      // on all cpu cores we will get thread starvation and higher latency.
-      int32_t presentLatency = m_presentationStats.getMedian();
+      // on all cpu cores, we will get thread starvation and higher latency.
+
+      int32_t presentLatency = m_presentationStats.getMedian( frameId );
+      lastVBlank -= presentLatency;
+
+      // the previous frame got presented already, so we know pretty much when the next v-blank will be
+      if (frameId - frameFinishedId == 1) {
+        int32_t targetVBlank = lastVBlank + m_vrrRefreshInterval;
+        return targetVBlank - props.optimizedGpuTime - props.cpuUntilGpuStart;
+      }
+
+      int32_t previousVBlank = lastVBlank
+        + (frameId - frameFinishedId - 1) * m_vrrRefreshInterval;
 
-      int32_t targetVBlank = lastVBlank
-        + (frameId - frameFinishedId) * m_vrrRefreshInterval
-        - presentLatency;
+      // we still haven't hardcoded frame progression based on v-blanks
+      // so this case might still happen for dxgi.maxFrameLatency != 1
+      if (unlikely(frameId - frameFinishedId != 2)) {
+        return previousVBlank + m_vrrRefreshInterval - props.optimizedGpuTime - props.cpuUntilGpuStart;
+      }
+
+      // override the prediction if we know when the gpu has completed the previous frame
+      if (m_latencyMarkersStorage->getTimeline()->gpuFinished.load() == frameId-1) {
+        const LatencyMarkers* mPrev = m_latencyMarkersStorage->getConstMarkers(frameId-1);
+        gpuReadyPrediction = std::chrono::duration_cast<microseconds>(
+          mPrev->start - t + microseconds(mPrev->gpuFinished) ).count();
+      } else {
+        // the previous frame might take longer than expected and isn't finished yet.
+        // relevant especially in fps-limited scenario
+        int32_t now = std::chrono::duration_cast<microseconds> (high_resolution_clock::now() - t).count();
+        previousVBlank = std::max( previousVBlank, now );
+      }
 
+      // the previous frame should be scheduled to finish after v-blank, but there is no guarantee
+      previousVBlank = std::max( previousVBlank, gpuReadyPrediction );
+
+      // finally return the prediction for the best frame start regarding v-blanks
+      int32_t targetVBlank = previousVBlank + m_vrrRefreshInterval;
       return targetVBlank - props.optimizedGpuTime - props.cpuUntilGpuStart;
+
     }
 
 
diff --git a/src/dxvk/framepacer/dxvk_presentation_stats.h b/src/dxvk/framepacer/dxvk_presentation_stats.h
index b6174a9f8be..ed32208c70c 100644
--- a/src/dxvk/framepacer/dxvk_presentation_stats.h
+++ b/src/dxvk/framepacer/dxvk_presentation_stats.h
@@ -42,9 +42,27 @@ namespace dxvk {
     }
 
 
-    int32_t getMedian() {
+    int32_t getMedian( uint64_t frameId ) {
 
-      uint64_t targetCount = m_numLatencies / 2;
+      // use a cache so we can efficiently call this multiple times per frame
+      if (frameId == 0 || m_cachedMedian.frameId == frameId)
+        return m_cachedMedian.median;
+
+      int32_t median = getPercentile(0.5);
+
+      m_cachedMedian.frameId = frameId;
+      m_cachedMedian.median  = median;
+
+      return median;
+
+    }
+
+
+    int32_t getPercentile( float p ) const {
+
+      assert( p >= 0 && p <= 1 );
+
+      uint64_t targetCount = m_numLatencies * p;
       uint64_t count = 0;
       size_t index = 0;
       while (count < targetCount && index < m_buckets.size()) {
@@ -52,6 +70,7 @@ namespace dxvk {
         ++index;
       }
 
+      if (index > 0) --index;
       return index * 8;
 
     }
@@ -68,7 +87,7 @@ namespace dxvk {
     // if presents take longer than 5 ms, we probably have a problem?
     constexpr static int32_t maxLatency = 5000;
 
-    std::array< std::atomic<int64_t>, maxLatency / 8 > m_buckets = { };
+    std::array< std::atomic<int64_t>, 1+(maxLatency / 8) > m_buckets = { };
     std::atomic< int64_t > m_numLatencies = { 0 };
 
     struct QueueItem {
@@ -76,9 +95,16 @@ namespace dxvk {
       int32_t    latency;
     };
 
-    // should only be accessed from one thread
+    // must only be accessed from one thread
     std::deque< QueueItem > m_queue;
 
+    struct CachedMedian {
+      uint64_t frameId;
+      int32_t  median;
+    };
+
+    CachedMedian m_cachedMedian = { };
+
   };
 
 }

From f8fcdb2634638abb105755d96a8ac3fe3b3d16f5 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 20 Jul 2025 04:01:22 +0200
Subject: [PATCH 62/81] [dxvk-async] Lower number of required draw calls for
 render target, after which asynchronous pipeline compilation for
 corresponding shader will be enabled

Leads to lower peak CPU load during shader compilation process, which leads to less stutters in both amount and longevity.
---
 src/dxvk/dxvk_image.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_image.h b/src/dxvk/dxvk_image.h
index c3e2b3479b5..3901bf0a32c 100644
--- a/src/dxvk/dxvk_image.h
+++ b/src/dxvk/dxvk_image.h
@@ -301,7 +301,7 @@ namespace dxvk {
      * \returns \c true if async compilation is supported
      */
     [[nodiscard]] bool getRtBindingAsyncCompilationCompat() const {
-      return m_rtBindingFrameCount >= 5;
+      return m_rtBindingFrameCount >= 2;
     }
 
 

From 4b9b11ba88b3fa70d73e1eb58d3ec29ce5203901 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 20 Jul 2025 04:05:18 +0200
Subject: [PATCH 63/81] Update README.md to DXVK-GPLALL 2.7-2

---
 README.md | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/README.md b/README.md
index aa714e87b26..fe6ef6fabb4 100644
--- a/README.md
+++ b/README.md
@@ -34,6 +34,8 @@ Author - [Digger1955](https://github.com/Digger1955/dxvk-gplasync-lowlatency/rel
 
 Author - [Digger1955](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases)
 
+7. Maintaining DXVK 2.6.x branch for GPUs/drivers that do not meet [DXVK 2.7 requirements](https://github.com/doitsujin/dxvk/releases/tag/v2.7). Author - [Digger1955](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases)
+
 Detailed Changelog provided in [Wiki](https://github.com/Digger1955/dxvk-gplasync-lowlatency/wiki/Detailed-Changelog).
 
 Builds Reference Guide provided in [Wiki](https://github.com/Digger1955/dxvk-gplasync-lowlatency/wiki/Builds-Reference-Guide).
@@ -151,6 +153,7 @@ A value of `-1` always disables the limiter.
 ## Device filter
 Some applications do not provide a method to select a different GPU. In that case, DXVK can be forced to use a given device:
 - `DXVK_FILTER_DEVICE_NAME="Device Name"` Selects devices with a matching Vulkan device name, which can be retrieved with tools such as `vulkaninfo`. Matches on substrings, so "VEGA" or "AMD RADV VEGA10" is supported if the full device name is "AMD RADV VEGA10 (LLVM 9.0.0)", for example. If the substring matches more than one device, the first device matched will be used.
+- `DXVK_FILTER_DEVICE_UUID="00000000000000000000000000000001"` Selects a device by matching its Vulkan device UUID, which can also be retrieved using tools such as vulkaninfo. The UUID must be a 32-character hexadecimal string with no dashes. This method provides more precise selection, especially when using multiple identical GPUs.
 
 **Note:** If the device filter is configured incorrectly, it may filter out all devices and applications will be unable to create a D3D device.
 

From 060baeeea9bf1d8e816865a7ca51106c15fbfc77 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Sun, 20 Jul 2025 04:11:47 +0200
Subject: [PATCH 64/81] [release] DXVK-GPLAsync-LowLatency 2.7-2 (DXVK-GPLALL
 2.7-2)

DXVK-GPLAsync-LowLatency 2.7-2 (DXVK-GPLALL 2.7-2)

Detailed Changelog provided in Wiki.
---
 RELEASE | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/RELEASE b/RELEASE
index 078bae215a5..39bf9228d50 100644
--- a/RELEASE
+++ b/RELEASE
@@ -1 +1 @@
-2.7-1
+2.7-2

From c29abbed7b756432d307aae6429f013b989d6c59 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Tue, 15 Jul 2025 17:37:09 +0200
Subject: [PATCH 65/81] [dxvk] Collect GPU and V-Sync buffer stats

---
 src/dxvk/framepacer/dxvk_framepacer.cpp       |  3 +-
 src/dxvk/framepacer/dxvk_framepacer.h         | 37 +++++++++++++++++++
 .../dxvk_framepacer_mode_low_latency.h        |  7 ++--
 ...sentation_stats.h => dxvk_latency_stats.h} | 10 +++--
 4 files changed, 49 insertions(+), 8 deletions(-)
 rename src/dxvk/framepacer/{dxvk_presentation_stats.h => dxvk_latency_stats.h} (91%)

diff --git a/src/dxvk/framepacer/dxvk_framepacer.cpp b/src/dxvk/framepacer/dxvk_framepacer.cpp
index d15194766f2..b9665005203 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.cpp
+++ b/src/dxvk/framepacer/dxvk_framepacer.cpp
@@ -13,7 +13,8 @@ namespace dxvk {
   }
 
 
-  FramePacer::FramePacer( const DxvkOptions& options, uint64_t firstFrameId ) {
+  FramePacer::FramePacer( const DxvkOptions& options, uint64_t firstFrameId )
+  : m_gpuBufferStats(3000), m_presentationStats(3000) {
     // we'll default to LOW_LATENCY in the draft-PR for now, for demonstration purposes,
     // highlighting the generally much better input lag and medium-term time consistency.
     // although MAX_FRAME_LATENCY has advantages in many games and is likely the better default,
diff --git a/src/dxvk/framepacer/dxvk_framepacer.h b/src/dxvk/framepacer/dxvk_framepacer.h
index 3a9565ee190..92238e49073 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.h
+++ b/src/dxvk/framepacer/dxvk_framepacer.h
@@ -2,6 +2,7 @@
 
 #include "dxvk_framepacer_mode.h"
 #include "dxvk_latency_markers.h"
+#include "dxvk_latency_stats.h"
 #include "../dxvk_latency.h"
 #include "../../util/util_time.h"
 #include <dxgi.h>
@@ -41,6 +42,7 @@ namespace dxvk {
       m_latencyMarkersStorage.registerFrameEnd(frameId);
       m_mode->endFrame(frameId);
       m_gpuStarts[ (frameId-1) % m_gpuStarts.size() ].store(0);
+      trackStats(frameId);
     }
 
     void notifyCsRenderBegin( uint64_t frameId ) override {
@@ -149,6 +151,16 @@ namespace dxvk {
     DxvkLatencyStats getStatistics( uint64_t frameId ) override
       { return DxvkLatencyStats(); }
 
+
+    // non-overriding methods
+
+
+    const LatencyStats* getGpuBufferStats() const
+      { return &m_gpuBufferStats; }
+
+    const LatencyStats* getPresentStats() const
+      { return &m_presentationStats; }
+
   private:
 
     void signalGpuStart( uint64_t frameId, LatencyMarkers* m, const high_resolution_clock::time_point& t ) {
@@ -171,12 +183,37 @@ namespace dxvk {
         signalGpuStart( frameId, m, t );
     }
 
+    void trackStats( uint64_t frameId ) {
+      if (!m_trackStats)
+        return;
+
+      const LatencyMarkers* m = m_latencyMarkersStorage.getConstMarkers(frameId);
+      m_presentationStats.push( m->end, m->presentFinished - m->gpuFinished );
+
+      int64_t minDiff = std::numeric_limits<int64_t>::max();
+      size_t i = 0;
+      while (m->gpuSubmit.size() > i && m->gpuReady.size() > i) {
+        int64_t diff = std::chrono::duration_cast<microseconds>(
+          m->gpuReady[i] - m->gpuSubmit[i]).count();
+        diff = std::max( (int64_t) 0, diff );
+        minDiff = std::min( minDiff, diff );
+        ++i;
+      }
+
+      if (minDiff != std::numeric_limits<int64_t>::max())
+        m_gpuBufferStats.push( m->end, minDiff );
+    }
+
     std::unique_ptr<FramePacerMode> m_mode;
 
     std::array< std::atomic< uint16_t >, 8 > m_gpuStarts = { };
     static constexpr uint16_t queueSubmitBit = 1;
     static constexpr uint16_t gpuReadyBit    = 2;
 
+    const bool   m_trackStats = { true };
+    LatencyStats m_gpuBufferStats;
+    LatencyStats m_presentationStats;
+
   };
 
 }
diff --git a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
index a2d8693d3c3..4d6ba320161 100644
--- a/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
+++ b/src/dxvk/framepacer/dxvk_framepacer_mode_low_latency.h
@@ -1,7 +1,7 @@
 #pragma once
 
 #include "dxvk_framepacer_mode.h"
-#include "dxvk_presentation_stats.h"
+#include "dxvk_latency_stats.h"
 #include "../dxvk_options.h"
 #include "../../util/log/log.h"
 #include "../../util/util_string.h"
@@ -46,7 +46,8 @@ namespace dxvk {
     LowLatencyMode(Mode mode, LatencyMarkersStorage* storage, const DxvkOptions& options, int refreshRate = 0)
     : FramePacerMode(mode, storage),
       m_lowLatencyOffset(getLowLatencyOffset(options)),
-      m_allowCpuFramesOverlap(options.lowLatencyAllowCpuFramesOverlap) {
+      m_allowCpuFramesOverlap(options.lowLatencyAllowCpuFramesOverlap),
+      m_presentationStats(5000) {
       Logger::info( str::format("Using lowLatencyOffset: ", m_lowLatencyOffset) );
       Logger::info( str::format("Using lowLatencyAllowCpuFramesOverlap: ", m_allowCpuFramesOverlap) );
 
@@ -348,7 +349,7 @@ namespace dxvk {
 
     Sleep::TimePoint m_lastStart = { high_resolution_clock::now() };
     int32_t m_vrrRefreshInterval = { 0 };
-    PresentationStats m_presentationStats;
+    LatencyStats m_presentationStats;
 
     std::array<SyncProps, 16> m_props;
     std::atomic<uint64_t> m_propsFinished = { 0 };
diff --git a/src/dxvk/framepacer/dxvk_presentation_stats.h b/src/dxvk/framepacer/dxvk_latency_stats.h
similarity index 91%
rename from src/dxvk/framepacer/dxvk_presentation_stats.h
rename to src/dxvk/framepacer/dxvk_latency_stats.h
index ed32208c70c..5ecdf701705 100644
--- a/src/dxvk/framepacer/dxvk_presentation_stats.h
+++ b/src/dxvk/framepacer/dxvk_latency_stats.h
@@ -11,12 +11,14 @@
 
 namespace dxvk {
 
-  class PresentationStats {
+  class LatencyStats {
 
   public:
 
     using time_point = high_resolution_clock::time_point;
 
+    LatencyStats( int32_t duration_ms ) : m_duration(duration_ms) { }
+
     void push( time_point t, int32_t latency ) {
 
       int32_t index = getBucketIndex(latency);
@@ -32,7 +34,7 @@ namespace dxvk {
 
       // remove old items from the queue
       while (!m_queue.empty() && m_queue.front().timeStamp
-        < high_resolution_clock::now() - std::chrono::milliseconds(5000) ) {
+        < high_resolution_clock::now() - std::chrono::milliseconds(m_duration) ) {
         index = getBucketIndex(m_queue.front().latency);
         --m_buckets[index];
         --m_numLatencies;
@@ -78,14 +80,14 @@ namespace dxvk {
 
   private:
 
-    int getBucketIndex( int32_t latency ) {
+    int getBucketIndex( int32_t latency ) const {
       assert( latency >= 0 );
       size_t index = latency / 8;
       return std::min( m_buckets.size()-1, index );
     }
 
-    // if presents take longer than 5 ms, we probably have a problem?
     constexpr static int32_t maxLatency = 5000;
+    const int32_t m_duration;
 
     std::array< std::atomic<int64_t>, 1+(maxLatency / 8) > m_buckets = { };
     std::atomic< int64_t > m_numLatencies = { 0 };

From 6d40102b5605755e2581244a46b06d09158e1e56 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Tue, 15 Jul 2025 18:36:54 +0200
Subject: [PATCH 66/81] [hud] Add latency details

Showing GPU and V-Sync buffer stats
---
 src/d3d11/d3d11_swapchain.cpp          |   4 +
 src/d3d11/d3d11_swapchain.h            |   1 +
 src/d3d9/d3d9_swapchain.cpp            |   4 +
 src/d3d9/d3d9_swapchain.h              |   1 +
 src/dxvk/hud/dxvk_hud_item.cpp         | 112 -------------
 src/dxvk/hud/dxvk_hud_item.h           |  48 +++++-
 src/dxvk/hud/dxvk_hud_item_latency.cpp | 209 +++++++++++++++++++++++++
 src/dxvk/meson.build                   |   1 +
 src/util/util_fps_limiter.cpp          |   3 +-
 src/util/util_fps_limiter.h            |   4 +-
 10 files changed, 270 insertions(+), 117 deletions(-)
 create mode 100644 src/dxvk/hud/dxvk_hud_item_latency.cpp

diff --git a/src/d3d11/d3d11_swapchain.cpp b/src/d3d11/d3d11_swapchain.cpp
index bcd938948e6..eb0fef0c043 100644
--- a/src/d3d11/d3d11_swapchain.cpp
+++ b/src/d3d11/d3d11_swapchain.cpp
@@ -301,6 +301,9 @@ namespace dxvk {
     if (m_presentLatencyHud)
       m_presentLatencyHud->updateLatencyTracker(m_latency);
 
+    if (m_latencyDetailsHud)
+      m_latencyDetailsHud->updateLatencyTracker(m_latency);
+
     return hr;
   }
 
@@ -615,6 +618,7 @@ namespace dxvk {
           int32_t fpsItemPos = hud->getItemPos<hud::HudFpsItem>();
           m_renderLatencyHud = hud->addItem<hud::HudRenderLatencyItem>("renderlatency", fpsItemPos+1);
           m_presentLatencyHud = hud->addItem<hud::HudPresentLatencyItem>("presentlatency", fpsItemPos+2);
+          m_latencyDetailsHud = hud->addItem<hud::HudLatencyDetailsItem>("latencydetails", fpsItemPos+3);
         }
       }
     }
diff --git a/src/d3d11/d3d11_swapchain.h b/src/d3d11/d3d11_swapchain.h
index 5daf407dc01..ed90f28e365 100644
--- a/src/d3d11/d3d11_swapchain.h
+++ b/src/d3d11/d3d11_swapchain.h
@@ -128,6 +128,7 @@ namespace dxvk {
     Rc<hud::HudLatencyItem>         m_latencyHud;
     Rc<hud::HudRenderLatencyItem>   m_renderLatencyHud;
     Rc<hud::HudPresentLatencyItem>  m_presentLatencyHud;
+    Rc<hud::HudLatencyDetailsItem>  m_latencyDetailsHud;
 
     Rc<DxvkImageView> GetBackBufferView();
 
diff --git a/src/d3d9/d3d9_swapchain.cpp b/src/d3d9/d3d9_swapchain.cpp
index 50b41f70ac3..682d942f523 100644
--- a/src/d3d9/d3d9_swapchain.cpp
+++ b/src/d3d9/d3d9_swapchain.cpp
@@ -924,6 +924,9 @@ namespace dxvk {
     if (m_presentLatencyHud)
       m_presentLatencyHud->updateLatencyTracker(m_latencyTracker);
 
+    if (m_latencyDetailsHud)
+      m_latencyDetailsHud->updateLatencyTracker(m_latencyTracker);
+
     // Rotate swap chain buffers so that the back
     // buffer at index 0 becomes the front buffer.
     uint32_t rotatingBufferCount = m_backBuffers.size();
@@ -1077,6 +1080,7 @@ namespace dxvk {
           int32_t fpsItemPos = hud->getItemPos<hud::HudFpsItem>();
           m_renderLatencyHud = hud->addItem<hud::HudRenderLatencyItem>("renderlatency", fpsItemPos+1);
           m_presentLatencyHud = hud->addItem<hud::HudPresentLatencyItem>("presentlatency", fpsItemPos+2);
+          m_latencyDetailsHud = hud->addItem<hud::HudLatencyDetailsItem>("latencydetails", fpsItemPos+3);
         }
       }
 
diff --git a/src/d3d9/d3d9_swapchain.h b/src/d3d9/d3d9_swapchain.h
index 550bfec6588..6f13bb87e6b 100644
--- a/src/d3d9/d3d9_swapchain.h
+++ b/src/d3d9/d3d9_swapchain.h
@@ -187,6 +187,7 @@ namespace dxvk {
     Rc<hud::HudLatencyItem>         m_latencyHud;
     Rc<hud::HudRenderLatencyItem>   m_renderLatencyHud;
     Rc<hud::HudPresentLatencyItem>  m_presentLatencyHud;
+    Rc<hud::HudLatencyDetailsItem>  m_latencyDetailsHud;
 
     std::optional<VkHdrMetadataEXT> m_hdrMetadata;
     bool m_unlockAdditionalFormats = false;
diff --git a/src/dxvk/hud/dxvk_hud_item.cpp b/src/dxvk/hud/dxvk_hud_item.cpp
index 141618faf33..902ac95e2c1 100644
--- a/src/dxvk/hud/dxvk_hud_item.cpp
+++ b/src/dxvk/hud/dxvk_hud_item.cpp
@@ -1,5 +1,4 @@
 #include "dxvk_hud_item.h"
-#include "../framepacer/dxvk_framepacer.h"
 
 #include <hud_chunk_frag_background.h>
 #include <hud_chunk_frag_visualize.h>
@@ -214,117 +213,6 @@ namespace dxvk::hud {
   }
 
 
-  HudRenderLatencyItem::HudRenderLatencyItem() { }
-  HudRenderLatencyItem::~HudRenderLatencyItem() { }
-
-  void HudRenderLatencyItem::update(dxvk::high_resolution_clock::time_point time) {
-    const Rc<DxvkLatencyTracker> tracker = m_tracker;
-    const FramePacer* framePacer = dynamic_cast<FramePacer*>( tracker.ptr() );
-    if (!framePacer)
-      return;
-
-    auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(time - m_lastUpdate);
-
-    if (elapsed.count() >= UpdateInterval) {
-      m_lastUpdate = time;
-
-      LatencyMarkersReader reader = framePacer->m_latencyMarkersStorage.getReader(100);
-      const LatencyMarkers* markers;
-      uint32_t count = 0;
-      uint64_t totalLatency = 0;
-      while (reader.getNext(markers)) {
-        totalLatency += markers->gpuFinished;
-        ++count;
-      }
-
-      if (!count)
-        return;
-
-      uint64_t latency = totalLatency / count;
-      m_latency = str::format(latency / 1000, ".", (latency/100) % 10, " ms");
-    }
-  }
-
-
-  HudPos HudRenderLatencyItem::render(
-    const Rc<DxvkCommandList>&ctx,
-    const HudPipelineKey&     key,
-    const HudOptions&         options,
-          HudRenderer&        renderer,
-          HudPos              position) {
-
-    position.y += 12;
-    renderer.drawText(16, position, 0xff4040ffu, "Render latency:");
-    renderer.drawText(16, { position.x + 195, position.y },
-      0xffffffffu, m_latency);
-
-    position.y += 8;
-    return position;
-  }
-
-
-  HudPresentLatencyItem::HudPresentLatencyItem() { }
-  HudPresentLatencyItem::~HudPresentLatencyItem() { }
-
-  void HudPresentLatencyItem::update(dxvk::high_resolution_clock::time_point time) {
-    // we cannot measure latency when fps-limiting is performed in Presenter::runFrameThread()
-    // because it's interfering with getting the right timestamp from vkWaitForPresent()
-    // if we truely wanted to measure it, we would need one additional thread
-    if (FpsLimiter::m_isActive) {
-      m_latency = "N/A";
-      return;
-    }
-
-    const Rc<DxvkLatencyTracker> tracker = m_tracker;
-    FramePacer* framePacer = dynamic_cast<FramePacer*>( tracker.ptr() );
-    if (!framePacer)
-      return;
-
-    if (framePacer->getFramePacerMode()->getPresentMode() == VK_PRESENT_MODE_MAILBOX_KHR) {
-      m_latency = "N/A";
-      return;
-    }
-
-    auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(time - m_lastUpdate);
-
-    if (elapsed.count() >= UpdateInterval) {
-      m_lastUpdate = time;
-
-      LatencyMarkersReader reader = framePacer->m_latencyMarkersStorage.getReader(100);
-      const LatencyMarkers* markers;
-      uint32_t count = 0;
-      uint64_t totalLatency = 0;
-      while (reader.getNext(markers)) {
-        totalLatency += markers->presentFinished - markers->gpuFinished;
-        ++count;
-      }
-
-      if (!count)
-        return;
-
-      uint64_t latency = totalLatency / count;
-      m_latency = str::format(latency / 1000, ".", (latency/100) % 10, " ms");
-    }
-  }
-
-
-  HudPos HudPresentLatencyItem::render(
-    const Rc<DxvkCommandList>&ctx,
-    const HudPipelineKey&     key,
-    const HudOptions&         options,
-          HudRenderer&        renderer,
-          HudPos              position) {
-
-    position.y += 12;
-    renderer.drawText(16, position, 0xff4040ffu, "Present latency:");
-    renderer.drawText(16, { position.x + 206, position.y },
-      0xffffffffu, m_latency);
-
-    position.y += 8;
-    return position;
-  }
-
-
   HudFrameTimeItem::HudFrameTimeItem(const Rc<DxvkDevice>& device, HudRenderer* renderer)
   : m_device            (device),
     m_gfxPipelineLayout (createPipelineLayout()) {
diff --git a/src/dxvk/hud/dxvk_hud_item.h b/src/dxvk/hud/dxvk_hud_item.h
index c92e5a4d859..db987cdc46a 100644
--- a/src/dxvk/hud/dxvk_hud_item.h
+++ b/src/dxvk/hud/dxvk_hud_item.h
@@ -289,8 +289,8 @@ namespace dxvk::hud {
   };
 
 
-     /**
-   * \brief HUD item to display render latency
+  /**
+   * \brief HUD item to display present latency
    */
   class HudPresentLatencyItem : public HudItem {
     constexpr static int64_t UpdateInterval = 500'000;
@@ -325,6 +325,50 @@ namespace dxvk::hud {
   };
 
 
+  /**
+   * \brief HUD item to display latency details, buffers, etc.
+   */
+  class HudLatencyDetailsItem : public HudItem {
+    constexpr static int64_t UpdateInterval = 500'000;
+  public:
+
+    HudLatencyDetailsItem();
+
+    ~HudLatencyDetailsItem();
+
+    void updateLatencyTracker( const Rc<DxvkLatencyTracker>& tracker ) {
+      m_tracker = tracker;
+    }
+
+    void update(dxvk::high_resolution_clock::time_point time);
+
+    HudPos render(
+      const Rc<DxvkCommandList>&ctx,
+      const HudPipelineKey&     key,
+      const HudOptions&         options,
+            HudRenderer&        renderer,
+            HudPos              position);
+
+  private:
+
+    Rc<DxvkLatencyTracker> m_tracker;
+
+    dxvk::high_resolution_clock::time_point m_lastUpdate
+      = dxvk::high_resolution_clock::now();
+
+    std::string m_gpuP50;
+    std::string m_gpuP75;
+    std::string m_gpuP95;
+    std::string m_gpuP99;
+
+    std::string m_presentP50;
+    std::string m_presentP75;
+    std::string m_presentP95;
+    std::string m_presentP99;
+
+  };
+
+
   /**
    * \brief HUD item to display the frame rate
    */
diff --git a/src/dxvk/hud/dxvk_hud_item_latency.cpp b/src/dxvk/hud/dxvk_hud_item_latency.cpp
new file mode 100644
index 00000000000..0c7a25b012f
--- /dev/null
+++ b/src/dxvk/hud/dxvk_hud_item_latency.cpp
@@ -0,0 +1,209 @@
+#include "dxvk_hud_item.h"
+#include "../framepacer/dxvk_framepacer.h"
+
+namespace dxvk::hud {
+
+  HudRenderLatencyItem::HudRenderLatencyItem() { }
+  HudRenderLatencyItem::~HudRenderLatencyItem() { }
+
+  void HudRenderLatencyItem::update(dxvk::high_resolution_clock::time_point time) {
+    const Rc<DxvkLatencyTracker> tracker = m_tracker;
+    const FramePacer* framePacer = dynamic_cast<FramePacer*>( tracker.ptr() );
+    if (!framePacer)
+      return;
+
+    auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(time - m_lastUpdate);
+
+    if (elapsed.count() >= UpdateInterval) {
+      m_lastUpdate = time;
+
+      LatencyMarkersReader reader = framePacer->m_latencyMarkersStorage.getReader(100);
+      const LatencyMarkers* markers;
+      uint32_t count = 0;
+      uint64_t totalLatency = 0;
+      while (reader.getNext(markers)) {
+        totalLatency += markers->gpuFinished;
+        ++count;
+      }
+
+      if (!count)
+        return;
+
+      uint64_t latency = totalLatency / count;
+      m_latency = str::format(latency / 1000, ".", (latency/100) % 10, " ms");
+    }
+  }
+
+
+  HudPos HudRenderLatencyItem::render(
+    const Rc<DxvkCommandList>&ctx,
+    const HudPipelineKey&     key,
+    const HudOptions&         options,
+          HudRenderer&        renderer,
+          HudPos              position) {
+
+    position.y += 12;
+    renderer.drawText(16, position, 0xff4040ffu, "Render latency:");
+    renderer.drawText(16, { position.x + 195, position.y },
+      0xffffffffu, m_latency);
+
+    position.y += 8;
+    return position;
+  }
+
+
+  HudPresentLatencyItem::HudPresentLatencyItem() { }
+  HudPresentLatencyItem::~HudPresentLatencyItem() { }
+
+  void HudPresentLatencyItem::update(dxvk::high_resolution_clock::time_point time) {
+    // we cannot measure latency when fps-limiting is performed in Presenter::runFrameThread()
+    // because it's interfering with getting the right timestamp from vkWaitForPresent()
+    // if we truely wanted to measure it, we would need one additional thread
+    if (FpsLimiter::m_isActive) {
+      m_latency = "N/A";
+      return;
+    }
+
+    const Rc<DxvkLatencyTracker> tracker = m_tracker;
+    FramePacer* framePacer = dynamic_cast<FramePacer*>( tracker.ptr() );
+    if (!framePacer)
+      return;
+
+    if (framePacer->getFramePacerMode()->getPresentMode() == VK_PRESENT_MODE_MAILBOX_KHR) {
+      m_latency = "N/A";
+      return;
+    }
+
+    auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(time - m_lastUpdate);
+
+    if (elapsed.count() >= UpdateInterval) {
+      m_lastUpdate = time;
+
+      LatencyMarkersReader reader = framePacer->m_latencyMarkersStorage.getReader(100);
+      const LatencyMarkers* markers;
+      uint32_t count = 0;
+      uint64_t totalLatency = 0;
+      while (reader.getNext(markers)) {
+        totalLatency += markers->presentFinished - markers->gpuFinished;
+        ++count;
+      }
+
+      if (!count)
+        return;
+
+      uint64_t latency = totalLatency / count;
+      uint32_t decimalPlaces = (latency/10) % 100;
+      std::string decimalPlacesStr = decimalPlaces < 10 ? "0" : "";
+      decimalPlacesStr.append( std::to_string(decimalPlaces) );
+      m_latency = str::format(latency / 1000, ".", decimalPlacesStr, " ms");
+    }
+  }
+
+
+  HudPos HudPresentLatencyItem::render(
+    const Rc<DxvkCommandList>&ctx,
+    const HudPipelineKey&     key,
+    const HudOptions&         options,
+          HudRenderer&        renderer,
+          HudPos              position) {
+
+    position.y += 12;
+    renderer.drawText(16, position, 0xff4040ffu, "Present latency:");
+    renderer.drawText(16, { position.x + 206, position.y },
+      0xffffffffu, m_latency);
+
+    position.y += 8;
+    return position;
+  }
+
+
+  HudLatencyDetailsItem::HudLatencyDetailsItem() { }
+  HudLatencyDetailsItem::~HudLatencyDetailsItem() { }
+
+  void HudLatencyDetailsItem::update(dxvk::high_resolution_clock::time_point time) {
+
+    const Rc<DxvkLatencyTracker> tracker = m_tracker;
+    FramePacer* framePacer = dynamic_cast<FramePacer*>( tracker.ptr() );
+    if (!framePacer)
+      return;
+
+    auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(time - m_lastUpdate);
+
+    if (elapsed.count() >= UpdateInterval) {
+      m_lastUpdate = time;
+
+      const LatencyStats* gpuBufferStats = framePacer->getGpuBufferStats();
+      int32_t p50 = gpuBufferStats->getPercentile(0.5);
+      int32_t p75 = gpuBufferStats->getPercentile(0.75);
+      int32_t p95 = gpuBufferStats->getPercentile(0.95);
+      int32_t p99 = gpuBufferStats->getPercentile(0.99);
+      m_gpuP50 = str::format(p50);
+      m_gpuP75 = str::format(p75);
+      m_gpuP95 = str::format(p95);
+      m_gpuP99 = str::format(p99);
+
+      if (framePacer->getFramePacerMode()->getPresentMode() == VK_PRESENT_MODE_FIFO_KHR
+        && (framePacer->getMode() || std::chrono::duration_cast<std::chrono::milliseconds>(
+          high_resolution_clock::now() - FpsLimiter::m_lastActive.load()).count() > 3000) ) {
+        const LatencyStats* presentStats = framePacer->getPresentStats();
+        p50 = presentStats->getPercentile(0.5);
+        p75 = presentStats->getPercentile(0.75);
+        p95 = presentStats->getPercentile(0.95);
+        p99 = presentStats->getPercentile(0.99);
+        m_presentP50 = str::format(p50);
+        m_presentP75 = str::format(p75);
+        m_presentP95 = str::format(p95);
+        m_presentP99 = str::format(p99);
+      } else {
+        m_presentP50 = "";
+      }
+
+    }
+  }
+
+
+  HudPos HudLatencyDetailsItem::render(
+    const Rc<DxvkCommandList>&ctx,
+    const HudPipelineKey&     key,
+    const HudOptions&         options,
+          HudRenderer&        renderer,
+          HudPos              position) {
+
+    constexpr int w = 12;
+    position.y += 12;
+
+    renderer.drawText(16, position, 0xff40ffffu, "GPU Buffer (us):");
+    position.y += 16;
+    int x = 2 * w;
+
+    renderer.drawText(16, { position.x + x, position.y }, 0xff40ffffu, "p50"); x += 4*w;
+    renderer.drawText(16, { position.x + x, position.y }, 0xffffffffu, m_gpuP50); x += (m_gpuP50.size()+1)*w;
+    renderer.drawText(16, { position.x + x, position.y }, 0xff40ffffu, "p75"); x += 4*w;
+    renderer.drawText(16, { position.x + x, position.y }, 0xffffffffu, m_gpuP75); x += (m_gpuP75.size()+1)*w;
+    renderer.drawText(16, { position.x + x, position.y }, 0xff40ffffu, "p95"); x += 4*w;
+    renderer.drawText(16, { position.x + x, position.y }, 0xffffffffu, m_gpuP95); x += (m_gpuP95.size()+1)*w;
+    renderer.drawText(16, { position.x + x, position.y }, 0xff40ffffu, "p99"); x += 4*w;
+    renderer.drawText(16, { position.x + x, position.y }, 0xffffffffu, m_gpuP99);
+
+    if (!m_presentP50.empty()) {
+      position.y += 18;
+      renderer.drawText(16, position, 0xff40ffffu, "V-Sync Buffer (us):");
+      position.y += 16;
+      x = 2 * w;
+
+      renderer.drawText(16, { position.x + x, position.y }, 0xff40ffffu, "p50"); x += 4*w;
+      renderer.drawText(16, { position.x + x, position.y }, 0xffffffffu, m_presentP50); x += (m_presentP50.size()+1)*w;
+      renderer.drawText(16, { position.x + x, position.y }, 0xff40ffffu, "p75"); x += 4*w;
+      renderer.drawText(16, { position.x + x, position.y }, 0xffffffffu, m_presentP75); x += (m_presentP75.size()+1)*w;
+      renderer.drawText(16, { position.x + x, position.y }, 0xff40ffffu, "p95"); x += 4*w;
+      renderer.drawText(16, { position.x + x, position.y }, 0xffffffffu, m_presentP95); x += (m_presentP95.size()+1)*w;
+      renderer.drawText(16, { position.x + x, position.y }, 0xff40ffffu, "p99"); x += 4*w;
+      renderer.drawText(16, { position.x + x, position.y }, 0xffffffffu, m_presentP99);
+    }
+
+    position.y += 8;
+    return position;
+  }
+
+
+}
diff --git a/src/dxvk/meson.build b/src/dxvk/meson.build
index 95118f50993..c5a0c40ff23 100644
--- a/src/dxvk/meson.build
+++ b/src/dxvk/meson.build
@@ -122,6 +122,7 @@ dxvk_src = [
   'hud/dxvk_hud.cpp',
   'hud/dxvk_hud_font.cpp',
   'hud/dxvk_hud_item.cpp',
+  'hud/dxvk_hud_item_latency.cpp',
   'hud/dxvk_hud_renderer.cpp',
 
   'framepacer/dxvk_framepacer.cpp',
diff --git a/src/util/util_fps_limiter.cpp b/src/util/util_fps_limiter.cpp
index f8866ff166b..4a126ac27ad 100644
--- a/src/util/util_fps_limiter.cpp
+++ b/src/util/util_fps_limiter.cpp
@@ -12,8 +12,6 @@
 using namespace std::chrono_literals;
 
 namespace dxvk {
-
-  std::atomic<bool> FpsLimiter::m_isActive = { false };
   
   FpsLimiter::FpsLimiter() {
     auto override = getEnvironmentOverride();
@@ -83,6 +81,7 @@ namespace dxvk {
 
     if (t1 < m_nextFrame) {
       m_isActive.store(true);
+      m_lastActive.store(high_resolution_clock::now());
       Sleep::sleepUntil(t1, m_nextFrame);
     }
 
diff --git a/src/util/util_fps_limiter.h b/src/util/util_fps_limiter.h
index d5610afd4d0..48e37364444 100644
--- a/src/util/util_fps_limiter.h
+++ b/src/util/util_fps_limiter.h
@@ -48,7 +48,9 @@ namespace dxvk {
      */
     static std::optional<double> getEnvironmentOverride();
 
-    static std::atomic<bool> m_isActive;
+    inline static std::atomic<bool> m_isActive = { false };
+    inline static std::atomic<high_resolution_clock::time_point>
+      m_lastActive = { high_resolution_clock::now() };
 
   private:
 

From cd329aab98d9f109d7d5c5be7dbc9029e9eb2247 Mon Sep 17 00:00:00 2001
From: netborg <137700136+netborg-afps@users.noreply.github.com>
Date: Wed, 23 Jul 2025 14:49:23 +0200
Subject: [PATCH 67/81] [dxvk] Track frame pacing buffer stats only on demand

---
 src/dxvk/framepacer/dxvk_framepacer.cpp | 17 +++++----
 src/dxvk/framepacer/dxvk_framepacer.h   | 49 +++++++++++++++----------
 src/dxvk/hud/dxvk_hud_item_latency.cpp  | 41 +++++++++++++--------
 3 files changed, 63 insertions(+), 44 deletions(-)

diff --git a/src/dxvk/framepacer/dxvk_framepacer.cpp b/src/dxvk/framepacer/dxvk_framepacer.cpp
index b9665005203..4554a23ca83 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.cpp
+++ b/src/dxvk/framepacer/dxvk_framepacer.cpp
@@ -13,13 +13,11 @@ namespace dxvk {
   }
 
 
-  FramePacer::FramePacer( const DxvkOptions& options, uint64_t firstFrameId )
-  : m_gpuBufferStats(3000), m_presentationStats(3000) {
-    // we'll default to LOW_LATENCY in the draft-PR for now, for demonstration purposes,
-    // highlighting the generally much better input lag and medium-term time consistency.
-    // although MAX_FRAME_LATENCY has advantages in many games and is likely the better default,
-    // for its higher fps throughput and less susceptibility to short-term time inconsistencies.
-    // which mode being smoother depends on the game.
+  FramePacer::FramePacer( const DxvkOptions& options, uint64_t firstFrameId ) {
+    // We'll default to LOW_LATENCY in the draft-PR for now, for demonstration purposes,
+    // highlighting the generally much better input lag and time consistency.
+    // MAX_FRAME_LATENCY has advantages in some games that provide inconsistent
+    // cpu frametimes and is tuned for highest fps which can be relevant in benchmarks.
     FramePacerMode::Mode mode = FramePacerMode::LOW_LATENCY;
     int refreshRate = 0;
 
@@ -98,6 +96,9 @@ namespace dxvk {
   }
 
 
-  FramePacer::~FramePacer() {}
+  FramePacer::~FramePacer() {
+    delete m_presentationStats.load();
+    delete m_gpuBufferStats.load();
+  }
 
 }
diff --git a/src/dxvk/framepacer/dxvk_framepacer.h b/src/dxvk/framepacer/dxvk_framepacer.h
index 92238e49073..15583e9bfcb 100644
--- a/src/dxvk/framepacer/dxvk_framepacer.h
+++ b/src/dxvk/framepacer/dxvk_framepacer.h
@@ -156,10 +156,13 @@ namespace dxvk {
 
 
     const LatencyStats* getGpuBufferStats() const
-      { return &m_gpuBufferStats; }
+      { return m_gpuBufferStats.load(); }
 
     const LatencyStats* getPresentStats() const
-      { return &m_presentationStats; }
+      { return m_presentationStats.load(); }
+
+    std::atomic< bool > m_enableGpuBufferTracking = { false };
+    std::atomic< bool > m_enableVSyncBufferTracking = { false };
 
   private:
 
@@ -184,24 +187,31 @@ namespace dxvk {
     }
 
     void trackStats( uint64_t frameId ) {
-      if (!m_trackStats)
-        return;
-
       const LatencyMarkers* m = m_latencyMarkersStorage.getConstMarkers(frameId);
-      m_presentationStats.push( m->end, m->presentFinished - m->gpuFinished );
-
-      int64_t minDiff = std::numeric_limits<int64_t>::max();
-      size_t i = 0;
-      while (m->gpuSubmit.size() > i && m->gpuReady.size() > i) {
-        int64_t diff = std::chrono::duration_cast<microseconds>(
-          m->gpuReady[i] - m->gpuSubmit[i]).count();
-        diff = std::max( (int64_t) 0, diff );
-        minDiff = std::min( minDiff, diff );
-        ++i;
+
+      if (m_enableVSyncBufferTracking) {
+        if (!m_presentationStats)
+          m_presentationStats.store( new LatencyStats(3000) );
+        m_presentationStats.load()->push( m->end, m->presentFinished - m->gpuFinished );
       }
 
-      if (minDiff != std::numeric_limits<int64_t>::max())
-        m_gpuBufferStats.push( m->end, minDiff );
+      if (m_enableGpuBufferTracking) {
+        if (!m_gpuBufferStats)
+          m_gpuBufferStats.store( new LatencyStats(3000) );
+
+        int64_t minDiff = std::numeric_limits<int64_t>::max();
+        size_t i = 0;
+        while (m->gpuSubmit.size() > i && m->gpuReady.size() > i) {
+          int64_t diff = std::chrono::duration_cast<microseconds>(
+            m->gpuReady[i] - m->gpuSubmit[i]).count();
+          diff = std::max( (int64_t) 0, diff );
+          minDiff = std::min( minDiff, diff );
+          ++i;
+        }
+
+        if (minDiff != std::numeric_limits<int64_t>::max())
+          m_gpuBufferStats.load()->push( m->end, minDiff );
+      }
     }
 
     std::unique_ptr<FramePacerMode> m_mode;
@@ -210,9 +220,8 @@ namespace dxvk {
     static constexpr uint16_t queueSubmitBit = 1;
     static constexpr uint16_t gpuReadyBit    = 2;
 
-    const bool   m_trackStats = { true };
-    LatencyStats m_gpuBufferStats;
-    LatencyStats m_presentationStats;
+    std::atomic<LatencyStats*> m_gpuBufferStats = { nullptr };
+    std::atomic<LatencyStats*> m_presentationStats = { nullptr };
 
   };
 
diff --git a/src/dxvk/hud/dxvk_hud_item_latency.cpp b/src/dxvk/hud/dxvk_hud_item_latency.cpp
index 0c7a25b012f..fdc742c6fdd 100644
--- a/src/dxvk/hud/dxvk_hud_item_latency.cpp
+++ b/src/dxvk/hud/dxvk_hud_item_latency.cpp
@@ -127,33 +127,42 @@ namespace dxvk::hud {
     if (!framePacer)
       return;
 
+    if (!framePacer->m_enableGpuBufferTracking)
+      framePacer->m_enableGpuBufferTracking.store(true);
+    if (!framePacer->m_enableVSyncBufferTracking && framePacer->getFramePacerMode()->getPresentMode() == VK_PRESENT_MODE_FIFO_KHR)
+      framePacer->m_enableVSyncBufferTracking.store(true);
+
     auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(time - m_lastUpdate);
 
     if (elapsed.count() >= UpdateInterval) {
       m_lastUpdate = time;
 
       const LatencyStats* gpuBufferStats = framePacer->getGpuBufferStats();
-      int32_t p50 = gpuBufferStats->getPercentile(0.5);
-      int32_t p75 = gpuBufferStats->getPercentile(0.75);
-      int32_t p95 = gpuBufferStats->getPercentile(0.95);
-      int32_t p99 = gpuBufferStats->getPercentile(0.99);
-      m_gpuP50 = str::format(p50);
-      m_gpuP75 = str::format(p75);
-      m_gpuP95 = str::format(p95);
-      m_gpuP99 = str::format(p99);
+      if (gpuBufferStats) {
+        int32_t p50 = gpuBufferStats->getPercentile(0.5);
+        int32_t p75 = gpuBufferStats->getPercentile(0.75);
+        int32_t p95 = gpuBufferStats->getPercentile(0.95);
+        int32_t p99 = gpuBufferStats->getPercentile(0.99);
+        m_gpuP50 = str::format(p50);
+        m_gpuP75 = str::format(p75);
+        m_gpuP95 = str::format(p95);
+        m_gpuP99 = str::format(p99);
+      }
 
       if (framePacer->getFramePacerMode()->getPresentMode() == VK_PRESENT_MODE_FIFO_KHR
         && (framePacer->getMode() || std::chrono::duration_cast<std::chrono::milliseconds>(
           high_resolution_clock::now() - FpsLimiter::m_lastActive.load()).count() > 3000) ) {
         const LatencyStats* presentStats = framePacer->getPresentStats();
-        p50 = presentStats->getPercentile(0.5);
-        p75 = presentStats->getPercentile(0.75);
-        p95 = presentStats->getPercentile(0.95);
-        p99 = presentStats->getPercentile(0.99);
-        m_presentP50 = str::format(p50);
-        m_presentP75 = str::format(p75);
-        m_presentP95 = str::format(p95);
-        m_presentP99 = str::format(p99);
+        if (presentStats) {
+          int32_t p50 = presentStats->getPercentile(0.5);
+          int32_t p75 = presentStats->getPercentile(0.75);
+          int32_t p95 = presentStats->getPercentile(0.95);
+          int32_t p99 = presentStats->getPercentile(0.99);
+          m_presentP50 = str::format(p50);
+          m_presentP75 = str::format(p75);
+          m_presentP95 = str::format(p95);
+          m_presentP99 = str::format(p99);
+        }
       } else {
         m_presentP50 = "";
       }

From 003f17be65a61aa4b58c9d0902f102f9acc947a3 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Thu, 24 Jul 2025 05:46:15 +0200
Subject: [PATCH 68/81] [build] Add '/Qpar', '/Qpar-report:2' 'Qvec-report:2'
 for MSVC builds

Somehow, they were not added in previous versions.
---
 meson.build | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/meson.build b/meson.build
index e45bb5439d8..3a705a64c8a 100644
--- a/meson.build
+++ b/meson.build
@@ -106,7 +106,10 @@ if platform == 'windows'
       '/O2',
       '/Ob3',
       '/GL',
-      '/Gw'
+      '/Gw',
+      '/Qpar',
+      '/Qpar-report:2',
+      '/Qvec-report:2'
     ]
     # MSVC Linker Options
     link_args += [

From d7380f2826257a9b11c7939cbdcc254565f27347 Mon Sep 17 00:00:00 2001
From: Laitinlok <adrianlai2000@hotmail.com>
Date: Sun, 3 Aug 2025 04:28:08 +0800
Subject: [PATCH 69/81] Support state cache in dxvk 2.7

---
 src/dxvk/dxvk_compute.cpp      |   2 +
 src/dxvk/dxvk_compute.h        |   2 +
 src/dxvk/dxvk_graphics.cpp     |  20 ++++++
 src/dxvk/dxvk_graphics.h       |   5 ++
 src/dxvk/dxvk_graphics_state.h | 116 +++++++++++++++++++++++++++++++++
 src/dxvk/dxvk_options.cpp      |   1 +
 src/dxvk/dxvk_options.h        |   3 +
 src/dxvk/dxvk_pipemanager.cpp  |  18 ++++-
 src/dxvk/dxvk_pipemanager.h    |   2 +
 src/dxvk/meson.build           |   1 +
 src/util/config/config.cpp     |   4 ++
 11 files changed, 173 insertions(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_compute.cpp b/src/dxvk/dxvk_compute.cpp
index 60465c590eb..cc12d41e57b 100644
--- a/src/dxvk/dxvk_compute.cpp
+++ b/src/dxvk/dxvk_compute.cpp
@@ -8,6 +8,7 @@
 #include "dxvk_device.h"
 #include "dxvk_graphics.h"
 #include "dxvk_pipemanager.h"
+#include "dxvk_state_cache.h"
 
 namespace dxvk {
   
@@ -17,6 +18,7 @@ namespace dxvk {
           DxvkComputePipelineShaders  shaders,
           DxvkShaderPipelineLibrary*  library)
   : m_device        (device),
+    m_stateCache    (&pipeMgr->m_stateCache),
     m_stats         (&pipeMgr->m_stats),
     m_library       (library),
     m_libraryHandle (VK_NULL_HANDLE),
diff --git a/src/dxvk/dxvk_compute.h b/src/dxvk/dxvk_compute.h
index 6252ef01e6c..7ac0af1ff84 100644
--- a/src/dxvk/dxvk_compute.h
+++ b/src/dxvk/dxvk_compute.h
@@ -13,6 +13,7 @@
 namespace dxvk {
   
   class DxvkDevice;
+  class DxvkStateCache;
   class DxvkPipelineManager;
   struct DxvkPipelineStats;
 
@@ -127,6 +128,7 @@ namespace dxvk {
   private:
     
     DxvkDevice*                 m_device;    
+    DxvkStateCache*             m_stateCache;
     DxvkPipelineStats*          m_stats;
 
     DxvkShaderPipelineLibrary*  m_library;
diff --git a/src/dxvk/dxvk_graphics.cpp b/src/dxvk/dxvk_graphics.cpp
index f9d0878d454..760a0889674 100644
--- a/src/dxvk/dxvk_graphics.cpp
+++ b/src/dxvk/dxvk_graphics.cpp
@@ -5,6 +5,7 @@
 #include "dxvk_device.h"
 #include "dxvk_graphics.h"
 #include "dxvk_pipemanager.h"
+#include "dxvk_state_cache.h"
 
 namespace dxvk {
 
@@ -1000,6 +1001,7 @@ namespace dxvk {
   : m_device        (device),
     m_manager       (pipeMgr),
     m_workers       (&pipeMgr->m_workers),
+    m_stateCache    (&pipeMgr->m_stateCache),
     m_stats         (&pipeMgr->m_stats),
     m_shaders       (std::move(shaders)),
     m_layout        (device, pipeMgr, buildPipelineLayout()),
@@ -1098,6 +1100,11 @@ namespace dxvk {
         // If necessary, compile an optimized pipeline variant
         if (!instance->fastHandle.load())
           m_workers->compileGraphicsPipeline(this, state, DxvkPipelinePriority::Low);
+
+        // Only store pipelines in the state cache that cannot benefit
+        // from pipeline libraries, or if that feature is disabled.
+        if (!canCreateBasePipeline)
+          this->writePipelineStateToCache(state);
       }
     }
 
@@ -1640,6 +1647,19 @@ namespace dxvk {
   }
 
   
+  void DxvkGraphicsPipeline::writePipelineStateToCache(
+    const DxvkGraphicsPipelineStateInfo& state) const {
+    DxvkStateCacheKey key;
+    if (m_shaders.vs  != nullptr) key.vs = m_shaders.vs->getShaderKey();
+    if (m_shaders.tcs != nullptr) key.tcs = m_shaders.tcs->getShaderKey();
+    if (m_shaders.tes != nullptr) key.tes = m_shaders.tes->getShaderKey();
+    if (m_shaders.gs  != nullptr) key.gs = m_shaders.gs->getShaderKey();
+    if (m_shaders.fs  != nullptr) key.fs = m_shaders.fs->getShaderKey();
+
+    m_stateCache->addGraphicsPipeline(key, state);
+  }
+  
+  
   void DxvkGraphicsPipeline::logPipelineState(
           LogLevel                       level,
     const DxvkGraphicsPipelineStateInfo& state) const {
diff --git a/src/dxvk/dxvk_graphics.h b/src/dxvk/dxvk_graphics.h
index 956d1ed1093..0593e355358 100644
--- a/src/dxvk/dxvk_graphics.h
+++ b/src/dxvk/dxvk_graphics.h
@@ -15,6 +15,7 @@
 namespace dxvk {
   
   class DxvkDevice;
+  class DxvkStateCache;
   class DxvkPipelineManager;
   class DxvkPipelineWorkers;
 
@@ -600,6 +601,7 @@ namespace dxvk {
     DxvkDevice*                 m_device;    
     DxvkPipelineManager*        m_manager;
     DxvkPipelineWorkers*        m_workers;
+    DxvkStateCache*             m_stateCache;
     DxvkPipelineStats*          m_stats;
 
     DxvkGraphicsPipelineShaders m_shaders;
@@ -681,6 +683,9 @@ namespace dxvk {
 
     DxvkPipelineLayoutBuilder buildPipelineLayout() const;
 
+    void writePipelineStateToCache(
+      const DxvkGraphicsPipelineStateInfo& state) const;
+
     void logPipelineState(
             LogLevel                       level,
       const DxvkGraphicsPipelineStateInfo& state) const;
diff --git a/src/dxvk/dxvk_graphics_state.h b/src/dxvk/dxvk_graphics_state.h
index 8601dd7efca..be8de1cec56 100644
--- a/src/dxvk/dxvk_graphics_state.h
+++ b/src/dxvk/dxvk_graphics_state.h
@@ -321,6 +321,119 @@ namespace dxvk {
   };
 
 
+  /**
+   * \brief Packed depth-stencil metadata
+   *
+   * Stores some flags and the depth-compare op in
+   * two bytes. Stencil ops are stored separately.
+   */
+  class DxvkDsInfo {
+
+  public:
+
+    DxvkDsInfo() = default;
+
+    DxvkDsInfo(
+            VkBool32 enableDepthTest,
+            VkBool32 enableDepthWrite,
+            VkBool32 enableDepthBoundsTest,
+            VkBool32 enableStencilTest,
+            VkCompareOp depthCompareOp)
+    : m_enableDepthTest       (uint16_t(enableDepthTest)),
+      m_enableDepthWrite      (uint16_t(enableDepthWrite)),
+      m_enableDepthBoundsTest (uint16_t(enableDepthBoundsTest)),
+      m_enableStencilTest     (uint16_t(enableStencilTest)),
+      m_depthCompareOp        (uint16_t(depthCompareOp)),
+      m_reserved              (0) { }
+    
+    VkBool32 enableDepthTest() const {
+      return VkBool32(m_enableDepthTest);
+    }
+
+    VkBool32 enableDepthWrite() const {
+      return VkBool32(m_enableDepthWrite);
+    }
+
+    VkBool32 enableDepthBoundsTest() const {
+      return VkBool32(m_enableDepthBoundsTest);
+    }
+
+    VkBool32 enableStencilTest() const {
+      return VkBool32(m_enableStencilTest);
+    }
+
+    VkCompareOp depthCompareOp() const {
+      return VkCompareOp(m_depthCompareOp);
+    }
+
+    void setEnableDepthBoundsTest(VkBool32 enableDepthBoundsTest) {
+      m_enableDepthBoundsTest = VkBool32(enableDepthBoundsTest);
+    }
+
+  private:
+
+    uint16_t m_enableDepthTest        : 1;
+    uint16_t m_enableDepthWrite       : 1;
+    uint16_t m_enableDepthBoundsTest  : 1;
+    uint16_t m_enableStencilTest      : 1;
+    uint16_t m_depthCompareOp         : 3;
+    uint16_t m_reserved               : 9;
+
+  };
+
+
+  /**
+   * \brief Packed stencil op
+   *
+   * Stores various stencil op parameters
+   * for one single face in four bytes.
+   */
+  class DxvkDsStencilOp {
+
+  public:
+
+    DxvkDsStencilOp() = default;
+
+    DxvkDsStencilOp(
+            VkStencilOp           failOp,
+            VkStencilOp           passOp,
+            VkStencilOp           depthFailOp,
+            VkCompareOp           compareOp,
+            uint8_t               compareMask,
+            uint8_t               writeMask)
+    : m_failOp      (uint32_t(failOp)),
+      m_passOp      (uint32_t(passOp)),
+      m_depthFailOp (uint32_t(depthFailOp)),
+      m_compareOp   (uint32_t(compareOp)),
+      m_reserved    (0),
+      m_compareMask (uint32_t(compareMask)),
+      m_writeMask   (uint32_t(writeMask)) { }
+    
+    VkStencilOpState state(bool write) const {
+      VkStencilOpState result;
+      result.failOp      = VkStencilOp(m_failOp);
+      result.passOp      = VkStencilOp(m_passOp);
+      result.depthFailOp = VkStencilOp(m_depthFailOp);
+      result.compareOp   = VkCompareOp(m_compareOp);
+      result.compareMask = m_compareMask;
+      result.writeMask   = write ? m_writeMask : 0;
+      result.reference   = 0;
+      return result;
+    }
+
+  private:
+
+    uint32_t m_failOp                 : 3;
+    uint32_t m_passOp                 : 3;
+    uint32_t m_depthFailOp            : 3;
+    uint32_t m_compareOp              : 3;
+    uint32_t m_reserved               : 4;
+    uint32_t m_compareMask            : 8;
+    uint32_t m_writeMask              : 8;
+
+  };
+
+
   /**
    * \brief Packed output merger metadata
    *
@@ -708,9 +821,12 @@ namespace dxvk {
     DxvkIlInfo              il;
     DxvkRsInfo              rs;
     DxvkMsInfo              ms;
+    DxvkDsInfo              ds;
     DxvkOmInfo              om;
     DxvkRtInfo              rt;
     DxvkScInfo              sc;
+    DxvkDsStencilOp         dsFront;
+    DxvkDsStencilOp         dsBack;
     DxvkOmAttachmentSwizzle omSwizzle         [DxvkLimits::MaxNumRenderTargets];
     DxvkOmAttachmentBlend   omBlend           [DxvkLimits::MaxNumRenderTargets];
     DxvkIlAttribute         ilAttributes      [DxvkLimits::MaxNumVertexAttributes];
diff --git a/src/dxvk/dxvk_options.cpp b/src/dxvk/dxvk_options.cpp
index 169a746bb54..f5a611fd7bb 100644
--- a/src/dxvk/dxvk_options.cpp
+++ b/src/dxvk/dxvk_options.cpp
@@ -5,6 +5,7 @@ namespace dxvk {
   DxvkOptions::DxvkOptions(const Config& config) {
     enableAsync           = config.getOption<bool>    ("dxvk.enableAsync",            true);
     enableDebugUtils      = config.getOption<bool>    ("dxvk.enableDebugUtils",       false);
+    enableStateCache      = config.getOption<bool>    ("dxvk.enableStateCache",       true);
     enableMemoryDefrag    = config.getOption<Tristate>("dxvk.enableMemoryDefrag",     Tristate::Auto);
     numCompilerThreads    = config.getOption<int32_t> ("dxvk.numCompilerThreads",     0);
     enableGraphicsPipelineLibrary = config.getOption<Tristate>("dxvk.enableGraphicsPipelineLibrary", Tristate::False);
diff --git a/src/dxvk/dxvk_options.h b/src/dxvk/dxvk_options.h
index 8ae2e492fa1..e9e554f6ca3 100644
--- a/src/dxvk/dxvk_options.h
+++ b/src/dxvk/dxvk_options.h
@@ -13,6 +13,9 @@ namespace dxvk {
     /// Enable debug utils
     bool enableDebugUtils = false;
 
+    /// Enable state cache
+    bool enableStateCache = true;
+
     /// Enable memory defragmentation
     Tristate enableMemoryDefrag = Tristate::Auto;
 
diff --git a/src/dxvk/dxvk_pipemanager.cpp b/src/dxvk/dxvk_pipemanager.cpp
index 18f907002f6..1a6c231eda0 100644
--- a/src/dxvk/dxvk_pipemanager.cpp
+++ b/src/dxvk/dxvk_pipemanager.cpp
@@ -2,6 +2,7 @@
 
 #include "dxvk_device.h"
 #include "dxvk_pipemanager.h"
+#include "dxvk_state_cache.h"
 
 namespace dxvk {
   
@@ -180,7 +181,8 @@ namespace dxvk {
   DxvkPipelineManager::DxvkPipelineManager(
           DxvkDevice*         device)
   : m_device    (device),
-    m_workers   (device) {
+    m_workers   (device),
+    m_stateCache(device, this, &m_workers) {
     Logger::info(str::format("DXVK: Graphics pipeline libraries ",
       (m_device->canUseGraphicsPipelineLibrary() ? "supported" : "not supported")));
 
@@ -251,6 +253,17 @@ namespace dxvk {
           // Don't dispatch the pipeline library to a worker thread
           // since it should be compiled on demand anyway.
           vsLibrary = createPipelineLibraryLocked(vsKey);
+
+          // Register the pipeline library with the state cache
+          // so that subsequent runs can still compile it early
+          DxvkStateCacheKey shaderKeys;
+          shaderKeys.vs = shaders.vs->getShaderKey();
+
+          if (shaders.tcs != nullptr) shaderKeys.tcs = shaders.tcs->getShaderKey();
+          if (shaders.tes != nullptr) shaderKeys.tes = shaders.tes->getShaderKey();
+          if (shaders.gs  != nullptr) shaderKeys.gs  = shaders.gs->getShaderKey();
+
+          m_stateCache.addPipelineLibrary(shaderKeys);
         }
       }
 
@@ -320,6 +333,8 @@ namespace dxvk {
       auto library = createShaderPipelineLibrary(key);
       m_workers.compilePipelineLibrary(library, DxvkPipelinePriority::Normal);
     }
+
+    m_stateCache.registerShader(shader);
   }
 
 
@@ -354,6 +369,7 @@ namespace dxvk {
 
   void DxvkPipelineManager::stopWorkerThreads() {
     m_workers.stopWorkers();
+    m_stateCache.stopWorkers();
   }
 
 
diff --git a/src/dxvk/dxvk_pipemanager.h b/src/dxvk/dxvk_pipemanager.h
index 494ac9efec8..780fe70683d 100644
--- a/src/dxvk/dxvk_pipemanager.h
+++ b/src/dxvk/dxvk_pipemanager.h
@@ -7,6 +7,7 @@
 
 #include "dxvk_compute.h"
 #include "dxvk_graphics.h"
+#include "dxvk_state_cache.h"
 
 namespace dxvk {
 
@@ -285,6 +286,7 @@ namespace dxvk {
     
     DxvkDevice*               m_device;
     DxvkPipelineWorkers       m_workers;
+    DxvkStateCache            m_stateCache;
     DxvkPipelineStats         m_stats;
     
     dxvk::mutex m_mutex;
diff --git a/src/dxvk/meson.build b/src/dxvk/meson.build
index 95118f50993..d87ed80f3e5 100644
--- a/src/dxvk/meson.build
+++ b/src/dxvk/meson.build
@@ -114,6 +114,7 @@ dxvk_src = [
   'dxvk_signal.cpp',
   'dxvk_sparse.cpp',
   'dxvk_staging.cpp',
+  'dxvk_state_cache.cpp',
   'dxvk_stats.cpp',
   'dxvk_swapchain_blitter.cpp',
   'dxvk_unbound.cpp',
diff --git a/src/util/config/config.cpp b/src/util/config/config.cpp
index a29fd96e01f..8f20e62cc59 100644
--- a/src/util/config/config.cpp
+++ b/src/util/config/config.cpp
@@ -113,6 +113,10 @@ namespace dxvk {
     { R"(\\nioh\.exe$)", {{
       { "d3d9.deferSurfaceCreation",        "True" },
     }} },
+    /* Anno 2205: Random crashes with state cache */
+    { R"(\\anno2205\.exe$)", {{
+      { "dxvk.enableStateCache",            "False" },
+    }} },
     /* Anno 1800: Poor performance without this   */
     { R"(\\Anno1800\.exe$)", {{
       { "d3d11.cachedDynamicResources",     "c"    },

From 4191766ad80fcc83bc4ab8c8ad48c81d56564b57 Mon Sep 17 00:00:00 2001
From: Laitinlok <adrianlai2000@hotmail.com>
Date: Sun, 3 Aug 2025 04:38:48 +0800
Subject: [PATCH 70/81] Support state cache in dxvk 2.7

---
 src/dxvk/dxvk_state_cache.cpp     | 902 ++++++++++++++++++++++++++++++
 src/dxvk/dxvk_state_cache.h       | 169 ++++++
 src/dxvk/dxvk_state_cache_types.h | 172 ++++++
 3 files changed, 1243 insertions(+)
 create mode 100644 src/dxvk/dxvk_state_cache.cpp
 create mode 100644 src/dxvk/dxvk_state_cache.h
 create mode 100644 src/dxvk/dxvk_state_cache_types.h

diff --git a/src/dxvk/dxvk_state_cache.cpp b/src/dxvk/dxvk_state_cache.cpp
new file mode 100644
index 00000000000..bf669dcf24c
--- /dev/null
+++ b/src/dxvk/dxvk_state_cache.cpp
@@ -0,0 +1,902 @@
+#include "dxvk_device.h"
+#include "dxvk_pipemanager.h"
+#include "dxvk_state_cache.h"
+
+namespace dxvk {
+
+  static const Sha1Hash       g_nullHash      = Sha1Hash::compute(nullptr, 0);
+  static const DxvkShaderKey  g_nullShaderKey = DxvkShaderKey();
+
+
+  /**
+   * \brief Packed entry header
+   */
+  struct DxvkStateCacheEntryHeader {
+    uint32_t entryType : 1;
+    uint32_t stageMask : 5;
+    uint32_t entrySize : 26;
+  };
+
+
+  /**
+   * \brief Version 8 entry header
+   */
+  struct DxvkStateCacheEntryHeaderV8 {
+    uint32_t stageMask : 8;
+    uint32_t entrySize : 24;
+  };
+
+  
+  /**
+   * \brief State cache entry data
+   *
+   * Stores data for a single cache entry and
+   * provides convenience methods to access it.
+   */
+  class DxvkStateCacheEntryData {
+    constexpr static size_t MaxSize = 1024;
+  public:
+
+    size_t size() const {
+      return m_size;
+    }
+
+    const char* data() const {
+      return m_data;
+    }
+
+    Sha1Hash computeHash() const {
+      return Sha1Hash::compute(m_data, m_size);
+    }
+
+    template<typename T>
+    bool read(T& data, uint32_t version) {
+      return read(data);
+    }
+
+    bool read(DxvkStateCacheKey& shaders, uint32_t version, VkShaderStageFlags stageFlags) {
+      DxvkShaderKey dummyKey;
+
+      std::array<std::pair<VkShaderStageFlagBits, DxvkShaderKey*>, 6> stages = {{
+        { VK_SHADER_STAGE_VERTEX_BIT,                   &shaders.vs },
+        { VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,     &shaders.tcs },
+        { VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,  &shaders.tes },
+        { VK_SHADER_STAGE_GEOMETRY_BIT,                 &shaders.gs },
+        { VK_SHADER_STAGE_FRAGMENT_BIT,                 &shaders.fs },
+        { VK_SHADER_STAGE_COMPUTE_BIT,                  &dummyKey },
+      }};
+
+      for (uint32_t i = 0; i < stages.size(); i++) {
+        if (stageFlags & stages[i].first) {
+          if (!read(*stages[i].second, version))
+            return false;
+        }
+      }
+
+      return true;
+    }
+
+    bool read(DxvkBindingMaskV10& data, uint32_t version) {
+      // v11 removes this field
+      if (version >= 11)
+        return true;
+
+      if (version < 9) {
+        DxvkBindingMaskV8 v8;
+        return read(v8);
+      }
+
+      return read(data);
+    }
+
+    bool read(DxvkRsInfo& data, uint32_t version) {
+      if (version < 13) {
+        DxvkRsInfoV12 v12;
+
+        if (!read(v12))
+          return false;
+
+        data = v12.convert();
+        return true;
+      }
+
+      if (version < 14) {
+        DxvkRsInfoV13 v13;
+
+        if (!read(v13))
+          return false;
+
+        data = v13.convert();
+        return true;
+      }
+
+      return read(data);
+    }
+
+    bool read(DxvkRtInfo& data, uint32_t version) {
+      // v12 introduced this field
+      if (version < 12)
+        return true;
+
+      return read(data);
+    }
+
+    bool read(DxvkIlBinding& data, uint32_t version) {
+      if (version < 10) {
+        DxvkIlBindingV9 v9;
+
+        if (!read(v9))
+          return false;
+
+        data = v9.convert();
+        return true;
+      }
+
+      if (!read(data))
+        return false;
+
+      // Format hasn't changed, but we introduced
+      // dynamic vertex strides in the meantime
+      if (version < 15)
+        data.setStride(0);
+
+      return true;
+    }
+
+
+    bool read(DxvkRenderPassFormatV11& data, uint32_t version) {
+      uint8_t sampleCount = 0;
+      uint8_t imageFormat = 0;
+      uint8_t imageLayout = 0;
+
+      if (!read(sampleCount)
+       || !read(imageFormat)
+       || !read(imageLayout))
+        return false;
+
+      data.sampleCount = VkSampleCountFlagBits(sampleCount);
+      data.depth.format = VkFormat(imageFormat);
+      data.depth.layout = unpackImageLayoutV11(imageLayout);
+
+      for (uint32_t i = 0; i < MaxNumRenderTargets; i++) {
+        if (!read(imageFormat)
+         || !read(imageLayout))
+          return false;
+
+        data.color[i].format = VkFormat(imageFormat);
+        data.color[i].layout = unpackImageLayoutV11(imageLayout);
+      }
+
+      return true;
+    }
+
+
+    template<typename T>
+    bool write(const T& data) {
+      if (m_size + sizeof(T) > MaxSize)
+        return false;
+      
+      std::memcpy(&m_data[m_size], &data, sizeof(T));
+      m_size += sizeof(T);
+      return true;
+    }
+
+    bool readFromStream(std::istream& stream, size_t size) {
+      if (size > MaxSize)
+        return false;
+
+      if (!stream.read(m_data, size))
+        return false;
+
+      m_size = size;
+      m_read = 0;
+      return true;
+    }
+
+  private:
+
+    size_t m_size = 0;
+    size_t m_read = 0;
+    char   m_data[MaxSize];
+
+    template<typename T>
+    bool read(T& data) {
+      if (m_read + sizeof(T) > m_size)
+        return false;
+
+      std::memcpy(&data, &m_data[m_read], sizeof(T));
+      m_read += sizeof(T);
+      return true;
+    }
+
+    static VkImageLayout unpackImageLayoutV11(
+            uint8_t                   layout) {
+      switch (layout) {
+        case 0x80: return VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL;
+        case 0x81: return VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL;
+        default: return VkImageLayout(layout);
+      }
+    }
+
+  };
+
+
+  template<typename T>
+  bool readCacheEntryTyped(std::istream& stream, T& entry) {
+    auto data = reinterpret_cast<char*>(&entry);
+    auto size = sizeof(entry);
+
+    if (!stream.read(data, size))
+      return false;
+    
+    Sha1Hash expectedHash = std::exchange(entry.hash, g_nullHash);
+    Sha1Hash computedHash = Sha1Hash::compute(entry);
+    return expectedHash == computedHash;
+  }
+
+
+  bool DxvkStateCacheKey::eq(const DxvkStateCacheKey& key) const {
+    return this->vs.eq(key.vs)
+        && this->tcs.eq(key.tcs)
+        && this->tes.eq(key.tes)
+        && this->gs.eq(key.gs)
+        && this->fs.eq(key.fs);
+  }
+
+
+  size_t DxvkStateCacheKey::hash() const {
+    DxvkHashState hash;
+    hash.add(this->vs.hash());
+    hash.add(this->tcs.hash());
+    hash.add(this->tes.hash());
+    hash.add(this->gs.hash());
+    hash.add(this->fs.hash());
+    return hash;
+  }
+
+
+  DxvkStateCache::DxvkStateCache(
+          DxvkDevice*           device,
+          DxvkPipelineManager*  pipeManager,
+          DxvkPipelineWorkers*  pipeWorkers)
+  : m_device      (device),
+    m_pipeManager (pipeManager),
+    m_pipeWorkers (pipeWorkers) {
+    std::string useStateCache = env::getEnvVar("DXVK_STATE_CACHE");
+    m_enable = useStateCache != "0" && useStateCache != "disable" &&
+      device->config().enableStateCache;
+
+    if (!m_enable)
+      return;
+
+    bool newFile = (useStateCache == "reset") || (!readCacheFile());
+
+    if (newFile) {
+      auto file = openCacheFileForWrite(true);
+
+      // Write all valid entries to the cache file in
+      // case we're recovering a corrupted cache file
+      for (auto& e : m_entries)
+        writeCacheEntry(file, e);
+    }
+  }
+  
+
+  DxvkStateCache::~DxvkStateCache() {
+    this->stopWorkers();
+  }
+
+
+  void DxvkStateCache::addPipelineLibrary(
+    const DxvkStateCacheKey&              shaders) {
+    if (!m_enable || shaders.vs.eq(g_nullShaderKey))
+      return;
+
+    // Do not add an entry that is already in the cache
+    auto entries = m_entryMap.equal_range(shaders);
+
+    for (auto e = entries.first; e != entries.second; e++) {
+      if (m_entries[e->second].type == DxvkStateCacheEntryType::PipelineLibrary)
+        return;
+    }
+
+    // Queue a job to write this pipeline to the cache
+    std::unique_lock<dxvk::mutex> lock(m_writerLock);
+
+    m_writerQueue.push({
+      DxvkStateCacheEntryType::PipelineLibrary, shaders,
+      DxvkGraphicsPipelineStateInfo(), g_nullHash });
+    m_writerCond.notify_one();
+
+    createWriter();
+  }
+
+
+  void DxvkStateCache::addGraphicsPipeline(
+    const DxvkStateCacheKey&              shaders,
+    const DxvkGraphicsPipelineStateInfo&  state) {
+    if (!m_enable || shaders.vs.eq(g_nullShaderKey))
+      return;
+
+    // Do not add an entry that is already in the cache
+    auto entries = m_entryMap.equal_range(shaders);
+
+    for (auto e = entries.first; e != entries.second; e++) {
+      if (m_entries[e->second].type == DxvkStateCacheEntryType::MonolithicPipeline
+       && m_entries[e->second].gpState == state)
+        return;
+    }
+
+    // Queue a job to write this pipeline to the cache
+    std::unique_lock<dxvk::mutex> lock(m_writerLock);
+
+    m_writerQueue.push({
+      DxvkStateCacheEntryType::MonolithicPipeline,
+      shaders, state, g_nullHash });
+    m_writerCond.notify_one();
+
+    createWriter();
+  }
+
+
+  void DxvkStateCache::registerShader(const Rc<DxvkShader>& shader) {
+    if (!m_enable)
+      return;
+
+    DxvkShaderKey key = shader->getShaderKey();
+
+    if (key.eq(g_nullShaderKey))
+      return;
+    
+    // Add the shader so we can look it up by its key
+    std::unique_lock<dxvk::mutex> entryLock(m_entryLock);
+    m_shaderMap.insert({ key, shader });
+
+    // Deferred lock, don't stall workers unless we have to
+    std::unique_lock<dxvk::mutex> workerLock;
+
+    auto pipelines = m_pipelineMap.equal_range(key);
+
+    for (auto p = pipelines.first; p != pipelines.second; p++) {
+      WorkerItem item;
+
+      if (!getShaderByKey(p->second.vs,  item.gp.vs)
+       || !getShaderByKey(p->second.tcs, item.gp.tcs)
+       || !getShaderByKey(p->second.tes, item.gp.tes)
+       || !getShaderByKey(p->second.gs,  item.gp.gs)
+       || !getShaderByKey(p->second.fs,  item.gp.fs))
+        continue;
+      
+      if (!workerLock)
+        workerLock = std::unique_lock<dxvk::mutex>(m_workerLock);
+      
+      m_workerQueue.push(item);
+    }
+
+    if (workerLock) {
+      m_workerCond.notify_all();
+      createWorker();
+    }
+  }
+
+
+  void DxvkStateCache::stopWorkers() {
+    { std::lock_guard<dxvk::mutex> workerLock(m_workerLock);
+      std::lock_guard<dxvk::mutex> writerLock(m_writerLock);
+
+      if (m_stopThreads.exchange(true))
+        return;
+
+      m_workerCond.notify_all();
+      m_writerCond.notify_all();
+    }
+
+    if (m_workerThread.joinable())
+      m_workerThread.join();
+    
+    if (m_writerThread.joinable())
+      m_writerThread.join();
+  }
+
+
+  DxvkShaderKey DxvkStateCache::getShaderKey(const Rc<DxvkShader>& shader) const {
+    return shader != nullptr ? shader->getShaderKey() : g_nullShaderKey;
+  }
+
+
+  bool DxvkStateCache::getShaderByKey(
+    const DxvkShaderKey&            key,
+          Rc<DxvkShader>&           shader) const {
+    if (key.eq(g_nullShaderKey))
+      return true;
+    
+    auto entry = m_shaderMap.find(key);
+    if (entry == m_shaderMap.end())
+      return false;
+
+    shader = entry->second;
+    return true;
+  }
+
+
+  void DxvkStateCache::mapPipelineToEntry(
+    const DxvkStateCacheKey&        key,
+          size_t                    entryId) {
+    m_entryMap.insert({ key, entryId });
+  }
+
+  
+  void DxvkStateCache::mapShaderToPipeline(
+    const DxvkShaderKey&            shader,
+    const DxvkStateCacheKey&        key) {
+    if (!shader.eq(g_nullShaderKey))
+      m_pipelineMap.insert({ shader, key });
+  }
+
+
+  void DxvkStateCache::compilePipelines(const WorkerItem& item) {
+    DxvkStateCacheKey key;
+    key.vs  = getShaderKey(item.gp.vs);
+    key.tcs = getShaderKey(item.gp.tcs);
+    key.tes = getShaderKey(item.gp.tes);
+    key.gs  = getShaderKey(item.gp.gs);
+    key.fs  = getShaderKey(item.gp.fs);
+
+    DxvkGraphicsPipeline* pipeline = nullptr;
+    auto entries = m_entryMap.equal_range(key);
+
+    for (auto e = entries.first; e != entries.second; e++) {
+      const auto& entry = m_entries[e->second];
+
+      switch (entry.type) {
+        case DxvkStateCacheEntryType::MonolithicPipeline: {
+          if (!pipeline)
+            pipeline = m_pipeManager->createGraphicsPipeline(item.gp);
+
+          m_pipeWorkers->compileGraphicsPipeline(pipeline, entry.gpState, DxvkPipelinePriority::Normal);
+        } break;
+
+        case DxvkStateCacheEntryType::PipelineLibrary: {
+          if (!m_device->canUseGraphicsPipelineLibrary() || item.gp.vs == nullptr)
+            break;
+
+          DxvkShaderPipelineLibraryKey libraryKey;
+          libraryKey.addShader(item.gp.vs);
+
+          if (item.gp.tcs != nullptr) libraryKey.addShader(item.gp.tcs);
+          if (item.gp.tes != nullptr) libraryKey.addShader(item.gp.tes);
+          if (item.gp.gs  != nullptr) libraryKey.addShader(item.gp.gs);
+
+          auto pipelineLibrary = m_pipeManager->createShaderPipelineLibrary(libraryKey);
+          m_pipeWorkers->compilePipelineLibrary(pipelineLibrary, DxvkPipelinePriority::Normal);
+        } break;
+      }
+    }
+  }
+
+
+  bool DxvkStateCache::readCacheFile() {
+    // Return success if the file was not found.
+    // This way we will only create it on demand.
+    std::ifstream ifile = openCacheFileForRead();
+
+    if (!ifile) {
+      Logger::debug("DXVK: No state cache file found");
+      return true;
+    }
+
+    // The header stores the state cache version,
+    // we need to regenerate it if it's outdated
+    DxvkStateCacheHeader newHeader;
+    DxvkStateCacheHeader curHeader;
+
+    if (!readCacheHeader(ifile, curHeader)) {
+      Logger::warn("DXVK: Failed to read state cache header");
+      return false;
+    }
+
+    // Discard caches of unsupported versions
+    if (curHeader.version < 8 || curHeader.version == 16
+     || curHeader.version > newHeader.version) {
+      Logger::warn("DXVK: State cache version not supported");
+      return false;
+    }
+
+    // Notify user about format conversion
+    if (curHeader.version != newHeader.version)
+      Logger::info(str::format("DXVK: Updating state cache version to v", newHeader.version));
+
+    // Read actual cache entries from the file.
+    // If we encounter invalid entries, we should
+    // regenerate the entire state cache file.
+    uint32_t numInvalidEntries = 0;
+
+    while (ifile) {
+      DxvkStateCacheEntry entry;
+
+      if (readCacheEntry(curHeader.version, ifile, entry)) {
+        size_t entryId = m_entries.size();
+        m_entries.push_back(entry);
+
+        mapPipelineToEntry(entry.shaders, entryId);
+
+        mapShaderToPipeline(entry.shaders.vs,  entry.shaders);
+        mapShaderToPipeline(entry.shaders.tcs, entry.shaders);
+        mapShaderToPipeline(entry.shaders.tes, entry.shaders);
+        mapShaderToPipeline(entry.shaders.gs,  entry.shaders);
+        mapShaderToPipeline(entry.shaders.fs,  entry.shaders);
+      } else if (ifile) {
+        numInvalidEntries += 1;
+      }
+    }
+
+    Logger::info(str::format(
+      "DXVK: Read ", m_entries.size(),
+      " valid state cache entries"));
+
+    if (numInvalidEntries) {
+      Logger::warn(str::format(
+        "DXVK: Skipped ", numInvalidEntries,
+        " invalid state cache entries"));
+      return false;
+    }
+    
+    // Rewrite entire state cache if it is outdated
+    return curHeader.version == newHeader.version;
+  }
+
+
+  bool DxvkStateCache::readCacheHeader(
+          std::istream&             stream,
+          DxvkStateCacheHeader&     header) const {
+    DxvkStateCacheHeader expected;
+
+    auto data = reinterpret_cast<char*>(&header);
+    auto size = sizeof(header);
+
+    if (!stream.read(data, size))
+      return false;
+    
+    for (uint32_t i = 0; i < 4; i++) {
+      if (expected.magic[i] != header.magic[i])
+        return false;
+    }
+    
+    return true;
+  }
+
+
+  bool DxvkStateCache::readCacheEntry(
+          uint32_t                  version,
+          std::istream&             stream, 
+          DxvkStateCacheEntry&      entry) const {
+    // Read entry metadata and actual data
+    DxvkStateCacheEntryHeader header;
+    DxvkStateCacheEntryData data;
+    VkShaderStageFlags stageMask;
+    Sha1Hash hash;
+
+    if (version >= 16) {
+      if (!stream.read(reinterpret_cast<char*>(&header), sizeof(header)))
+        return false;
+
+      stageMask = VkShaderStageFlags(header.stageMask);
+    } else {
+      DxvkStateCacheEntryHeaderV8 headerV8;
+
+      if (!stream.read(reinterpret_cast<char*>(&headerV8), sizeof(headerV8)))
+        return false;
+
+      header.entryType = uint32_t(DxvkStateCacheEntryType::MonolithicPipeline);
+      header.stageMask = headerV8.stageMask & VK_SHADER_STAGE_ALL_GRAPHICS;
+      header.entrySize = headerV8.entrySize;
+
+      stageMask = VkShaderStageFlags(headerV8.stageMask);
+    }
+
+    if (!stream.read(reinterpret_cast<char*>(&hash), sizeof(hash))
+     || !data.readFromStream(stream, header.entrySize))
+      return false;
+
+    // Validate hash, skip entry if invalid
+    if (hash != data.computeHash())
+      return false;
+
+    // Set up entry metadata
+    entry.type = DxvkStateCacheEntryType(header.entryType);
+
+    // Read shader hashes
+    auto entryType = DxvkStateCacheEntryType(header.entryType);
+    data.read(entry.shaders, version, stageMask);
+
+    if (entryType == DxvkStateCacheEntryType::PipelineLibrary)
+      return true;
+
+    DxvkBindingMaskV10 dummyBindingMask = { };
+
+    if (stageMask & VK_SHADER_STAGE_COMPUTE_BIT) {
+      if (!data.read(dummyBindingMask, version))
+        return false;
+    } else {
+      // Read packed render pass format
+      if (version < 12) {
+        DxvkRenderPassFormatV11 v11;
+        data.read(v11, version);
+        entry.gpState.rt = v11.convert();
+      }
+
+      // Read common pipeline state
+      if (!data.read(dummyBindingMask, version)
+       || !data.read(entry.gpState.ia, version)
+       || !data.read(entry.gpState.il, version)
+       || !data.read(entry.gpState.rs, version)
+       || !data.read(entry.gpState.ms, version)
+       || !data.read(entry.gpState.ds, version)
+       || !data.read(entry.gpState.om, version)
+       || !data.read(entry.gpState.rt, version)
+       || !data.read(entry.gpState.dsFront, version)
+       || !data.read(entry.gpState.dsBack, version))
+        return false;
+
+      if (entry.gpState.il.attributeCount() > MaxNumVertexAttributes
+       || entry.gpState.il.bindingCount() > MaxNumVertexBindings)
+        return false;
+
+      // Read render target swizzles
+      for (uint32_t i = 0; i < MaxNumRenderTargets; i++) {
+        if (!data.read(entry.gpState.omSwizzle[i], version))
+          return false;
+      }
+
+      // Read render target blend info
+      for (uint32_t i = 0; i < MaxNumRenderTargets; i++) {
+        if (!data.read(entry.gpState.omBlend[i], version))
+          return false;
+      }
+
+      // Read defined vertex attributes
+      for (uint32_t i = 0; i < entry.gpState.il.attributeCount(); i++) {
+        if (!data.read(entry.gpState.ilAttributes[i], version))
+          return false;
+      }
+
+      // Read defined vertex bindings
+      for (uint32_t i = 0; i < entry.gpState.il.bindingCount(); i++) {
+        if (!data.read(entry.gpState.ilBindings[i], version))
+          return false;
+      }
+    }
+
+    // Read non-zero spec constants
+    uint32_t specConstantMask = 0;
+
+    if (!data.read(specConstantMask, version))
+      return false;
+
+    for (uint32_t i = 0; i < MaxNumSpecConstants; i++) {
+      if (specConstantMask & (1 << i)) {
+        if (!data.read(entry.gpState.sc.specConstants[i], version))
+          return false;
+      }
+    }
+
+    // Compute shaders are no longer supported
+    if (stageMask & VK_SHADER_STAGE_COMPUTE_BIT)
+      return false;
+
+    return true;
+  }
+
+
+  void DxvkStateCache::writeCacheEntry(
+          std::ostream&             stream, 
+          DxvkStateCacheEntry&      entry) const {
+    DxvkStateCacheEntryData data;
+    VkShaderStageFlags stageMask = 0;
+
+    // Write shader hashes
+    std::array<std::pair<VkShaderStageFlagBits, const DxvkShaderKey*>, 5> stages = {{
+      { VK_SHADER_STAGE_VERTEX_BIT,                   &entry.shaders.vs },
+      { VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,     &entry.shaders.tcs },
+      { VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,  &entry.shaders.tes },
+      { VK_SHADER_STAGE_GEOMETRY_BIT,                 &entry.shaders.gs },
+      { VK_SHADER_STAGE_FRAGMENT_BIT,                 &entry.shaders.fs },
+    }};
+
+    for (uint32_t i = 0; i < stages.size(); i++) {
+      if (!stages[i].second->eq(g_nullShaderKey)) {
+        stageMask |= stages[i].first;
+        data.write(*stages[i].second);
+      }
+    }
+
+    if (entry.type != DxvkStateCacheEntryType::PipelineLibrary) {
+      // Write out common pipeline state
+      data.write(entry.gpState.ia);
+      data.write(entry.gpState.il);
+      data.write(entry.gpState.rs);
+      data.write(entry.gpState.ms);
+      data.write(entry.gpState.ds);
+      data.write(entry.gpState.om);
+      data.write(entry.gpState.rt);
+      data.write(entry.gpState.dsFront);
+      data.write(entry.gpState.dsBack);
+
+      // Write out render target swizzles and blend info
+      for (uint32_t i = 0; i < MaxNumRenderTargets; i++)
+        data.write(entry.gpState.omSwizzle[i]);
+
+      for (uint32_t i = 0; i < MaxNumRenderTargets; i++)
+        data.write(entry.gpState.omBlend[i]);
+
+      // Write out input layout for defined attributes
+      for (uint32_t i = 0; i < entry.gpState.il.attributeCount(); i++)
+        data.write(entry.gpState.ilAttributes[i]);
+
+      for (uint32_t i = 0; i < entry.gpState.il.bindingCount(); i++)
+        data.write(entry.gpState.ilBindings[i]);
+
+      // Write out all non-zero spec constants
+      uint32_t specConstantMask = 0;
+
+      for (uint32_t i = 0; i < MaxNumSpecConstants; i++)
+        specConstantMask |= entry.gpState.sc.specConstants[i] ? (1 << i) : 0;
+
+      data.write(specConstantMask);
+
+      for (uint32_t i = 0; i < MaxNumSpecConstants; i++) {
+        if (specConstantMask & (1 << i))
+          data.write(entry.gpState.sc.specConstants[i]);
+      }
+    }
+
+    // General layout: header -> hash -> data
+    DxvkStateCacheEntryHeader header;
+    header.entryType = uint32_t(entry.type);
+    header.stageMask = uint32_t(stageMask);
+    header.entrySize = data.size();
+
+    Sha1Hash hash = data.computeHash();
+
+    stream.write(reinterpret_cast<char*>(&header), sizeof(header));
+    stream.write(reinterpret_cast<char*>(&hash), sizeof(hash));
+    stream.write(data.data(), data.size());
+    stream.flush();
+  }
+
+
+  void DxvkStateCache::workerFunc() {
+    env::setThreadName("dxvk-worker");
+
+    while (!m_stopThreads.load()) {
+      WorkerItem item;
+
+      { std::unique_lock<dxvk::mutex> lock(m_workerLock);
+
+        if (m_workerQueue.empty()) {
+          m_workerCond.wait(lock, [this] () {
+            return m_workerQueue.size()
+                || m_stopThreads.load();
+          });
+        }
+
+        if (m_workerQueue.empty())
+          break;
+        
+        item = m_workerQueue.front();
+        m_workerQueue.pop();
+      }
+
+      compilePipelines(item);
+    }
+  }
+
+
+  void DxvkStateCache::writerFunc() {
+    env::setThreadName("dxvk-writer");
+
+    std::ofstream file;
+
+    while (!m_stopThreads.load()) {
+      DxvkStateCacheEntry entry;
+
+      { std::unique_lock<dxvk::mutex> lock(m_writerLock);
+
+        m_writerCond.wait(lock, [this] () {
+          return m_writerQueue.size()
+              || m_stopThreads.load();
+        });
+
+        if (m_writerQueue.size() == 0)
+          break;
+
+        entry = m_writerQueue.front();
+        m_writerQueue.pop();
+      }
+
+      if (!file.is_open())
+        file = openCacheFileForWrite(false);
+
+      writeCacheEntry(file, entry);
+    }
+  }
+
+
+  void DxvkStateCache::createWorker() {
+    if (!m_workerThread.joinable())
+      m_workerThread = dxvk::thread([this] () { workerFunc(); });
+  }
+
+
+  void DxvkStateCache::createWriter() {
+    if (!m_writerThread.joinable())
+      m_writerThread = dxvk::thread([this] () { writerFunc(); });
+  }
+
+
+  str::path_string DxvkStateCache::getCacheFileName() const {
+    std::string path = getCacheDir();
+
+    if (!path.empty() && *path.rbegin() != '/')
+      path += '/';
+    
+    std::string exeName = env::getExeBaseName();
+    path += exeName + ".dxvk-cache";
+    return str::topath(path.c_str());
+  }
+
+
+  std::ifstream DxvkStateCache::openCacheFileForRead() const {
+    return std::ifstream(getCacheFileName().c_str(), std::ios_base::binary);
+  }
+
+
+  std::ofstream DxvkStateCache::openCacheFileForWrite(bool recreate) const {
+    std::ofstream file;
+
+    if (!recreate) {
+      // Apparently there's no other way to check whether
+      // the file is empty after creating an ofstream
+      recreate = !openCacheFileForRead();
+    }
+
+    if (recreate) {
+      file = std::ofstream(getCacheFileName().c_str(),
+        std::ios_base::binary |
+        std::ios_base::trunc);
+
+      if (!file && env::createDirectory(getCacheDir())) {
+        file = std::ofstream(getCacheFileName().c_str(),
+          std::ios_base::binary |
+          std::ios_base::trunc);
+      }
+    } else {
+      file = std::ofstream(getCacheFileName().c_str(),
+        std::ios_base::binary |
+        std::ios_base::app);
+    }
+
+    if (!file)
+      return file;
+
+    if (recreate) {
+      Logger::info("DXVK: Creating new state cache file");
+
+      // Write header with the current version number
+      DxvkStateCacheHeader header;
+
+      auto data = reinterpret_cast<const char*>(&header);
+      auto size = sizeof(header);
+
+      file.write(data, size);
+    }
+
+    return file;
+  }
+
+
+  std::string DxvkStateCache::getCacheDir() const {
+    return env::getEnvVar("DXVK_STATE_CACHE_PATH");
+  }
+
+}
diff --git a/src/dxvk/dxvk_state_cache.h b/src/dxvk/dxvk_state_cache.h
new file mode 100644
index 00000000000..0e72138ad77
--- /dev/null
+++ b/src/dxvk/dxvk_state_cache.h
@@ -0,0 +1,169 @@
+#pragma once
+
+#include <atomic>
+#include <condition_variable>
+#include <fstream>
+#include <mutex>
+#include <queue>
+#include <unordered_map>
+#include <vector>
+
+#include "dxvk_state_cache_types.h"
+
+namespace dxvk {
+
+  class DxvkDevice;
+  class DxvkPipelineManager;
+  class DxvkPipelineWorkers;
+
+  /**
+   * \brief State cache
+   * 
+   * The shader state cache stores state vectors and
+   * render pass formats of all pipelines used in a
+   * game, which allows DXVK to compile them ahead
+   * of time instead of compiling them on the first
+   * draw.
+   */
+  class DxvkStateCache {
+
+  public:
+
+    DxvkStateCache(
+            DxvkDevice*           device,
+            DxvkPipelineManager*  pipeManager,
+            DxvkPipelineWorkers*  pipeWorkers);
+
+    ~DxvkStateCache();
+
+    /**
+     * \brief Adds pipeline library to the cache
+     *
+     * If the pipeline is not already cached, this
+     * will write a new pipeline to the cache file.
+     * \param [in] shaders Shader keys
+     */
+    void addPipelineLibrary(
+      const DxvkStateCacheKey&              shaders);
+
+    /**
+     * \brief Adds a graphics pipeline to the cache
+     * 
+     * If the pipeline is not already cached, this
+     * will write a new pipeline to the cache file.
+     * \param [in] shaders Shader keys
+     * \param [in] state Graphics pipeline state
+     */
+    void addGraphicsPipeline(
+      const DxvkStateCacheKey&              shaders,
+      const DxvkGraphicsPipelineStateInfo&  state);
+
+    /**
+     * \brief Registers a newly compiled shader
+     * 
+     * Makes the shader available to the pipeline
+     * compiler, and starts compiling all pipelines
+     * for which all shaders become available.
+     * \param [in] shader The shader to add
+     */
+    void registerShader(
+      const Rc<DxvkShader>&                 shader);
+
+    /**
+     * \brief Explicitly stops worker threads
+     */
+    void stopWorkers();
+
+  private:
+
+    using WriterItem = DxvkStateCacheEntry;
+
+    struct WorkerItem {
+      DxvkGraphicsPipelineShaders gp;
+    };
+
+    DxvkDevice*                       m_device;
+    DxvkPipelineManager*              m_pipeManager;
+    DxvkPipelineWorkers*              m_pipeWorkers;
+    bool                              m_enable = false;
+
+    std::vector<DxvkStateCacheEntry>  m_entries;
+    std::atomic<bool>                 m_stopThreads = { false };
+
+    dxvk::mutex                       m_entryLock;
+
+    std::unordered_multimap<
+      DxvkStateCacheKey, size_t,
+      DxvkHash, DxvkEq> m_entryMap;
+
+    std::unordered_multimap<
+      DxvkShaderKey, DxvkStateCacheKey,
+      DxvkHash, DxvkEq> m_pipelineMap;
+    
+    std::unordered_map<
+      DxvkShaderKey, Rc<DxvkShader>,
+      DxvkHash, DxvkEq> m_shaderMap;
+
+    dxvk::mutex                       m_workerLock;
+    dxvk::condition_variable          m_workerCond;
+    std::queue<WorkerItem>            m_workerQueue;
+    dxvk::thread                      m_workerThread;
+
+    dxvk::mutex                       m_writerLock;
+    dxvk::condition_variable          m_writerCond;
+    std::queue<WriterItem>            m_writerQueue;
+    dxvk::thread                      m_writerThread;
+
+    DxvkShaderKey getShaderKey(
+      const Rc<DxvkShader>&           shader) const;
+
+    bool getShaderByKey(
+      const DxvkShaderKey&            key,
+            Rc<DxvkShader>&           shader) const;
+    
+    void mapPipelineToEntry(
+      const DxvkStateCacheKey&        key,
+            size_t                    entryId);
+    
+    void mapShaderToPipeline(
+      const DxvkShaderKey&            shader,
+      const DxvkStateCacheKey&        key);
+
+    void compilePipelines(
+      const WorkerItem&               item);
+
+    bool readCacheFile();
+
+    bool readCacheHeader(
+            std::istream&             stream,
+            DxvkStateCacheHeader&     header) const;
+
+    bool readCacheEntry(
+            uint32_t                  version,
+            std::istream&             stream, 
+            DxvkStateCacheEntry&      entry) const;
+    
+    void writeCacheEntry(
+            std::ostream&             stream, 
+            DxvkStateCacheEntry&      entry) const;
+    
+    void workerFunc();
+
+    void writerFunc();
+
+    void createWorker();
+
+    void createWriter();
+
+    str::path_string getCacheFileName() const;
+
+    std::ifstream openCacheFileForRead() const;
+
+    std::ofstream openCacheFileForWrite(
+            bool                      recreate) const;
+
+    std::string getCacheDir() const;
+
+  };
+
+}
diff --git a/src/dxvk/dxvk_state_cache_types.h b/src/dxvk/dxvk_state_cache_types.h
new file mode 100644
index 00000000000..e7ee3e597c8
--- /dev/null
+++ b/src/dxvk/dxvk_state_cache_types.h
@@ -0,0 +1,172 @@
+#pragma once
+
+#include "dxvk_compute.h"
+#include "dxvk_graphics.h"
+#include "dxvk_renderpass.h"
+
+namespace dxvk {
+
+  /**
+   * \brief State cache entry key
+   * 
+   * Stores the shader keys for all
+   * graphics shader stages. Used to
+   * look up cached state entries.
+   */
+  struct DxvkStateCacheKey {
+    DxvkShaderKey vs;
+    DxvkShaderKey tcs;
+    DxvkShaderKey tes;
+    DxvkShaderKey gs;
+    DxvkShaderKey fs;
+
+    bool eq(const DxvkStateCacheKey& key) const;
+
+    size_t hash() const;
+  };
+
+
+  /**
+   * \brief State entry type
+   */
+  enum class DxvkStateCacheEntryType : uint32_t {
+    MonolithicPipeline  = 0,
+    PipelineLibrary     = 1,
+  };
+
+  
+  /**
+   * \brief State entry
+   * 
+   * Stores the shaders used in a pipeline, as well
+   * as the full state vector, including its render
+   * pass format. This also includes a SHA-1 hash
+   * that is used as a check sum to verify integrity.
+   */
+  struct DxvkStateCacheEntry {
+    DxvkStateCacheEntryType       type;
+    DxvkStateCacheKey             shaders;
+    DxvkGraphicsPipelineStateInfo gpState;
+    Sha1Hash                      hash;
+  };
+
+
+  /**
+   * \brief State cache header
+   * 
+   * Stores the state cache format version. If an
+   * existing cache file is incompatible to the
+   * current version, it will be discarded.
+   */
+  struct DxvkStateCacheHeader {
+    char     magic[4]   = { 'D', 'X', 'V', 'K' };
+    uint32_t version    = 18;
+    uint32_t entrySize  = 0; /* no longer meaningful */
+  };
+
+  static_assert(sizeof(DxvkStateCacheHeader) == 12);
+
+  using DxvkBindingMaskV10 = DxvkBindingSet<384>;
+  using DxvkBindingMaskV8 = DxvkBindingSet<128>;
+
+  class DxvkIlBindingV9 {
+
+  public:
+
+    uint32_t m_binding                : 5;
+    uint32_t m_stride                 : 12;
+    uint32_t m_inputRate              : 1;
+    uint32_t m_reserved               : 14;
+    uint32_t m_divisor;
+
+    DxvkIlBinding convert() const {
+      return DxvkIlBinding(m_binding, m_stride,
+        VkVertexInputRate(m_inputRate), m_divisor);
+    }
+
+  };
+
+  /**
+   * \brief Old attachment format struct
+   */
+  struct DxvkAttachmentFormatV11 {
+    VkFormat      format = VK_FORMAT_UNDEFINED;
+    VkImageLayout layout = VK_IMAGE_LAYOUT_UNDEFINED;
+  };
+  
+  
+  /**
+   * \brief Old render pass format struct
+   */
+  struct DxvkRenderPassFormatV11 {
+    VkSampleCountFlagBits sampleCount;
+    DxvkAttachmentFormatV11 depth;
+    DxvkAttachmentFormatV11 color[MaxNumRenderTargets];
+
+    DxvkRtInfo convert() const {
+      VkImageAspectFlags readOnlyAspects = 0;
+      auto depthFormatInfo = lookupFormatInfo(depth.format);
+
+      if (depth.format && depthFormatInfo) {
+        readOnlyAspects = depthFormatInfo->aspectMask
+          & ~vk::getWritableAspectsForLayout(depth.layout);
+      }
+
+      std::array<VkFormat, MaxNumRenderTargets> colorFormats;
+      for (uint32_t i = 0; i < MaxNumRenderTargets; i++)
+        colorFormats[i] = color[i].format;
+
+      return DxvkRtInfo(MaxNumRenderTargets, colorFormats.data(),
+        depth.format, readOnlyAspects);
+    }
+  };
+
+  class DxvkRsInfoV12 {
+
+  public:
+
+    uint32_t m_depthClipEnable        : 1;
+    uint32_t m_polygonMode            : 2;
+    uint32_t m_cullMode               : 2;
+    uint32_t m_frontFace              : 1;
+    uint32_t m_viewportCount          : 5;
+    uint32_t m_sampleCount            : 5;
+    uint32_t m_conservativeMode       : 2;
+    uint32_t m_reserved               : 13;
+
+    DxvkRsInfo convert() const {
+      return DxvkRsInfo(
+        VkBool32(m_depthClipEnable),
+        VkPolygonMode(m_polygonMode),
+        VkSampleCountFlags(m_sampleCount),
+        VkConservativeRasterizationModeEXT(m_conservativeMode),
+        VK_FALSE, VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT);
+    }
+
+  };
+
+
+  class DxvkRsInfoV13 {
+
+  public:
+
+    uint16_t m_depthClipEnable        : 1;
+    uint16_t m_polygonMode            : 2;
+    uint16_t m_cullMode               : 2;
+    uint16_t m_frontFace              : 1;
+    uint16_t m_sampleCount            : 5;
+    uint16_t m_conservativeMode       : 2;
+    uint16_t m_reserved               : 2;
+
+    DxvkRsInfo convert() const {
+      return DxvkRsInfo(
+        VkBool32(m_depthClipEnable),
+        VkPolygonMode(m_polygonMode),
+        VkSampleCountFlags(m_sampleCount),
+        VkConservativeRasterizationModeEXT(m_conservativeMode),
+        VK_FALSE, VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT);
+    }
+
+  };
+
+}

From 50aea4d300a348f76a634b3b4e0213ba41799126 Mon Sep 17 00:00:00 2001
From: Laitinlok <adrianlai2000@hotmail.com>
Date: Sun, 3 Aug 2025 05:05:28 +0800
Subject: [PATCH 71/81] Support state cache in dxvk 2.7

---
 src/dxvk/dxvk_graphics.cpp | 11 +++++++++--
 src/dxvk/dxvk_graphics.h   |  2 ++
 src/dxvk/dxvk_options.cpp  | 10 ++++++++++
 src/dxvk/dxvk_options.h    |  3 +++
 4 files changed, 24 insertions(+), 2 deletions(-)

diff --git a/src/dxvk/dxvk_graphics.cpp b/src/dxvk/dxvk_graphics.cpp
index 760a0889674..277928af698 100644
--- a/src/dxvk/dxvk_graphics.cpp
+++ b/src/dxvk/dxvk_graphics.cpp
@@ -1012,6 +1012,7 @@ namespace dxvk {
     m_vsIn  = m_shaders.vs != nullptr ? m_shaders.vs->info().inputMask  : 0;
     m_fsOut = m_shaders.fs != nullptr ? m_shaders.fs->info().outputMask : 0;
     m_specConstantMask = this->computeSpecConstantMask();
+    gplAsyncCache = m_device->config().gplAsyncCache;
 
     if (m_shaders.gs != nullptr) {
       if (m_shaders.gs->flags().test(DxvkShaderFlag::HasTransformFeedback)) {
@@ -1127,7 +1128,7 @@ namespace dxvk {
 
       // Do not compile if this pipeline can be fast linked. This essentially
       // disables the state cache for pipelines that do not benefit from it.
-      if (!m_async.load(std::memory_order_acquire) && this->canCreateBasePipeline(state))
+      if (!gplAsyncCache && !m_async.load(std::memory_order_acquire) && this->canCreateBasePipeline(state))
         return;
 
       // Prevent other threads from adding new instances and check again
@@ -1148,8 +1149,14 @@ namespace dxvk {
     instance->fastHandle.store(pipeline, std::memory_order_release);
 
     // Log pipeline state on error
-    if (!pipeline)
+    if (!pipeline) {
       this->logPipelineState(LogLevel::Error, state);
+      return;
+    }
+    
+     //Write pipeline to state cache
+     if (gplAsyncCache)
+       this->writePipelineStateToCache(state);
   }
 
 
diff --git a/src/dxvk/dxvk_graphics.h b/src/dxvk/dxvk_graphics.h
index 0593e355358..dfbfbbaf3e1 100644
--- a/src/dxvk/dxvk_graphics.h
+++ b/src/dxvk/dxvk_graphics.h
@@ -625,6 +625,8 @@ namespace dxvk {
     dxvk::mutex                                   m_asyncMutex;
 
     std::atomic<bool>                             m_async{false};
+    
+    bool                                          gplAsyncCache;
 
     sync::List<DxvkGraphicsPipelineInstance>      m_pipelines;
     uint32_t                                      m_useCount = 0;
diff --git a/src/dxvk/dxvk_options.cpp b/src/dxvk/dxvk_options.cpp
index f5a611fd7bb..8262aa62531 100644
--- a/src/dxvk/dxvk_options.cpp
+++ b/src/dxvk/dxvk_options.cpp
@@ -3,6 +3,16 @@
 namespace dxvk {
 
   DxvkOptions::DxvkOptions(const Config& config) {
+     if (env::getEnvVar("DXVK_GPLASYNCCACHE") == "0")
+       gplAsyncCache = false;
+     else
+       gplAsyncCache = config.getOption<bool>("dxvk.gplAsyncCache", true);
+     
+     if (env::getEnvVar("DXVK_ASYNC") == "0")
+       enableAsync = false;
+     else
+       enableAsync = config.getOption<bool>("dxvk.enableAsync", true);
+
     enableAsync           = config.getOption<bool>    ("dxvk.enableAsync",            true);
     enableDebugUtils      = config.getOption<bool>    ("dxvk.enableDebugUtils",       false);
     enableStateCache      = config.getOption<bool>    ("dxvk.enableStateCache",       true);
diff --git a/src/dxvk/dxvk_options.h b/src/dxvk/dxvk_options.h
index e9e554f6ca3..df3489743f3 100644
--- a/src/dxvk/dxvk_options.h
+++ b/src/dxvk/dxvk_options.h
@@ -34,6 +34,9 @@ namespace dxvk {
 
     /// Enable async pipelines
     bool enableAsync = true;
+    
+    // Enable state cache with gpl and fixes for async
+    bool gplAsyncCache;
 
     /// Shader-related options
     Tristate useRawSsbo = Tristate::Auto;

From 9f8e63622a4ad2e2e412ee347804194dff31c21c Mon Sep 17 00:00:00 2001
From: Laitinlok <adrianlai2000@hotmail.com>
Date: Sun, 3 Aug 2025 05:09:55 +0800
Subject: [PATCH 72/81] Support state cache in dxvk 2.7

---
 src/dxvk/dxvk_options.cpp | 10 ----------
 1 file changed, 10 deletions(-)

diff --git a/src/dxvk/dxvk_options.cpp b/src/dxvk/dxvk_options.cpp
index 8262aa62531..f5a611fd7bb 100644
--- a/src/dxvk/dxvk_options.cpp
+++ b/src/dxvk/dxvk_options.cpp
@@ -3,16 +3,6 @@
 namespace dxvk {
 
   DxvkOptions::DxvkOptions(const Config& config) {
-     if (env::getEnvVar("DXVK_GPLASYNCCACHE") == "0")
-       gplAsyncCache = false;
-     else
-       gplAsyncCache = config.getOption<bool>("dxvk.gplAsyncCache", true);
-     
-     if (env::getEnvVar("DXVK_ASYNC") == "0")
-       enableAsync = false;
-     else
-       enableAsync = config.getOption<bool>("dxvk.enableAsync", true);
-
     enableAsync           = config.getOption<bool>    ("dxvk.enableAsync",            true);
     enableDebugUtils      = config.getOption<bool>    ("dxvk.enableDebugUtils",       false);
     enableStateCache      = config.getOption<bool>    ("dxvk.enableStateCache",       true);

From 7a5b20fd9e55181f6f09521635a0428585ec58fa Mon Sep 17 00:00:00 2001
From: Laitinlok <adrianlai2000@hotmail.com>
Date: Sun, 3 Aug 2025 05:18:45 +0800
Subject: [PATCH 73/81] Support state cache in dxvk 2.7

---
 src/dxvk/dxvk_options.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/dxvk/dxvk_options.cpp b/src/dxvk/dxvk_options.cpp
index f5a611fd7bb..2a5e3964711 100644
--- a/src/dxvk/dxvk_options.cpp
+++ b/src/dxvk/dxvk_options.cpp
@@ -3,6 +3,7 @@
 namespace dxvk {
 
   DxvkOptions::DxvkOptions(const Config& config) {
+    gplAsyncCache         = config.getOption<bool>    ("dxvk.gplAsyncCache",          true);
     enableAsync           = config.getOption<bool>    ("dxvk.enableAsync",            true);
     enableDebugUtils      = config.getOption<bool>    ("dxvk.enableDebugUtils",       false);
     enableStateCache      = config.getOption<bool>    ("dxvk.enableStateCache",       true);

From 005988de36a3f8b5329fbdbf9ef3e98cdb41a1aa Mon Sep 17 00:00:00 2001
From: Laitinlok <63400461+Laitinlok@users.noreply.github.com>
Date: Sun, 3 Aug 2025 23:04:54 +0800
Subject: [PATCH 74/81] Update dxvk_options.cpp

---
 src/dxvk/dxvk_options.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_options.cpp b/src/dxvk/dxvk_options.cpp
index 2a5e3964711..2a7b88ac4fb 100644
--- a/src/dxvk/dxvk_options.cpp
+++ b/src/dxvk/dxvk_options.cpp
@@ -3,7 +3,10 @@
 namespace dxvk {
 
   DxvkOptions::DxvkOptions(const Config& config) {
-    gplAsyncCache         = config.getOption<bool>    ("dxvk.gplAsyncCache",          true);
+    if (env::getEnvVar("DXVK_GPLASYNCCACHE") == "0")
+      gplAsyncCache = false;
+    else
+      gplAsyncCache = config.getOption<bool>("dxvk.gplAsyncCache", true);
     enableAsync           = config.getOption<bool>    ("dxvk.enableAsync",            true);
     enableDebugUtils      = config.getOption<bool>    ("dxvk.enableDebugUtils",       false);
     enableStateCache      = config.getOption<bool>    ("dxvk.enableStateCache",       true);

From 221358f0e5d4db87d31efec98552a66df722991f Mon Sep 17 00:00:00 2001
From: Laitinlok <63400461+Laitinlok@users.noreply.github.com>
Date: Sun, 3 Aug 2025 23:33:19 +0800
Subject: [PATCH 75/81] Update dxvk_options.cpp

---
 src/dxvk/dxvk_options.cpp | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/src/dxvk/dxvk_options.cpp b/src/dxvk/dxvk_options.cpp
index 2a7b88ac4fb..74cd6202682 100644
--- a/src/dxvk/dxvk_options.cpp
+++ b/src/dxvk/dxvk_options.cpp
@@ -3,10 +3,7 @@
 namespace dxvk {
 
   DxvkOptions::DxvkOptions(const Config& config) {
-    if (env::getEnvVar("DXVK_GPLASYNCCACHE") == "0")
-      gplAsyncCache = false;
-    else
-      gplAsyncCache = config.getOption<bool>("dxvk.gplAsyncCache", true);
+    gplAsyncCache = config.getOption<bool>("dxvk.gplAsyncCache", true);
     enableAsync           = config.getOption<bool>    ("dxvk.enableAsync",            true);
     enableDebugUtils      = config.getOption<bool>    ("dxvk.enableDebugUtils",       false);
     enableStateCache      = config.getOption<bool>    ("dxvk.enableStateCache",       true);

From f9437fbc2dc058d33cd3a2dfc5de9752937c21f9 Mon Sep 17 00:00:00 2001
From: Laitinlok <63400461+Laitinlok@users.noreply.github.com>
Date: Sun, 3 Aug 2025 23:37:12 +0800
Subject: [PATCH 76/81] Update dxvk_graphics.cpp

---
 src/dxvk/dxvk_graphics.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_graphics.cpp b/src/dxvk/dxvk_graphics.cpp
index 277928af698..6579d07e937 100644
--- a/src/dxvk/dxvk_graphics.cpp
+++ b/src/dxvk/dxvk_graphics.cpp
@@ -1012,7 +1012,7 @@ namespace dxvk {
     m_vsIn  = m_shaders.vs != nullptr ? m_shaders.vs->info().inputMask  : 0;
     m_fsOut = m_shaders.fs != nullptr ? m_shaders.fs->info().outputMask : 0;
     m_specConstantMask = this->computeSpecConstantMask();
-    gplAsyncCache = m_device->config().gplAsyncCache;
+    const bool gplAsyncCache = m_device->config().gplAsyncCache && env::getEnvVar("DXVK_GPLASYNCCACHE") != "0";
 
     if (m_shaders.gs != nullptr) {
       if (m_shaders.gs->flags().test(DxvkShaderFlag::HasTransformFeedback)) {

From 251b428184b9615d1e60d837683695311b5988c8 Mon Sep 17 00:00:00 2001
From: Laitinlok <63400461+Laitinlok@users.noreply.github.com>
Date: Sun, 3 Aug 2025 23:43:46 +0800
Subject: [PATCH 77/81] Update dxvk_graphics.cpp

---
 src/dxvk/dxvk_graphics.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_graphics.cpp b/src/dxvk/dxvk_graphics.cpp
index 6579d07e937..9f37e2cf4bf 100644
--- a/src/dxvk/dxvk_graphics.cpp
+++ b/src/dxvk/dxvk_graphics.cpp
@@ -1012,7 +1012,7 @@ namespace dxvk {
     m_vsIn  = m_shaders.vs != nullptr ? m_shaders.vs->info().inputMask  : 0;
     m_fsOut = m_shaders.fs != nullptr ? m_shaders.fs->info().outputMask : 0;
     m_specConstantMask = this->computeSpecConstantMask();
-    const bool gplAsyncCache = m_device->config().gplAsyncCache && env::getEnvVar("DXVK_GPLASYNCCACHE") != "0";
+    bool gplAsyncCache = m_device->config().gplAsyncCache && env::getEnvVar("DXVK_GPLASYNCCACHE") != "0";
 
     if (m_shaders.gs != nullptr) {
       if (m_shaders.gs->flags().test(DxvkShaderFlag::HasTransformFeedback)) {

From bd0b883fd85ab6da2207192991a0d9dc94a75299 Mon Sep 17 00:00:00 2001
From: Laitinlok <63400461+Laitinlok@users.noreply.github.com>
Date: Mon, 4 Aug 2025 00:23:32 +0800
Subject: [PATCH 78/81] Update dxvk_graphics.cpp

---
 src/dxvk/dxvk_graphics.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/dxvk/dxvk_graphics.cpp b/src/dxvk/dxvk_graphics.cpp
index 9f37e2cf4bf..a0428df8502 100644
--- a/src/dxvk/dxvk_graphics.cpp
+++ b/src/dxvk/dxvk_graphics.cpp
@@ -1012,7 +1012,7 @@ namespace dxvk {
     m_vsIn  = m_shaders.vs != nullptr ? m_shaders.vs->info().inputMask  : 0;
     m_fsOut = m_shaders.fs != nullptr ? m_shaders.fs->info().outputMask : 0;
     m_specConstantMask = this->computeSpecConstantMask();
-    bool gplAsyncCache = m_device->config().gplAsyncCache && env::getEnvVar("DXVK_GPLASYNCCACHE") != "0";
+    gplAsyncCache = m_device->config().gplAsyncCache && env::getEnvVar("DXVK_GPLASYNCCACHE") != "0";
 
     if (m_shaders.gs != nullptr) {
       if (m_shaders.gs->flags().test(DxvkShaderFlag::HasTransformFeedback)) {

From 9926041cd7663371bff1d7f91803a06d51e9053a Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Tue, 5 Aug 2025 03:54:23 +0200
Subject: [PATCH 79/81] [dxvk] Return dxvk.gplAsyncCache config option

---
 dxvk.conf | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dxvk.conf b/dxvk.conf
index b78dd1d4916..2fcd90c4d43 100644
--- a/dxvk.conf
+++ b/dxvk.conf
@@ -17,6 +17,7 @@
 # Example (Linux): DXVK_CONFIG_FILE=$XDG_DATA_HOME/dxvk.conf
 # Example (MacOS): DXVK_CONFIG_FILE=$HOME/Library/dxvk.conf
 
+
 # Device filter. Only exposes devices whose Vulkan device name contains
 # the given string. May be useful to force an application to run on a
 # specific GPU, but not applications launched by that application.
@@ -54,6 +55,21 @@
 # dxvk.enableAsync = True
 
 
+# This option enables or disables fixes for DXVK state cache that allow 
+# to use both Async and GPL together or separately.
+# For Async it is always useful.
+# For GPL it can be useful depending on game. 
+# 
+# Default: True
+# Supported values: True, False
+# 
+# DXVK_GPLASYNCCACHE environment variable provides control for this option too.
+# DXVK_GPLASYNCCACHE=1 is equivalent to dxvk.gplAsyncCache = True
+# DXVK_GPLASYNCCACHE=0 is equivalent to dxvk.gplAsyncCache = False
+
+# dxvk.gplAsyncCache = True
+
+
 # Frame pacing mode managing CPU-GPU synchronization.
 #
 # "max-frame-latency" provides stable latency in the GPU-limit as long as GPU render times are stable. 

From 2e29e4c6608cd41e51c21d7c750b4c6012151acd Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Tue, 5 Aug 2025 03:57:55 +0200
Subject: [PATCH 80/81] Update README.md to DXVK-GPLALL 2.7-3

---
 README.md | 28 ++++++++++++++++------------
 1 file changed, 16 insertions(+), 12 deletions(-)

diff --git a/README.md b/README.md
index fe6ef6fabb4..757fa48f31d 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 # DXVK GPLAsync-LowLatency (DXVK-GPLALL)
 
-A Vulkan-based translation layer for Direct3D 8/9/10/11 which allows running 3D applications on: 
+A Vulkan 1.3-based translation layer for Direct3D 8/9/10/11 which allows running 3D applications on: 
 
 1. Windows 10/11, if GPU has Vulkan driver that is Vulkan 1.3 compliant. Requires SSE2 CPU.
 2. Linux using Wine, if GPU has Vulkan driver that is Vulkan 1.3 compliant. Requires SSE2 CPU.
@@ -13,8 +13,9 @@ For GPUs that do not have Vulkan 1.3 compliant driver, it is recommended to use
 1. Implemented Low Latency frame pacing mode that aims to greatly reduce latency with minimal impact in fps. Author - [netborg-afps](https://github.com/netborg-afps/dxvk/releases)
 2. Implemented Asynchronous pipeline compilation (Async) that aims to greatly reduce shader compilation stutter by not blocking the main thread when compiling async pipelines. Authors - [jomihaka](https://github.com/jomihaka/dxvk-poe-hack) and [Sporif](https://github.com/Sporif/dxvk-async)
 3. Implemented the ability to use both (together or separately) Graphics Pipeline Library (GPL) and Asynchronous pipeline compilation (Async) on DXVK 2.1 and later. Author - [Ph42oN](https://gitlab.com/Ph42oN/dxvk-gplasync/). Contributor - [Britt Yazel](https://gitlab.com/Ph42oN/dxvk-gplasync/-/merge_requests/12)
-4. Implemented all of aforementioned in one DXVK package. Author - [Digger1955](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases)
-5. Provided various GCC (for any OS) builds of DXVK-GPLALL:
+4. Implemented State Cache for DXVK 2.7 starting from DXVK-GPLALL 2.7-3. Author - [Laitinlok](https://github.com/Digger1955/dxvk-gplasync-lowlatency/pull/29)
+5. Implemented all of aforementioned in one DXVK package. Author - [Digger1955](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases)
+6. Provided various GCC (for any OS) builds of DXVK-GPLALL:
 
    a) optimized for `SSE2` (`-march=x86-64, -mtune=x86-64`) CPUs with Link-Time Optimization (`LTO`, a.k.a. `-flto=auto`) and `-O3` optimization level;
 
@@ -24,7 +25,7 @@ For GPUs that do not have Vulkan 1.3 compliant driver, it is recommended to use
 
 Author - [Digger1955](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases)
 
-6. Provided various MSVC (only for Windows, requires [MSVCRT](https://www.techpowerup.com/download/visual-c-redistributable-runtime-package-all-in-one/)) builds of DXVK-GPLALL:
+7. Provided various MSVC (requires [MSVCRT](https://www.techpowerup.com/download/visual-c-redistributable-runtime-package-all-in-one/)) builds of DXVK-GPLALL:
 
    a) optimized for `SSE2` (`/arch:SSE2`) CPUs with Link-Time Optimization (`LTO`, a.k.a. `/LTCG`) and `/O2` optimization level;
 
@@ -34,16 +35,18 @@ Author - [Digger1955](https://github.com/Digger1955/dxvk-gplasync-lowlatency/rel
 
 Author - [Digger1955](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases)
 
-7. Maintaining DXVK 2.6.x branch for GPUs/drivers that do not meet [DXVK 2.7 requirements](https://github.com/doitsujin/dxvk/releases/tag/v2.7). Author - [Digger1955](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases)
+8. Maintaining DXVK 2.6.x branch for GPUs/drivers that do not meet [DXVK 2.7 requirements](https://github.com/doitsujin/dxvk/releases/tag/v2.7). Author - [Digger1955](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases)
 
 Detailed Changelog provided in [Wiki](https://github.com/Digger1955/dxvk-gplasync-lowlatency/wiki/Detailed-Changelog).
 
 Builds Reference Guide provided in [Wiki](https://github.com/Digger1955/dxvk-gplasync-lowlatency/wiki/Builds-Reference-Guide).
 
+Contributing Guidelines provided in [Wiki](https://github.com/Digger1955/dxvk-gplasync-lowlatency/wiki/Contributing-Guidelines).
+
 ## How to use (Windows 10/11)
 
 1. Download DXVK package from [release](https://github.com/Digger1955/dxvk-gplasync-lowlatency/releases) page.
-2. Copy appropriate [DLL dependencies](https://github.com/Digger1955/dxvk-gplasync-lowlatency/blob/test/README.md#dll-dependencies) to the location of application's main executable folder.
+2. Copy appropriate [DLL dependencies](https://github.com/Digger1955/dxvk-gplasync-lowlatency/tree/GPLALL-master-2.7?tab=readme-ov-file#dll-dependencies) to the location of application's main executable folder.
 3. Run application.
 
 **Important**: It is **STRONGLY RECOMMENDED** to create `dxvk.conf` at application's main executable folder (per-application configuration file - first priority) or at `%APPDATA%/dxvk.conf` (one global configuration file - second priority) with your desired DXVK settings.
@@ -128,7 +131,8 @@ The `DXVK_HUD` environment variable controls a HUD which can display the framera
 - `scale=x`: Scales the HUD by a factor of `x` (e.g. `1.5`)
 - `opacity=y`: Adjusts the HUD opacity by a factor of `y` (e.g. `0.5`, `1.0` being fully opaque).
 - `renderlatency`: Start of frame (usually when the game starts processing input) until the GPU did finish rendering this frame. Note that this will not work when a game's fps limiter is enabled, as there is no way to detect when a game will stall processing before reading input. Average over 100 frames.
-- `presentlatency`: time it takes to present the finished image to the screen. Relies on the driver implementation of `vkWaitForPresentKHR`, which may or may not be accurate. `VK_PRESENT_MODE_MAILBOX_KHR` is currently not supported, because it needs special treatment. Average over 100 frames.
+- `presentlatency`: Time it takes to present the finished image to the screen. Relies on the driver implementation of `vkWaitForPresentKHR`, which may or may not be accurate. `VK_PRESENT_MODE_MAILBOX_KHR` is currently not supported, because it needs special treatment. Average over 100 frames.
+- `latencydetails`: Enables the user to fine tune his system, settings, etc. according to the values presented in the HUD for a specific game.
 
 Additionally, `DXVK_HUD=1` has the same effect as `DXVK_HUD=devinfo,fps`, and `DXVK_HUD=full` enables all available HUD elements.
 
@@ -175,8 +179,8 @@ In games that load their shaders during loading screens or in the menu, this can
 
 **IMPORTANT**: Disabled by default since DXVK-GPLALL 2.6.1-4. Reasons have been specified in [Wiki](https://github.com/Digger1955/dxvk-gplasync-lowlatency/wiki/dxvk.conf-Options-Guide#dxvkenablegraphicspipelinelibrary)
 
-## State cache (DXVK-GPLALL 2.6.x only)
-DXVK-GPLALL up to version 2.6.x caches pipeline state by default, so that shaders can be recompiled ahead of time on subsequent runs of an application, even if the driver's own shader cache got invalidated in the meantime. This cache is enabled by default, and generally reduces stuttering.
+## State cache
+DXVK-GPLALL caches pipeline state by default, so that shaders can be recompiled ahead of time on subsequent runs of an application, even if the driver's own shader cache got invalidated in the meantime. This cache is enabled by default, and generally reduces stuttering.
 
 State cache can be used together with GPL that is not possible on upstream DXVK, but it can be useful depending on game.
 
@@ -186,7 +190,7 @@ The following environment variables can be used to control the cache:
   - `reset`: Clears the cache file.
 - `DXVK_STATE_CACHE_PATH=/some/directory` Specifies a directory where to put the cache files. Defaults to the current working directory of the application.
 
-**Important**: The state cache has been removed from the [upstream DXVK since version 2.7](https://github.com/doitsujin/dxvk/releases/tag/v2.7), and is therefore not available in DXVK-GPLALL 2.7 and later.
+**Important**: The state cache has been removed from the [upstream DXVK since version 2.7](https://github.com/doitsujin/dxvk/releases/tag/v2.7). It is not available in DXVK-GPLALL 2.7-1 and 2.7-2, but available in DXVK-GPLALL 2.7-3 and later.
 
 ## Asynchronous pipeline compilation (Async)
 
@@ -198,13 +202,13 @@ Asynchronous pipeline compilation is enabled with `DXVK_ASYNC=1` environment var
 
 Asynchronous pipeline compilation is disabled with `DXVK_ASYNC=0` environment variable and is equivalent to `dxvk.enableAsync = False` in `dxvk.conf`.
 
-## GPLAsync and State cache (DXVK-GPLALL 2.6.x only)
+## GPLAsync and State cache
 
 State cache fixes for GPL and Async are enabled with `DXVK_GPLASYNCCACHE=1` environment variable and is equivalent to `dxvk.gplAsyncCache = True` in `dxvk.conf`. It is enabled by default.
 
 State cache fixes for GPL and Async are disabled with `DXVK_GPLASYNCCACHE=0` environment variable and is equivalent to `dxvk.gplAsyncCache = False` in `dxvk.conf`.
 
-**Important**: The state cache has been removed from the [upstream DXVK since version 2.7](https://github.com/doitsujin/dxvk/releases/tag/v2.7), and is therefore not available in DXVK-GPLALL 2.7 and later.
+**Important**: The state cache has been removed from the [upstream DXVK since version 2.7](https://github.com/doitsujin/dxvk/releases/tag/v2.7). It is not available in DXVK-GPLALL 2.7-1 and 2.7-2, but available in DXVK-GPLALL 2.7-3 and later.
 
 ## Low Latency frame pacing
 

From 7be66a1893fa3e9b45280b5a6db7d0cd8dd72c66 Mon Sep 17 00:00:00 2001
From: Digger1955 <205152346+Digger1955@users.noreply.github.com>
Date: Tue, 5 Aug 2025 04:04:08 +0200
Subject: [PATCH 81/81] [release] DXVK-GPLAsync-LowLatency 2.7-3 (DXVK-GPLALL
 2.7-3)

DXVK-GPLAsync-LowLatency 2.7-3 (DXVK-GPLALL 2.7-3)

Detailed Changelog provided in [Wiki](https://github.com/Digger1955/dxvk-gplasync-lowlatency/wiki/Detailed-Changelog#dxvk-gplasync-lowlatency-27-3-dxvk-gplall-27-3).
---
 RELEASE | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/RELEASE b/RELEASE
index 39bf9228d50..e22b85759a1 100644
--- a/RELEASE
+++ b/RELEASE
@@ -1 +1 @@
-2.7-2
+2.7-3
