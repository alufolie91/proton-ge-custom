diff --git a/src/d3d11/d3d11_context.h b/src/d3d11/d3d11_context.h
index c659337..14e2fff 100644
--- a/src/d3d11/d3d11_context.h
+++ b/src/d3d11/d3d11_context.h
@@ -81,7 +81,7 @@ namespace dxvk {
     constexpr static Tristate DebugLazyBinding = Tristate::Auto;
 
   public:
-    
+
     D3D11CommonContext(
             D3D11Device*            pParent,
       const Rc<DxvkDevice>&         Device,
@@ -97,7 +97,7 @@ namespace dxvk {
     D3D11_DEVICE_CONTEXT_TYPE STDMETHODCALLTYPE GetType();
 
     UINT STDMETHODCALLTYPE GetContextFlags();
-    
+
     void STDMETHODCALLTYPE ClearState();
 
     void STDMETHODCALLTYPE DiscardResource(ID3D11Resource *pResource);
@@ -802,7 +802,7 @@ namespace dxvk {
     DxvkLocalAllocationCache    m_allocationCache;
 
     DxvkCsChunkRef AllocCsChunk();
-    
+
     DxvkBufferSlice AllocStagingBuffer(
             VkDeviceSize                      Size);
 
@@ -831,19 +831,19 @@ namespace dxvk {
     void ApplyDirtyComputeBindings();
 
     void ApplyInputLayout();
-    
+
     void ApplyPrimitiveTopology();
-    
+
     void ApplyBlendState();
-    
+
     void ApplyBlendFactor();
-    
+
     void ApplyDepthStencilState();
-    
+
     void ApplyStencilRef();
-    
+
     void ApplyRasterizerState();
-    
+
     void ApplyRasterizerSampleCount();
 
     void ApplyViewportState();
@@ -1055,10 +1055,10 @@ namespace dxvk {
             D3D11RenderTargetView*            pView);
 
     void RestoreCommandListState();
-    
+
     void RestoreConstantBuffers(
             DxbcProgramType                   Stage);
-    
+
     void RestoreSamplers(
             DxbcProgramType                   Stage);
 
@@ -1179,7 +1179,7 @@ namespace dxvk {
     static DxvkBlendMode InitDefaultBlendState();
 
     template<bool AllowFlush = true, typename Cmd>
-    void EmitCs(Cmd&& command) {
+    void EmitCs(Cmd&& command, bool disableFlush=false ) {
       if (unlikely(m_csDataType != D3D11CmdType::None)) {
         m_csData = nullptr;
         m_csDataType = D3D11CmdType::None;
@@ -1190,7 +1190,8 @@ namespace dxvk {
         m_csChunk = AllocCsChunk();
 
         if constexpr (!IsDeferred && AllowFlush)
-          GetTypedContext()->ConsiderFlush(GpuFlushType::ImplicitWeakHint);
+                if (!disableFlush)
+                        GetTypedContext()->ConsiderFlush(GpuFlushType::ImplicitWeakHint);
 
         m_csChunk->push(command);
       }
@@ -1257,5 +1258,5 @@ namespace dxvk {
     }
 
   };
-  
+
 }
diff --git a/src/dxvk/hud/dxvk_hud_item.cpp b/src/dxvk/hud/dxvk_hud_item.cpp
index 4bc85e6..927cf77 100644
--- a/src/dxvk/hud/dxvk_hud_item.cpp
+++ b/src/dxvk/hud/dxvk_hud_item.cpp
@@ -213,117 +213,6 @@ namespace dxvk::hud {
   }
 
 
-  HudRenderLatencyItem::HudRenderLatencyItem() { }
-  HudRenderLatencyItem::~HudRenderLatencyItem() { }
-
-  void HudRenderLatencyItem::update(dxvk::high_resolution_clock::time_point time) {
-    const Rc<DxvkLatencyTracker> tracker = m_tracker;
-    const FramePacer* framePacer = dynamic_cast<FramePacer*>( tracker.ptr() );
-    if (!framePacer)
-      return;
-
-    auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(time - m_lastUpdate);
-
-    if (elapsed.count() >= UpdateInterval) {
-      m_lastUpdate = time;
-
-      LatencyMarkersReader reader = framePacer->m_latencyMarkersStorage.getReader(100);
-      const LatencyMarkers* markers;
-      uint32_t count = 0;
-      uint64_t totalLatency = 0;
-      while (reader.getNext(markers)) {
-        totalLatency += markers->gpuFinished;
-        ++count;
-      }
-
-      if (!count)
-        return;
-
-      uint64_t latency = totalLatency / count;
-      m_latency = str::format(latency / 1000, ".", (latency/100) % 10, " ms");
-    }
-  }
-
-
-  HudPos HudRenderLatencyItem::render(
-    const DxvkContextObjects& ctx,
-    const HudPipelineKey&     key,
-    const HudOptions&         options,
-          HudRenderer&        renderer,
-          HudPos              position) {
-
-    position.y += 12;
-    renderer.drawText(16, position, 0xff4040ffu, "Render latency:");
-    renderer.drawText(16, { position.x + 195, position.y },
-      0xffffffffu, m_latency);
-
-    position.y += 8;
-    return position;
-  }
-
-
-  HudPresentLatencyItem::HudPresentLatencyItem() { }
-  HudPresentLatencyItem::~HudPresentLatencyItem() { }
-
-  void HudPresentLatencyItem::update(dxvk::high_resolution_clock::time_point time) {
-    // we cannot measure latency when fps-limiting is performed in Presenter::runFrameThread()
-    // because it's interfering with getting the right timestamp from vkWaitForPresent()
-    // if we truely wanted to measure it, we would need one additional thread
-    if (FpsLimiter::m_isActive) {
-      m_latency = "N/A";
-      return;
-    }
-
-    const Rc<DxvkLatencyTracker> tracker = m_tracker;
-    FramePacer* framePacer = dynamic_cast<FramePacer*>( tracker.ptr() );
-    if (!framePacer)
-      return;
-
-    if (framePacer->getFramePacerMode()->getPresentMode() == VK_PRESENT_MODE_MAILBOX_KHR) {
-      m_latency = "N/A";
-      return;
-    }
-
-    auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(time - m_lastUpdate);
-
-    if (elapsed.count() >= UpdateInterval) {
-      m_lastUpdate = time;
-
-      LatencyMarkersReader reader = framePacer->m_latencyMarkersStorage.getReader(100);
-      const LatencyMarkers* markers;
-      uint32_t count = 0;
-      uint64_t totalLatency = 0;
-      while (reader.getNext(markers)) {
-        totalLatency += markers->presentFinished - markers->gpuFinished;
-        ++count;
-      }
-
-      if (!count)
-        return;
-
-      uint64_t latency = totalLatency / count;
-      m_latency = str::format(latency / 1000, ".", (latency/100) % 10, " ms");
-    }
-  }
-
-
-  HudPos HudPresentLatencyItem::render(
-    const DxvkContextObjects& ctx,
-    const HudPipelineKey&     key,
-    const HudOptions&         options,
-          HudRenderer&        renderer,
-          HudPos              position) {
-
-    position.y += 12;
-    renderer.drawText(16, position, 0xff4040ffu, "Present latency:");
-    renderer.drawText(16, { position.x + 206, position.y },
-      0xffffffffu, m_latency);
-
-    position.y += 8;
-    return position;
-  }
-
-
   HudFrameTimeItem::HudFrameTimeItem(const Rc<DxvkDevice>& device, HudRenderer* renderer)
   : m_device            (device),
     m_gfxPipelineLayout (createPipelineLayout()) {
diff --git a/src/util/util_flush.cpp b/src/util/util_flush.cpp
index c22a9d3..1a094bb 100644
--- a/src/util/util_flush.cpp
+++ b/src/util/util_flush.cpp
@@ -42,13 +42,13 @@ namespace dxvk {
 
       case GpuFlushType::ImplicitStrongHint: {
         // Flush aggressively with a strong hint to reduce readback latency.
-        return chunkCount >= minChunkCount;
+        return chunkCount >= m_minChunkCount;
       }
 
       case GpuFlushType::ImplicitWeakHint: {
         // Aim for a higher number of chunks per submission with
         // a weak hint in order to avoid submitting too often.
-        if (chunkCount < 2 * minChunkCount)
+        if (chunkCount < 2 * m_minChunkCount)
           return false;
 
         // Actual heuristic is shared with synchronization commands
